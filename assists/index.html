<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Assists (Code Actions) - The Rust Analyzer Book</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="../index.html">Introduction</a></li><li class="chapter-item affix "><a href="../quickstart.html">Quick Start</a></li><li class="spacer"></li><li class="chapter-item "><a href="../installation/index.html"><strong aria-hidden="true">1.</strong> Installation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../installation/toolchain.html"><strong aria-hidden="true">1.1.</strong> Toolchain</a></li><li class="chapter-item "><a href="../installation/vscode.html"><strong aria-hidden="true">1.2.</strong> VS Code</a></li><li class="chapter-item "><a href="../installation/server_binary.html"><strong aria-hidden="true">1.3.</strong> Language Server Binary</a></li><li class="chapter-item "><a href="../installation/emacs.html"><strong aria-hidden="true">1.4.</strong> Emacs</a></li><li class="chapter-item "><a href="../installation/vim_neovim.html"><strong aria-hidden="true">1.5.</strong> Vim/NeoVim</a></li><li class="chapter-item "><a href="../installation/sublime_text.html"><strong aria-hidden="true">1.6.</strong> Sublime Text</a></li><li class="chapter-item "><a href="../installation/gnome_builder.html"><strong aria-hidden="true">1.7.</strong> GNOME Builder</a></li><li class="chapter-item "><a href="../installation/eclipse_ide.html"><strong aria-hidden="true">1.8.</strong> Eclipse IDE</a></li><li class="chapter-item "><a href="../installation/kate_text_editor.html"><strong aria-hidden="true">1.9.</strong> Kate Text Editor</a></li><li class="chapter-item "><a href="../installation/juci++.html"><strong aria-hidden="true">1.10.</strong> juCi++</a></li><li class="chapter-item "><a href="../installation/kakoune.html"><strong aria-hidden="true">1.11.</strong> Kakoune</a></li><li class="chapter-item "><a href="../installation/helix.html"><strong aria-hidden="true">1.12.</strong> Helix</a></li><li class="chapter-item "><a href="../installation/visual_studio_2022.html"><strong aria-hidden="true">1.13.</strong> Visual Studio 2022</a></li><li class="chapter-item "><a href="../installation/lapce.html"><strong aria-hidden="true">1.14.</strong> Lapce</a></li><li class="chapter-item "><a href="../installation/crates.html"><strong aria-hidden="true">1.15.</strong> Crates</a></li></ol></li><li class="chapter-item "><a href="../troubleshooting.html"><strong aria-hidden="true">2.</strong> Troubleshooting</a></li><li class="chapter-item "><a href="../configuration/index.html"><strong aria-hidden="true">3.</strong> Configuration</a></li><li class="chapter-item "><a href="../non_cargo_based_projects.html"><strong aria-hidden="true">4.</strong> Non-Cargo Based Projects</a></li><li class="chapter-item "><a href="../security.html"><strong aria-hidden="true">5.</strong> Security</a></li><li class="chapter-item "><a href="../privacy.html"><strong aria-hidden="true">6.</strong> Privacy</a></li><li class="chapter-item "><a href="../features/index.html"><strong aria-hidden="true">7.</strong> Features</a></li><li class="chapter-item expanded "><a href="../assists/index.html" class="active"><strong aria-hidden="true">8.</strong> Assists (Code Actions)</a></li><li class="chapter-item "><a href="../diagnostics/index.html"><strong aria-hidden="true">9.</strong> Diagnostics</a></li><li class="chapter-item "><a href="../editor_features/index.html"><strong aria-hidden="true">10.</strong> Editor Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../editor_features/vscode.html"><strong aria-hidden="true">10.1.</strong> VS Code</a></li></ol></li><li class="chapter-item "><a href="../contributing/index.html"><strong aria-hidden="true">11.</strong> Contributing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../contributing/guide.html"><strong aria-hidden="true">11.1.</strong> Guide</a></li><li class="chapter-item "><a href="../contributing/architecture.html"><strong aria-hidden="true">11.2.</strong> Architecture</a></li><li class="chapter-item "><a href="../contributing/style.html"><strong aria-hidden="true">11.3.</strong> Style</a></li><li class="chapter-item "><a href="../contributing/syntax.html"><strong aria-hidden="true">11.4.</strong> Syntax</a></li><li class="chapter-item "><a href="../contributing/debugging.html"><strong aria-hidden="true">11.5.</strong> Debugging</a></li><li class="chapter-item "><a href="../contributing/lsp-extensions.html"><strong aria-hidden="true">11.6.</strong> LSP Extensions</a></li><li class="spacer"></li></ol></li><li class="chapter-item "><a href="../sponsors.html">Sponsors</a></li><li class="chapter-item affix "><a href="../communication.html">Communication</a></li><li class="chapter-item affix "><a href="../license.html">License</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Analyzer Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-analyzer/rust-analyzer/tree/master/manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-analyzer/rust-analyzer/edit/master/manual/src/assists/README.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="assists-code-actions"><a class="header" href="#assists-code-actions">Assists (Code Actions)</a></h1>
<ul>
<li><a href="#add_braces">add_braces</a></li>
<li><a href="#add_explicit_type">add_explicit_type</a></li>
<li><a href="#add_hash">add_hash</a></li>
<li><a href="#add_impl_default_members">add_impl_default_members</a></li>
<li><a href="#add_impl_missing_members">add_impl_missing_members</a></li>
<li><a href="#add_label_to_loop">add_label_to_loop</a></li>
<li><a href="#add_lifetime_to_type">add_lifetime_to_type</a></li>
<li><a href="#add_missing_match_arms">add_missing_match_arms</a></li>
<li><a href="#add_return_type">add_return_type</a></li>
<li><a href="#add_turbo_fish">add_turbo_fish</a></li>
<li><a href="#apply_demorgan">apply_demorgan</a></li>
<li><a href="#auto_import">auto_import</a></li>
<li><a href="#change_visibility">change_visibility</a></li>
<li><a href="#convert_bool_then_to_if">convert_bool_then_to_if</a></li>
<li><a href="#convert_for_loop_with_for_each">convert_for_loop_with_for_each</a></li>
<li><a href="#convert_if_to_bool_then">convert_if_to_bool_then</a></li>
<li><a href="#convert_integer_literal">convert_integer_literal</a></li>
<li><a href="#convert_into_to_from">convert_into_to_from</a></li>
<li><a href="#convert_iter_for_each_to_for">convert_iter_for_each_to_for</a></li>
<li><a href="#convert_let_else_to_match">convert_let_else_to_match</a></li>
<li><a href="#convert_match_to_let_else">convert_match_to_let_else</a></li>
<li><a href="#convert_named_struct_to_tuple_struct">convert_named_struct_to_tuple_struct</a></li>
<li><a href="#convert_nested_function_to_closure">convert_nested_function_to_closure</a></li>
<li><a href="#convert_to_guarded_return">convert_to_guarded_return</a></li>
<li><a href="#convert_tuple_struct_to_named_struct">convert_tuple_struct_to_named_struct</a></li>
<li><a href="#convert_two_arm_bool_match_to_matches_macro">convert_two_arm_bool_match_to_matches_macro</a></li>
<li><a href="#convert_while_to_loop">convert_while_to_loop</a></li>
<li><a href="#destructure_tuple_binding">destructure_tuple_binding</a></li>
<li><a href="#desugar_doc_comment">desugar_doc_comment</a></li>
<li><a href="#expand_glob_import">expand_glob_import</a></li>
<li><a href="#extract_expressions_from_format_string">extract_expressions_from_format_string</a></li>
<li><a href="#extract_function">extract_function</a></li>
<li><a href="#extract_module">extract_module</a></li>
<li><a href="#extract_struct_from_enum_variant">extract_struct_from_enum_variant</a></li>
<li><a href="#extract_type_alias">extract_type_alias</a></li>
<li><a href="#extract_variable">extract_variable</a></li>
<li><a href="#fix_visibility">fix_visibility</a></li>
<li><a href="#flip_binexpr">flip_binexpr</a></li>
<li><a href="#flip_comma">flip_comma</a></li>
<li><a href="#flip_trait_bound">flip_trait_bound</a></li>
<li><a href="#generate_constant">generate_constant</a></li>
<li><a href="#generate_default_from_enum_variant">generate_default_from_enum_variant</a></li>
<li><a href="#generate_default_from_new">generate_default_from_new</a></li>
<li><a href="#generate_delegate_methods">generate_delegate_methods</a></li>
<li><a href="#generate_delegate_trait">generate_delegate_trait</a></li>
<li><a href="#generate_deref">generate_deref</a></li>
<li><a href="#generate_derive">generate_derive</a></li>
<li><a href="#generate_doc_example">generate_doc_example</a></li>
<li><a href="#generate_documentation_template">generate_documentation_template</a></li>
<li><a href="#generate_enum_as_method">generate_enum_as_method</a></li>
<li><a href="#generate_enum_is_method">generate_enum_is_method</a></li>
<li><a href="#generate_enum_try_into_method">generate_enum_try_into_method</a></li>
<li><a href="#generate_enum_variant">generate_enum_variant</a></li>
<li><a href="#generate_from_impl_for_enum">generate_from_impl_for_enum</a></li>
<li><a href="#generate_function">generate_function</a></li>
<li><a href="#generate_getter">generate_getter</a></li>
<li><a href="#generate_getter_mut">generate_getter_mut</a></li>
<li><a href="#generate_impl">generate_impl</a></li>
<li><a href="#generate_is_empty_from_len">generate_is_empty_from_len</a></li>
<li><a href="#generate_new">generate_new</a></li>
<li><a href="#generate_setter">generate_setter</a></li>
<li><a href="#generate_trait_from_impl">generate_trait_from_impl</a></li>
<li><a href="#generate_trait_impl">generate_trait_impl</a></li>
<li><a href="#inline_call">inline_call</a></li>
<li><a href="#inline_const_as_literal">inline_const_as_literal</a></li>
<li><a href="#inline_into_callers">inline_into_callers</a></li>
<li><a href="#inline_local_variable">inline_local_variable</a></li>
<li><a href="#inline_macro">inline_macro</a></li>
<li><a href="#inline_type_alias">inline_type_alias</a></li>
<li><a href="#inline_type_alias_uses">inline_type_alias_uses</a></li>
<li><a href="#introduce_named_generic">introduce_named_generic</a></li>
<li><a href="#introduce_named_lifetime">introduce_named_lifetime</a></li>
<li><a href="#invert_if">invert_if</a></li>
<li><a href="#line_to_block">line_to_block</a></li>
<li><a href="#make_raw_string">make_raw_string</a></li>
<li><a href="#make_usual_string">make_usual_string</a></li>
<li><a href="#merge_imports">merge_imports</a></li>
<li><a href="#merge_match_arms">merge_match_arms</a></li>
<li><a href="#move_arm_cond_to_match_guard">move_arm_cond_to_match_guard</a></li>
<li><a href="#move_bounds_to_where_clause">move_bounds_to_where_clause</a></li>
<li><a href="#move_const_to_impl">move_const_to_impl</a></li>
<li><a href="#move_from_mod_rs">move_from_mod_rs</a></li>
<li><a href="#move_guard_to_arm_body">move_guard_to_arm_body</a></li>
<li><a href="#move_module_to_file">move_module_to_file</a></li>
<li><a href="#move_to_mod_rs">move_to_mod_rs</a></li>
<li><a href="#promote_local_to_const">promote_local_to_const</a></li>
<li><a href="#pull_assignment_up">pull_assignment_up</a></li>
<li><a href="#qualify_method_call">qualify_method_call</a></li>
<li><a href="#qualify_path">qualify_path</a></li>
<li><a href="#reformat_number_literal">reformat_number_literal</a></li>
<li><a href="#remove_dbg">remove_dbg</a></li>
<li><a href="#remove_hash">remove_hash</a></li>
<li><a href="#remove_mut">remove_mut</a></li>
<li><a href="#remove_parentheses">remove_parentheses</a></li>
<li><a href="#remove_unused_param">remove_unused_param</a></li>
<li><a href="#reorder_fields">reorder_fields</a></li>
<li><a href="#reorder_impl_items">reorder_impl_items</a></li>
<li><a href="#replace_arith_with_checked">replace_arith_with_checked</a></li>
<li><a href="#replace_arith_with_saturating">replace_arith_with_saturating</a></li>
<li><a href="#replace_arith_with_wrapping">replace_arith_with_wrapping</a></li>
<li><a href="#replace_char_with_string">replace_char_with_string</a></li>
<li><a href="#replace_derive_with_manual_impl">replace_derive_with_manual_impl</a></li>
<li><a href="#replace_if_let_with_match">replace_if_let_with_match</a></li>
<li><a href="#replace_let_with_if_let">replace_let_with_if_let</a></li>
<li><a href="#replace_match_with_if_let">replace_match_with_if_let</a></li>
<li><a href="#replace_named_generic_with_impl">replace_named_generic_with_impl</a></li>
<li><a href="#replace_qualified_name_with_use">replace_qualified_name_with_use</a></li>
<li><a href="#replace_string_with_char">replace_string_with_char</a></li>
<li><a href="#replace_try_expr_with_match">replace_try_expr_with_match</a></li>
<li><a href="#replace_turbofish_with_explicit_type">replace_turbofish_with_explicit_type</a></li>
<li><a href="#replace_with_eager_method">replace_with_eager_method</a></li>
<li><a href="#replace_with_lazy_method">replace_with_lazy_method</a></li>
<li><a href="#sort_items">sort_items</a></li>
<li><a href="#split_import">split_import</a></li>
<li><a href="#toggle_ignore">toggle_ignore</a></li>
<li><a href="#unmerge_match_arm">unmerge_match_arm</a></li>
<li><a href="#unmerge_use">unmerge_use</a></li>
<li><a href="#unnecessary_async">unnecessary_async</a></li>
<li><a href="#unqualify_method_call">unqualify_method_call</a></li>
<li><a href="#unwrap_block">unwrap_block</a></li>
<li><a href="#unwrap_result_return_type">unwrap_result_return_type</a></li>
<li><a href="#unwrap_tuple">unwrap_tuple</a></li>
<li><a href="#wrap_return_type_in_result">wrap_return_type_in_result</a></li>
</ul>
<h3 id="add_braces"><a class="header" href="#add_braces">add_braces</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_braces.rs#L8">add_braces.rs</a></p>
<blockquote>
<p>Adds braces to lambda and match arm expressions.</p>
</blockquote>
<h4 id="before"><a class="header" href="#before">Before</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    match n {
        1 =&gt;┃ n + 1,
        _ =&gt; 0
    }
}</code></pre>
<h4 id="after"><a class="header" href="#after">After</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    match n {
        1 =&gt; {
            n + 1
        },
        _ =&gt; 0
    }
}</code></pre>
<h3 id="add_explicit_type"><a class="header" href="#add_explicit_type">add_explicit_type</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_explicit_type.rs#L7">add_explicit_type.rs</a></p>
<blockquote>
<p>Specify type for a let binding.</p>
</blockquote>
<h4 id="before-1"><a class="header" href="#before-1">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x┃ = 92;
}</code></pre>
<h4 id="after-1"><a class="header" href="#after-1">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x: i32 = 92;
}</code></pre>
<h3 id="add_hash"><a class="header" href="#add_hash">add_hash</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L89">raw_string.rs</a></p>
<blockquote>
<p>Adds a hash to a raw string literal.</p>
</blockquote>
<h4 id="before-2"><a class="header" href="#before-2">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello,┃ World!&quot;#;
}</code></pre>
<h4 id="after-2"><a class="header" href="#after-2">After</a></h4>
<pre><code class="language-rust">fn main() {
    r##&quot;Hello, World!&quot;##;
}</code></pre>
<h3 id="add_impl_default_members"><a class="header" href="#add_impl_default_members">add_impl_default_members</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_missing_impl_members.rs#L51">add_missing_impl_members.rs</a></p>
<blockquote>
<p>Adds scaffold for overriding default impl members.</p>
</blockquote>
<h4 id="before-3"><a class="header" href="#before-3">Before</a></h4>
<pre><code class="language-rust">trait Trait {
    type X;
    fn foo(&amp;self);
    fn bar(&amp;self) {}
}

impl Trait for () {
    type X = ();
    fn foo(&amp;self) {}┃
}</code></pre>
<h4 id="after-3"><a class="header" href="#after-3">After</a></h4>
<pre><code class="language-rust">trait Trait {
    type X;
    fn foo(&amp;self);
    fn bar(&amp;self) {}
}

impl Trait for () {
    type X = ();
    fn foo(&amp;self) {}

    ┃fn bar(&amp;self) {}
}</code></pre>
<h3 id="add_impl_missing_members"><a class="header" href="#add_impl_missing_members">add_impl_missing_members</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_missing_impl_members.rs#L10">add_missing_impl_members.rs</a></p>
<blockquote>
<p>Adds scaffold for required impl members.</p>
</blockquote>
<h4 id="before-4"><a class="header" href="#before-4">Before</a></h4>
<pre><code class="language-rust">trait Trait&lt;T&gt; {
    type X;
    fn foo(&amp;self) -&gt; T;
    fn bar(&amp;self) {}
}

impl Trait&lt;u32&gt; for () {┃

}</code></pre>
<h4 id="after-4"><a class="header" href="#after-4">After</a></h4>
<pre><code class="language-rust">trait Trait&lt;T&gt; {
    type X;
    fn foo(&amp;self) -&gt; T;
    fn bar(&amp;self) {}
}

impl Trait&lt;u32&gt; for () {
    ┃type X;

    fn foo(&amp;self) -&gt; u32 {
        todo!()
    }
}</code></pre>
<h3 id="add_label_to_loop"><a class="header" href="#add_label_to_loop">add_label_to_loop</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_label_to_loop.rs#L9">add_label_to_loop.rs</a></p>
<blockquote>
<p>Adds a label to a loop.</p>
</blockquote>
<h4 id="before-5"><a class="header" href="#before-5">Before</a></h4>
<pre><code class="language-rust">fn main() {
    loop┃ {
        break;
        continue;
    }
}</code></pre>
<h4 id="after-5"><a class="header" href="#after-5">After</a></h4>
<pre><code class="language-rust">fn main() {
    'l: loop {
        break 'l;
        continue 'l;
    }
}</code></pre>
<h3 id="add_lifetime_to_type"><a class="header" href="#add_lifetime_to_type">add_lifetime_to_type</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_lifetime_to_type.rs#L5">add_lifetime_to_type.rs</a></p>
<blockquote>
<p>Adds a new lifetime to a struct, enum or union.</p>
</blockquote>
<h4 id="before-6"><a class="header" href="#before-6">Before</a></h4>
<pre><code class="language-rust">struct Point {
    x: &amp;┃u32,
    y: u32,
}</code></pre>
<h4 id="after-6"><a class="header" href="#after-6">After</a></h4>
<pre><code class="language-rust">struct Point&lt;'a&gt; {
    x: &amp;'a u32,
    y: u32,
}</code></pre>
<h3 id="add_missing_match_arms"><a class="header" href="#add_missing_match_arms">add_missing_match_arms</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_missing_match_arms.rs#L16">add_missing_match_arms.rs</a></p>
<blockquote>
<p>Adds missing clauses to a <code>match</code> expression.</p>
</blockquote>
<h4 id="before-7"><a class="header" href="#before-7">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ┃
    }
}</code></pre>
<h4 id="after-7"><a class="header" href="#after-7">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ┃Action::Move { distance } =&gt; todo!(),
        Action::Stop =&gt; todo!(),
    }
}</code></pre>
<h3 id="add_return_type"><a class="header" href="#add_return_type">add_return_type</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_return_type.rs#L6">add_return_type.rs</a></p>
<blockquote>
<p>Adds the return type to a function or closure inferred from its tail expression if it doesn't have a return
type specified. This assists is useable in a functions or closures tail expression or return type position.</p>
</blockquote>
<h4 id="before-8"><a class="header" href="#before-8">Before</a></h4>
<pre><code class="language-rust">fn foo() { 4┃2i32 }</code></pre>
<h4 id="after-8"><a class="header" href="#after-8">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="add_turbo_fish"><a class="header" href="#add_turbo_fish">add_turbo_fish</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/add_turbo_fish.rs#L10">add_turbo_fish.rs</a></p>
<blockquote>
<p>Adds <code>::&lt;_&gt;</code> to a call of a generic method or function.</p>
</blockquote>
<h4 id="before-9"><a class="header" href="#before-9">Before</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { todo!() }
fn main() {
    let x = make┃();
}</code></pre>
<h4 id="after-9"><a class="header" href="#after-9">After</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { todo!() }
fn main() {
    let x = make::&lt;${0:_}&gt;();
}</code></pre>
<h3 id="apply_demorgan"><a class="header" href="#apply_demorgan">apply_demorgan</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/apply_demorgan.rs#L7">apply_demorgan.rs</a></p>
<blockquote>
<p>Apply https://en.wikipedia.org/wiki/De_Morgan%27s_laws[De Morgan's law].
This transforms expressions of the form <code>!l || !r</code> into <code>!(l &amp;&amp; r)</code>.
This also works with <code>&amp;&amp;</code>. This assist can only be applied with the cursor
on either <code>||</code> or <code>&amp;&amp;</code>.</p>
</blockquote>
<h4 id="before-10"><a class="header" href="#before-10">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if x != 4 ||┃ y &lt; 3.14 {}
}</code></pre>
<h4 id="after-10"><a class="header" href="#after-10">After</a></h4>
<pre><code class="language-rust">fn main() {
    if !(x == 4 &amp;&amp; y &gt;= 3.14) {}
}</code></pre>
<h3 id="auto_import"><a class="header" href="#auto_import">auto_import</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/auto_import.rs#L71">auto_import.rs</a></p>
<blockquote>
<p>If the name is unresolved, provides all possible imports for it.</p>
</blockquote>
<h4 id="before-11"><a class="header" href="#before-11">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let map = HashMap┃::new();
}</code></pre>
<h4 id="after-11"><a class="header" href="#after-11">After</a></h4>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
}</code></pre>
<h3 id="change_visibility"><a class="header" href="#change_visibility">change_visibility</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/change_visibility.rs#L12">change_visibility.rs</a></p>
<blockquote>
<p>Adds or changes existing visibility specifier.</p>
</blockquote>
<h4 id="before-12"><a class="header" href="#before-12">Before</a></h4>
<pre><code class="language-rust">┃fn frobnicate() {}</code></pre>
<h4 id="after-12"><a class="header" href="#after-12">After</a></h4>
<pre><code class="language-rust">pub(crate) fn frobnicate() {}</code></pre>
<h3 id="convert_bool_then_to_if"><a class="header" href="#convert_bool_then_to_if">convert_bool_then_to_if</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_bool_then.rs#L132">convert_bool_then.rs</a></p>
<blockquote>
<p>Converts a <code>bool::then</code> method call to an equivalent if expression.</p>
</blockquote>
<h4 id="before-13"><a class="header" href="#before-13">Before</a></h4>
<pre><code class="language-rust">fn main() {
    (0 == 0).then┃(|| val)
}</code></pre>
<h4 id="after-13"><a class="header" href="#after-13">After</a></h4>
<pre><code class="language-rust">fn main() {
    if 0 == 0 {
        Some(val)
    } else {
        None
    }
}</code></pre>
<h3 id="convert_for_loop_with_for_each"><a class="header" href="#convert_for_loop_with_for_each">convert_for_loop_with_for_each</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs#L76">convert_iter_for_each_to_for.rs</a></p>
<blockquote>
<p>Converts a for loop into a for_each loop on the Iterator.</p>
</blockquote>
<h4 id="before-14"><a class="header" href="#before-14">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    for┃ v in x {
        let y = v * 2;
    }
}</code></pre>
<h4 id="after-14"><a class="header" href="#after-14">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    x.into_iter().for_each(|v| {
        let y = v * 2;
    });
}</code></pre>
<h3 id="convert_if_to_bool_then"><a class="header" href="#convert_if_to_bool_then">convert_if_to_bool_then</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_bool_then.rs#L20">convert_bool_then.rs</a></p>
<blockquote>
<p>Converts an if expression into a corresponding <code>bool::then</code> call.</p>
</blockquote>
<h4 id="before-15"><a class="header" href="#before-15">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if┃ cond {
        Some(val)
    } else {
        None
    }
}</code></pre>
<h4 id="after-15"><a class="header" href="#after-15">After</a></h4>
<pre><code class="language-rust">fn main() {
    cond.then(|| val)
}</code></pre>
<h3 id="convert_integer_literal"><a class="header" href="#convert_integer_literal">convert_integer_literal</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_integer_literal.rs#L5">convert_integer_literal.rs</a></p>
<blockquote>
<p>Converts the base of integer literals to other bases.</p>
</blockquote>
<h4 id="before-16"><a class="header" href="#before-16">Before</a></h4>
<pre><code class="language-rust">const _: i32 = 10┃;</code></pre>
<h4 id="after-16"><a class="header" href="#after-16">After</a></h4>
<pre><code class="language-rust">const _: i32 = 0b1010;</code></pre>
<h3 id="convert_into_to_from"><a class="header" href="#convert_into_to_from">convert_into_to_from</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_into_to_from.rs#L8">convert_into_to_from.rs</a></p>
<blockquote>
<p>Converts an Into impl to an equivalent From impl.</p>
</blockquote>
<h4 id="before-17"><a class="header" href="#before-17">Before</a></h4>
<pre><code class="language-rust">impl ┃Into&lt;Thing&gt; for usize {
    fn into(self) -&gt; Thing {
        Thing {
            b: self.to_string(),
            a: self
        }
    }
}</code></pre>
<h4 id="after-17"><a class="header" href="#after-17">After</a></h4>
<pre><code class="language-rust">impl From&lt;usize&gt; for Thing {
    fn from(val: usize) -&gt; Self {
        Thing {
            b: val.to_string(),
            a: val
        }
    }
}</code></pre>
<h3 id="convert_iter_for_each_to_for"><a class="header" href="#convert_iter_for_each_to_for">convert_iter_for_each_to_for</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs#L11">convert_iter_for_each_to_for.rs</a></p>
<blockquote>
<p>Converts an Iterator::for_each function into a for loop.</p>
</blockquote>
<h4 id="before-18"><a class="header" href="#before-18">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let iter = iter::repeat((9, 2));
    iter.for_each┃(|(x, y)| {
        println!(&quot;x: {}, y: {}&quot;, x, y);
    });
}</code></pre>
<h4 id="after-18"><a class="header" href="#after-18">After</a></h4>
<pre><code class="language-rust">fn main() {
    let iter = iter::repeat((9, 2));
    for (x, y) in iter {
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}</code></pre>
<h3 id="convert_let_else_to_match"><a class="header" href="#convert_let_else_to_match">convert_let_else_to_match</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_let_else_to_match.rs#L8">convert_let_else_to_match.rs</a></p>
<blockquote>
<p>Converts let-else statement to let statement and match expression.</p>
</blockquote>
<h4 id="before-19"><a class="header" href="#before-19">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let Ok(mut x) = f() else┃ { return };
}</code></pre>
<h4 id="after-19"><a class="header" href="#after-19">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut x = match f() {
        Ok(x) =&gt; x,
        _ =&gt; return,
    };
}</code></pre>
<h3 id="convert_match_to_let_else"><a class="header" href="#convert_match_to_let_else">convert_match_to_let_else</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_match_to_let_else.rs#L12">convert_match_to_let_else.rs</a></p>
<blockquote>
<p>Converts let statement with match initializer to let-else statement.</p>
</blockquote>
<h4 id="before-20"><a class="header" href="#before-20">Before</a></h4>
<pre><code class="language-rust">fn foo(opt: Option&lt;()&gt;) {
    let val┃ = match opt {
        Some(it) =&gt; it,
        None =&gt; return,
    };
}</code></pre>
<h4 id="after-20"><a class="header" href="#after-20">After</a></h4>
<pre><code class="language-rust">fn foo(opt: Option&lt;()&gt;) {
    let Some(val) = opt else { return };
}</code></pre>
<h3 id="convert_named_struct_to_tuple_struct"><a class="header" href="#convert_named_struct_to_tuple_struct">convert_named_struct_to_tuple_struct</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs#L11">convert_named_struct_to_tuple_struct.rs</a></p>
<blockquote>
<p>Converts struct with named fields to tuple struct, and analogously for enum variants with named
fields.</p>
</blockquote>
<h4 id="before-21"><a class="header" href="#before-21">Before</a></h4>
<pre><code class="language-rust">struct Point┃ { x: f32, y: f32 }

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point { x, y }
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.x
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.y
    }
}</code></pre>
<h4 id="after-21"><a class="header" href="#after-21">After</a></h4>
<pre><code class="language-rust">struct Point(f32, f32);

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point(x, y)
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.0
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.1
    }
}</code></pre>
<h3 id="convert_nested_function_to_closure"><a class="header" href="#convert_nested_function_to_closure">convert_nested_function_to_closure</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_nested_function_to_closure.rs#L7">convert_nested_function_to_closure.rs</a></p>
<blockquote>
<p>Converts a function that is defined within the body of another function into a closure.</p>
</blockquote>
<h4 id="before-22"><a class="header" href="#before-22">Before</a></h4>
<pre><code class="language-rust">fn main() {
    fn fo┃o(label: &amp;str, number: u64) {
        println!(&quot;{}: {}&quot;, label, number);
    }

    foo(&quot;Bar&quot;, 100);
}</code></pre>
<h4 id="after-22"><a class="header" href="#after-22">After</a></h4>
<pre><code class="language-rust">fn main() {
    let foo = |label: &amp;str, number: u64| {
        println!(&quot;{}: {}&quot;, label, number);
    };

    foo(&quot;Bar&quot;, 100);
}</code></pre>
<h3 id="convert_to_guarded_return"><a class="header" href="#convert_to_guarded_return">convert_to_guarded_return</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_to_guarded_return.rs#L21">convert_to_guarded_return.rs</a></p>
<blockquote>
<p>Replace a large conditional with a guarded return.</p>
</blockquote>
<h4 id="before-23"><a class="header" href="#before-23">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃if cond {
        foo();
        bar();
    }
}</code></pre>
<h4 id="after-23"><a class="header" href="#after-23">After</a></h4>
<pre><code class="language-rust">fn main() {
    if !cond {
        return;
    }
    foo();
    bar();
}</code></pre>
<h3 id="convert_tuple_struct_to_named_struct"><a class="header" href="#convert_tuple_struct_to_named_struct">convert_tuple_struct_to_named_struct</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs#L10">convert_tuple_struct_to_named_struct.rs</a></p>
<blockquote>
<p>Converts tuple struct to struct with named fields, and analogously for tuple enum variants.</p>
</blockquote>
<h4 id="before-24"><a class="header" href="#before-24">Before</a></h4>
<pre><code class="language-rust">struct Point┃(f32, f32);

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point(x, y)
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.0
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.1
    }
}</code></pre>
<h4 id="after-24"><a class="header" href="#after-24">After</a></h4>
<pre><code class="language-rust">struct Point { field1: f32, field2: f32 }

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point { field1: x, field2: y }
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.field1
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.field2
    }
}</code></pre>
<h3 id="convert_two_arm_bool_match_to_matches_macro"><a class="header" href="#convert_two_arm_bool_match_to_matches_macro">convert_two_arm_bool_match_to_matches_macro</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_two_arm_bool_match_to_matches_macro.rs#L5">convert_two_arm_bool_match_to_matches_macro.rs</a></p>
<blockquote>
<p>Convert 2-arm match that evaluates to a boolean into the equivalent matches! invocation.</p>
</blockquote>
<h4 id="before-25"><a class="header" href="#before-25">Before</a></h4>
<pre><code class="language-rust">fn main() {
    match scrutinee┃ {
        Some(val) if val.cond() =&gt; true,
        _ =&gt; false,
    }
}</code></pre>
<h4 id="after-25"><a class="header" href="#after-25">After</a></h4>
<pre><code class="language-rust">fn main() {
    matches!(scrutinee, Some(val) if val.cond())
}</code></pre>
<h3 id="convert_while_to_loop"><a class="header" href="#convert_while_to_loop">convert_while_to_loop</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_while_to_loop.rs#L19">convert_while_to_loop.rs</a></p>
<blockquote>
<p>Replace a while with a loop.</p>
</blockquote>
<h4 id="before-26"><a class="header" href="#before-26">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃while cond {
        foo();
    }
}</code></pre>
<h4 id="after-26"><a class="header" href="#after-26">After</a></h4>
<pre><code class="language-rust">fn main() {
    loop {
        if !cond {
            break;
        }
        foo();
    }
}</code></pre>
<h3 id="destructure_tuple_binding"><a class="header" href="#destructure_tuple_binding">destructure_tuple_binding</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/destructure_tuple_binding.rs#L13">destructure_tuple_binding.rs</a></p>
<blockquote>
<p>Destructures a tuple binding in place.</p>
</blockquote>
<h4 id="before-27"><a class="header" href="#before-27">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let ┃t = (1,2);
    let v = t.0;
}</code></pre>
<h4 id="after-27"><a class="header" href="#after-27">After</a></h4>
<pre><code class="language-rust">fn main() {
    let (┃_0, _1) = (1,2);
    let v = _0;
}</code></pre>
<h3 id="desugar_doc_comment"><a class="header" href="#desugar_doc_comment">desugar_doc_comment</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/desugar_doc_comment.rs#L14">desugar_doc_comment.rs</a></p>
<blockquote>
<p>Desugars doc-comments to the attribute form.</p>
</blockquote>
<h4 id="before-28"><a class="header" href="#before-28">Before</a></h4>
<pre><code class="language-rust">/// Multi-line┃
/// comment</code></pre>
<h4 id="after-28"><a class="header" href="#after-28">After</a></h4>
<pre><code class="language-rust">#[doc = r&quot;Multi-line
comment&quot;]</code></pre>
<h3 id="expand_glob_import"><a class="header" href="#expand_glob_import">expand_glob_import</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/expand_glob_import.rs#L18">expand_glob_import.rs</a></p>
<blockquote>
<p>Expands glob imports.</p>
</blockquote>
<h4 id="before-29"><a class="header" href="#before-29">Before</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

use foo::*┃;

fn qux(bar: Bar, baz: Baz) {}</code></pre>
<h4 id="after-29"><a class="header" href="#after-29">After</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

use foo::{Bar, Baz};

fn qux(bar: Bar, baz: Baz) {}</code></pre>
<h3 id="extract_expressions_from_format_string"><a class="header" href="#extract_expressions_from_format_string">extract_expressions_from_format_string</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_expressions_from_format_string.rs#L13">extract_expressions_from_format_string.rs</a></p>
<blockquote>
<p>Move an expression out of a format string.</p>
</blockquote>
<h4 id="before-30"><a class="header" href="#before-30">Before</a></h4>
<pre><code class="language-rust">macro_rules! format_args {
    ($lit:literal $(tt:tt)*) =&gt; { 0 },
}
macro_rules! print {
    ($($arg:tt)*) =&gt; (std::io::_print(format_args!($($arg)*)));
}

fn main() {
    print!(&quot;{var} {x + 1}┃&quot;);
}</code></pre>
<h4 id="after-30"><a class="header" href="#after-30">After</a></h4>
<pre><code class="language-rust">macro_rules! format_args {
    ($lit:literal $(tt:tt)*) =&gt; { 0 },
}
macro_rules! print {
    ($($arg:tt)*) =&gt; (std::io::_print(format_args!($($arg)*)));
}

fn main() {
    print!(&quot;{var} {}&quot;┃, x + 1);
}</code></pre>
<h3 id="extract_function"><a class="header" href="#extract_function">extract_function</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_function.rs#L39">extract_function.rs</a></p>
<blockquote>
<p>Extracts selected statements and comments into new function.</p>
</blockquote>
<h4 id="before-31"><a class="header" href="#before-31">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let n = 1;
    ┃let m = n + 2;
    // calculate
    let k = m + n;┃
    let g = 3;
}</code></pre>
<h4 id="after-31"><a class="header" href="#after-31">After</a></h4>
<pre><code class="language-rust">fn main() {
    let n = 1;
    fun_name(n);
    let g = 3;
}

fn ┃fun_name(n: i32) {
    let m = n + 2;
    // calculate
    let k = m + n;
}</code></pre>
<h3 id="extract_module"><a class="header" href="#extract_module">extract_module</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_module.rs#L32">extract_module.rs</a></p>
<blockquote>
<p>Extracts a selected region as separate module. All the references, visibility and imports are
resolved.</p>
</blockquote>
<h4 id="before-32"><a class="header" href="#before-32">Before</a></h4>
<pre><code class="language-rust">┃fn foo(name: i32) -&gt; i32 {
    name + 1
}┃

fn bar(name: i32) -&gt; i32 {
    name + 2
}</code></pre>
<h4 id="after-32"><a class="header" href="#after-32">After</a></h4>
<pre><code class="language-rust">mod modname {
    pub(crate) fn foo(name: i32) -&gt; i32 {
        name + 1
    }
}

fn bar(name: i32) -&gt; i32 {
    name + 2
}</code></pre>
<h3 id="extract_struct_from_enum_variant"><a class="header" href="#extract_struct_from_enum_variant">extract_struct_from_enum_variant</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs#L25">extract_struct_from_enum_variant.rs</a></p>
<blockquote>
<p>Extracts a struct from enum variant.</p>
</blockquote>
<h4 id="before-33"><a class="header" href="#before-33">Before</a></h4>
<pre><code class="language-rust">enum A { ┃One(u32, u32) }</code></pre>
<h4 id="after-33"><a class="header" href="#after-33">After</a></h4>
<pre><code class="language-rust">struct One(u32, u32);

enum A { One(One) }</code></pre>
<h3 id="extract_type_alias"><a class="header" href="#extract_type_alias">extract_type_alias</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_type_alias.rs#L10">extract_type_alias.rs</a></p>
<blockquote>
<p>Extracts the selected type as a type alias.</p>
</blockquote>
<h4 id="before-34"><a class="header" href="#before-34">Before</a></h4>
<pre><code class="language-rust">struct S {
    field: ┃(u8, u8, u8)┃,
}</code></pre>
<h4 id="after-34"><a class="header" href="#after-34">After</a></h4>
<pre><code class="language-rust">type ┃Type = (u8, u8, u8);

struct S {
    field: Type,
}</code></pre>
<h3 id="extract_variable"><a class="header" href="#extract_variable">extract_variable</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/extract_variable.rs#L15">extract_variable.rs</a></p>
<blockquote>
<p>Extracts subexpression into a variable.</p>
</blockquote>
<h4 id="before-35"><a class="header" href="#before-35">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃(1 + 2)┃ * 4;
}</code></pre>
<h4 id="after-35"><a class="header" href="#after-35">After</a></h4>
<pre><code class="language-rust">fn main() {
    let ┃var_name = (1 + 2);
    var_name * 4;
}</code></pre>
<h3 id="fix_visibility"><a class="header" href="#fix_visibility">fix_visibility</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/fix_visibility.rs#L12">fix_visibility.rs</a></p>
<blockquote>
<p>Makes inaccessible item public.</p>
</blockquote>
<h4 id="before-36"><a class="header" href="#before-36">Before</a></h4>
<pre><code class="language-rust">mod m {
    fn frobnicate() {}
}
fn main() {
    m::frobnicate┃();
}</code></pre>
<h4 id="after-36"><a class="header" href="#after-36">After</a></h4>
<pre><code class="language-rust">mod m {
    ┃pub(crate) fn frobnicate() {}
}
fn main() {
    m::frobnicate();
}</code></pre>
<h3 id="flip_binexpr"><a class="header" href="#flip_binexpr">flip_binexpr</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_binexpr.rs#L5">flip_binexpr.rs</a></p>
<blockquote>
<p>Flips operands of a binary expression.</p>
</blockquote>
<h4 id="before-37"><a class="header" href="#before-37">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 90 +┃ 2;
}</code></pre>
<h4 id="after-37"><a class="header" href="#after-37">After</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 2 + 90;
}</code></pre>
<h3 id="flip_comma"><a class="header" href="#flip_comma">flip_comma</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_comma.rs#L5">flip_comma.rs</a></p>
<blockquote>
<p>Flips two comma-separated items.</p>
</blockquote>
<h4 id="before-38"><a class="header" href="#before-38">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ((1, 2),┃ (3, 4));
}</code></pre>
<h4 id="after-38"><a class="header" href="#after-38">After</a></h4>
<pre><code class="language-rust">fn main() {
    ((3, 4), (1, 2));
}</code></pre>
<h3 id="flip_trait_bound"><a class="header" href="#flip_trait_bound">flip_trait_bound</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/flip_trait_bound.rs#L9">flip_trait_bound.rs</a></p>
<blockquote>
<p>Flips two trait bounds.</p>
</blockquote>
<h4 id="before-39"><a class="header" href="#before-39">Before</a></h4>
<pre><code class="language-rust">fn foo&lt;T: Clone +┃ Copy&gt;() { }</code></pre>
<h4 id="after-39"><a class="header" href="#after-39">After</a></h4>
<pre><code class="language-rust">fn foo&lt;T: Copy + Clone&gt;() { }</code></pre>
<h3 id="generate_constant"><a class="header" href="#generate_constant">generate_constant</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_constant.rs#L13">generate_constant.rs</a></p>
<blockquote>
<p>Generate a named constant.</p>
</blockquote>
<h4 id="before-40"><a class="header" href="#before-40">Before</a></h4>
<pre><code class="language-rust">struct S { i: usize }
impl S { pub fn new(n: usize) {} }
fn main() {
    let v = S::new(CAPA┃CITY);
}</code></pre>
<h4 id="after-40"><a class="header" href="#after-40">After</a></h4>
<pre><code class="language-rust">struct S { i: usize }
impl S { pub fn new(n: usize) {} }
fn main() {
    const CAPACITY: usize = ┃;
    let v = S::new(CAPACITY);
}</code></pre>
<h3 id="generate_default_from_enum_variant"><a class="header" href="#generate_default_from_enum_variant">generate_default_from_enum_variant</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_default_from_enum_variant.rs#L6">generate_default_from_enum_variant.rs</a></p>
<blockquote>
<p>Adds a Default impl for an enum using a variant.</p>
</blockquote>
<h4 id="before-41"><a class="header" href="#before-41">Before</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor┃,
 Major,
}</code></pre>
<h4 id="after-41"><a class="header" href="#after-41">After</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor,
 Major,
}

impl Default for Version {
    fn default() -&gt; Self {
        Self::Minor
    }
}</code></pre>
<h3 id="generate_default_from_new"><a class="header" href="#generate_default_from_new">generate_default_from_new</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_default_from_new.rs#L13">generate_default_from_new.rs</a></p>
<blockquote>
<p>Generates default implementation from new method.</p>
</blockquote>
<h4 id="before-42"><a class="header" href="#before-42">Before</a></h4>
<pre><code class="language-rust">struct Example { _inner: () }

impl Example {
    pub fn n┃ew() -&gt; Self {
        Self { _inner: () }
    }
}</code></pre>
<h4 id="after-42"><a class="header" href="#after-42">After</a></h4>
<pre><code class="language-rust">struct Example { _inner: () }

impl Example {
    pub fn new() -&gt; Self {
        Self { _inner: () }
    }
}

impl Default for Example {
    fn default() -&gt; Self {
        Self::new()
    }
}</code></pre>
<h3 id="generate_delegate_methods"><a class="header" href="#generate_delegate_methods">generate_delegate_methods</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_delegate_methods.rs#L16">generate_delegate_methods.rs</a></p>
<blockquote>
<p>Generate delegate methods.</p>
</blockquote>
<h4 id="before-43"><a class="header" href="#before-43">Before</a></h4>
<pre><code class="language-rust">struct Age(u8);
impl Age {
    fn age(&amp;self) -&gt; u8 {
        self.0
    }
}

struct Person {
    ag┃e: Age,
}</code></pre>
<h4 id="after-43"><a class="header" href="#after-43">After</a></h4>
<pre><code class="language-rust">struct Age(u8);
impl Age {
    fn age(&amp;self) -&gt; u8 {
        self.0
    }
}

struct Person {
    age: Age,
}

impl Person {
    ┃fn age(&amp;self) -&gt; u8 {
        self.age.age()
    }
}</code></pre>
<h3 id="generate_delegate_trait"><a class="header" href="#generate_delegate_trait">generate_delegate_trait</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_delegate_trait.rs#L23">generate_delegate_trait.rs</a></p>
<blockquote>
<p>Generate delegate trait implementation for <code>StructField</code>s.</p>
</blockquote>
<h4 id="before-44"><a class="header" href="#before-44">Before</a></h4>
<pre><code class="language-rust">trait SomeTrait {
    type T;
    fn fn_(arg: u32) -&gt; u32;
    fn method_(&amp;mut self) -&gt; bool;
}
struct A;
impl SomeTrait for A {
    type T = u32;

    fn fn_(arg: u32) -&gt; u32 {
        42
    }

    fn method_(&amp;mut self) -&gt; bool {
        false
    }
}
struct B {
    a┃: A,
}</code></pre>
<h4 id="after-44"><a class="header" href="#after-44">After</a></h4>
<pre><code class="language-rust">trait SomeTrait {
    type T;
    fn fn_(arg: u32) -&gt; u32;
    fn method_(&amp;mut self) -&gt; bool;
}
struct A;
impl SomeTrait for A {
    type T = u32;

    fn fn_(arg: u32) -&gt; u32 {
        42
    }

    fn method_(&amp;mut self) -&gt; bool {
        false
    }
}
struct B {
    a: A,
}

impl SomeTrait for B {
    type T = &lt;A as SomeTrait&gt;::T;

    fn fn_(arg: u32) -&gt; u32 {
        &lt;A as SomeTrait&gt;::fn_(arg)
    }

    fn method_(&amp;mut self) -&gt; bool {
        &lt;A as SomeTrait&gt;::method_( &amp;mut self.a )
    }
}</code></pre>
<h3 id="generate_deref"><a class="header" href="#generate_deref">generate_deref</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_deref.rs#L16">generate_deref.rs</a></p>
<blockquote>
<p>Generate <code>Deref</code> impl using the given struct field.</p>
</blockquote>
<h4 id="before-45"><a class="header" href="#before-45">Before</a></h4>
<pre><code class="language-rust">struct A;
struct B {
   ┃a: A
}</code></pre>
<h4 id="after-45"><a class="header" href="#after-45">After</a></h4>
<pre><code class="language-rust">struct A;
struct B {
   a: A
}

impl core::ops::Deref for B {
    type Target = A;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.a
    }
}</code></pre>
<h3 id="generate_derive"><a class="header" href="#generate_derive">generate_derive</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_derive.rs#L8">generate_derive.rs</a></p>
<blockquote>
<p>Adds a new <code>#[derive()]</code> clause to a struct or enum.</p>
</blockquote>
<h4 id="before-46"><a class="header" href="#before-46">Before</a></h4>
<pre><code class="language-rust">struct Point {
    x: u32,
    y: u32,┃
}</code></pre>
<h4 id="after-46"><a class="header" href="#after-46">After</a></h4>
<pre><code class="language-rust">#[derive(┃)]
struct Point {
    x: u32,
    y: u32,
}</code></pre>
<h3 id="generate_doc_example"><a class="header" href="#generate_doc_example">generate_doc_example</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_documentation_template.rs#L76">generate_documentation_template.rs</a></p>
<blockquote>
<p>Generates a rustdoc example when editing an item's documentation.</p>
</blockquote>
<h4 id="before-47"><a class="header" href="#before-47">Before</a></h4>
<pre><code class="language-rust">/// Adds two numbers.┃
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
<h4 id="after-47"><a class="header" href="#after-47">After</a></h4>
<pre><code class="language-rust">/// Adds two numbers.
///
/// # Examples
///
/// ```
/// use test::add;
///
/// assert_eq!(add(a, b), );
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
<h3 id="generate_documentation_template"><a class="header" href="#generate_documentation_template">generate_documentation_template</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_documentation_template.rs#L13">generate_documentation_template.rs</a></p>
<blockquote>
<p>Adds a documentation template above a function definition / declaration.</p>
</blockquote>
<h4 id="before-48"><a class="header" href="#before-48">Before</a></h4>
<pre><code class="language-rust">pub struct S;
impl S {
    pub unsafe fn set_len┃(&amp;mut self, len: usize) -&gt; Result&lt;(), std::io::Error&gt; {
        /* ... */
    }
}</code></pre>
<h4 id="after-48"><a class="header" href="#after-48">After</a></h4>
<pre><code class="language-rust">pub struct S;
impl S {
    /// Sets the length of this [`S`].
    ///
    /// # Errors
    ///
    /// This function will return an error if .
    ///
    /// # Safety
    ///
    /// .
    pub unsafe fn set_len(&amp;mut self, len: usize) -&gt; Result&lt;(), std::io::Error&gt; {
        /* ... */
    }
}</code></pre>
<h3 id="generate_enum_as_method"><a class="header" href="#generate_enum_as_method">generate_enum_as_method</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_projection_method.rs#L59">generate_enum_projection_method.rs</a></p>
<blockquote>
<p>Generate an <code>as_</code> method for this enum variant.</p>
</blockquote>
<h4 id="before-49"><a class="header" href="#before-49">Before</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String)┃,
}</code></pre>
<h4 id="after-49"><a class="header" href="#after-49">After</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String),
}

impl Value {
    fn as_text(&amp;self) -&gt; Option&lt;&amp;String&gt; {
        if let Self::Text(v) = self {
            Some(v)
        } else {
            None
        }
    }
}</code></pre>
<h3 id="generate_enum_is_method"><a class="header" href="#generate_enum_is_method">generate_enum_is_method</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_is_method.rs#L11">generate_enum_is_method.rs</a></p>
<blockquote>
<p>Generate an <code>is_</code> method for this enum variant.</p>
</blockquote>
<h4 id="before-50"><a class="header" href="#before-50">Before</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor┃,
 Major,
}</code></pre>
<h4 id="after-50"><a class="header" href="#after-50">After</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor,
 Major,
}

impl Version {
    /// Returns `true` if the version is [`Minor`].
    ///
    /// [`Minor`]: Version::Minor
    #[must_use]
    fn is_minor(&amp;self) -&gt; bool {
        matches!(self, Self::Minor)
    }
}</code></pre>
<h3 id="generate_enum_try_into_method"><a class="header" href="#generate_enum_try_into_method">generate_enum_try_into_method</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_projection_method.rs#L12">generate_enum_projection_method.rs</a></p>
<blockquote>
<p>Generate a <code>try_into_</code> method for this enum variant.</p>
</blockquote>
<h4 id="before-51"><a class="header" href="#before-51">Before</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String)┃,
}</code></pre>
<h4 id="after-51"><a class="header" href="#after-51">After</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String),
}

impl Value {
    fn try_into_text(self) -&gt; Result&lt;String, Self&gt; {
        if let Self::Text(v) = self {
            Ok(v)
        } else {
            Err(self)
        }
    }
}</code></pre>
<h3 id="generate_enum_variant"><a class="header" href="#generate_enum_variant">generate_enum_variant</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_enum_variant.rs#L10">generate_enum_variant.rs</a></p>
<blockquote>
<p>Adds a variant to an enum.</p>
</blockquote>
<h4 id="before-52"><a class="header" href="#before-52">Before</a></h4>
<pre><code class="language-rust">enum Countries {
    Ghana,
}

fn main() {
    let country = Countries::Lesotho┃;
}</code></pre>
<h4 id="after-52"><a class="header" href="#after-52">After</a></h4>
<pre><code class="language-rust">enum Countries {
    Ghana,
    Lesotho,
}

fn main() {
    let country = Countries::Lesotho;
}</code></pre>
<h3 id="generate_from_impl_for_enum"><a class="header" href="#generate_from_impl_for_enum">generate_from_impl_for_enum</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs#L8">generate_from_impl_for_enum.rs</a></p>
<blockquote>
<p>Adds a From impl for this enum variant with one tuple field.</p>
</blockquote>
<h4 id="before-53"><a class="header" href="#before-53">Before</a></h4>
<pre><code class="language-rust">enum A { ┃One(u32) }</code></pre>
<h4 id="after-53"><a class="header" href="#after-53">After</a></h4>
<pre><code class="language-rust">enum A { One(u32) }

impl From&lt;u32&gt; for A {
    fn from(v: u32) -&gt; Self {
        Self::One(v)
    }
}</code></pre>
<h3 id="generate_function"><a class="header" href="#generate_function">generate_function</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_function.rs#L27">generate_function.rs</a></p>
<blockquote>
<p>Adds a stub function with a signature matching the function under the cursor.</p>
</blockquote>
<h4 id="before-54"><a class="header" href="#before-54">Before</a></h4>
<pre><code class="language-rust">struct Baz;
fn baz() -&gt; Baz { Baz }
fn foo() {
    bar┃(&quot;&quot;, baz());
}
</code></pre>
<h4 id="after-54"><a class="header" href="#after-54">After</a></h4>
<pre><code class="language-rust">struct Baz;
fn baz() -&gt; Baz { Baz }
fn foo() {
    bar(&quot;&quot;, baz());
}

fn bar(arg: &amp;str, baz: Baz) ${0:-&gt; _} {
    todo!()
}
</code></pre>
<h3 id="generate_getter"><a class="header" href="#generate_getter">generate_getter</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#L73">generate_getter_or_setter.rs</a></p>
<blockquote>
<p>Generate a getter method.</p>
</blockquote>
<h4 id="before-55"><a class="header" href="#before-55">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam┃e: String,
}</code></pre>
<h4 id="after-55"><a class="header" href="#after-55">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ┃name(&amp;self) -&gt; &amp;str {
        self.name.as_ref()
    }
}</code></pre>
<h3 id="generate_getter_mut"><a class="header" href="#generate_getter_mut">generate_getter_mut</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#L113">generate_getter_or_setter.rs</a></p>
<blockquote>
<p>Generate a mut getter method.</p>
</blockquote>
<h4 id="before-56"><a class="header" href="#before-56">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam┃e: String,
}</code></pre>
<h4 id="after-56"><a class="header" href="#after-56">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ┃name_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.name
    }
}</code></pre>
<h3 id="generate_impl"><a class="header" href="#generate_impl">generate_impl</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_impl.rs#L8">generate_impl.rs</a></p>
<blockquote>
<p>Adds a new inherent impl for a type.</p>
</blockquote>
<h4 id="before-57"><a class="header" href="#before-57">Before</a></h4>
<pre><code class="language-rust">struct Ctx┃&lt;T: Clone&gt; {
    data: T,
}</code></pre>
<h4 id="after-57"><a class="header" href="#after-57">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
    data: T,
}

impl&lt;T: Clone&gt; Ctx&lt;T&gt; {
    ┃
}</code></pre>
<h3 id="generate_is_empty_from_len"><a class="header" href="#generate_is_empty_from_len">generate_is_empty_from_len</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_is_empty_from_len.rs#L12">generate_is_empty_from_len.rs</a></p>
<blockquote>
<p>Generates is_empty implementation from the len method.</p>
</blockquote>
<h4 id="before-58"><a class="header" href="#before-58">Before</a></h4>
<pre><code class="language-rust">struct MyStruct { data: Vec&lt;String&gt; }

impl MyStruct {
    #[must_use]
    p┃ub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }
}</code></pre>
<h4 id="after-58"><a class="header" href="#after-58">After</a></h4>
<pre><code class="language-rust">struct MyStruct { data: Vec&lt;String&gt; }

impl MyStruct {
    #[must_use]
    pub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }

    #[must_use]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }
}</code></pre>
<h3 id="generate_new"><a class="header" href="#generate_new">generate_new</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_new.rs#L13">generate_new.rs</a></p>
<blockquote>
<p>Adds a <code>fn new</code> for a type.</p>
</blockquote>
<h4 id="before-59"><a class="header" href="#before-59">Before</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
     data: T,┃
}</code></pre>
<h4 id="after-59"><a class="header" href="#after-59">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
     data: T,
}

impl&lt;T: Clone&gt; Ctx&lt;T&gt; {
    fn ┃new(data: T) -&gt; Self { Self { data } }
}</code></pre>
<h3 id="generate_setter"><a class="header" href="#generate_setter">generate_setter</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#L13">generate_getter_or_setter.rs</a></p>
<blockquote>
<p>Generate a setter method.</p>
</blockquote>
<h4 id="before-60"><a class="header" href="#before-60">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam┃e: String,
}</code></pre>
<h4 id="after-60"><a class="header" href="#after-60">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ┃set_name(&amp;mut self, name: String) {
        self.name = name;
    }
}</code></pre>
<h3 id="generate_trait_from_impl"><a class="header" href="#generate_trait_from_impl">generate_trait_from_impl</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_trait_from_impl.rs#L13">generate_trait_from_impl.rs</a></p>
<blockquote>
<p>Generate trait for an already defined inherent impl and convert impl to a trait impl.</p>
</blockquote>
<h4 id="before-61"><a class="header" href="#before-61">Before</a></h4>
<pre><code class="language-rust">struct Foo&lt;const N: usize&gt;([i32; N]);

macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; {
        const CONST: $t = $v;
    };
}

impl&lt;const N: usize&gt; Fo┃o&lt;N&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt; {
        Some(())
    }

    const_maker! {i32, 7}
}</code></pre>
<h4 id="after-61"><a class="header" href="#after-61">After</a></h4>
<pre><code class="language-rust">struct Foo&lt;const N: usize&gt;([i32; N]);

macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; {
        const CONST: $t = $v;
    };
}

trait ${0:TraitName}&lt;const N: usize&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt;;

    const_maker! {i32, 7}
}

impl&lt;const N: usize&gt; ${0:TraitName}&lt;N&gt; for Foo&lt;N&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt; {
        Some(())
    }

    const_maker! {i32, 7}
}</code></pre>
<h3 id="generate_trait_impl"><a class="header" href="#generate_trait_impl">generate_trait_impl</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/generate_impl.rs#L56">generate_impl.rs</a></p>
<blockquote>
<p>Adds a new trait impl for a type.</p>
</blockquote>
<h4 id="before-62"><a class="header" href="#before-62">Before</a></h4>
<pre><code class="language-rust">struct ┃Ctx&lt;T: Clone&gt; {
    data: T,
}</code></pre>
<h4 id="after-62"><a class="header" href="#after-62">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
    data: T,
}

impl&lt;T: Clone&gt; ┃ for Ctx&lt;T&gt; {

}</code></pre>
<h3 id="inline_call"><a class="header" href="#inline_call">inline_call</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_call.rs#L161">inline_call.rs</a></p>
<blockquote>
<p>Inlines a function or method body creating a <code>let</code> statement per parameter unless the parameter
can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
or if the parameter is only accessed inside the function body once.</p>
</blockquote>
<h4 id="before-63"><a class="header" href="#before-63">Before</a></h4>
<pre><code class="language-rust">fn foo(name: Option&lt;&amp;str&gt;) {
    let name = name.unwrap┃();
}</code></pre>
<h4 id="after-63"><a class="header" href="#after-63">After</a></h4>
<pre><code class="language-rust">fn foo(name: Option&lt;&amp;str&gt;) {
    let name = match name {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        };
}</code></pre>
<h3 id="inline_const_as_literal"><a class="header" href="#inline_const_as_literal">inline_const_as_literal</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_const_as_literal.rs#L5">inline_const_as_literal.rs</a></p>
<blockquote>
<p>Evaluate and inline const variable as literal.</p>
</blockquote>
<h4 id="before-64"><a class="header" href="#before-64">Before</a></h4>
<pre><code class="language-rust">const STRING: &amp;str = &quot;Hello, World!&quot;;

fn something() -&gt; &amp;'static str {
    STRING┃
}</code></pre>
<h4 id="after-64"><a class="header" href="#after-64">After</a></h4>
<pre><code class="language-rust">const STRING: &amp;str = &quot;Hello, World!&quot;;

fn something() -&gt; &amp;'static str {
    &quot;Hello, World!&quot;
}</code></pre>
<h3 id="inline_into_callers"><a class="header" href="#inline_into_callers">inline_into_callers</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_call.rs#L27">inline_call.rs</a></p>
<blockquote>
<p>Inline a function or method body into all of its callers where possible, creating a <code>let</code> statement per parameter
unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
or if the parameter is only accessed inside the function body once.
If all calls can be inlined the function will be removed.</p>
</blockquote>
<h4 id="before-65"><a class="header" href="#before-65">Before</a></h4>
<pre><code class="language-rust">fn print(_: &amp;str) {}
fn foo┃(word: &amp;str) {
    if !word.is_empty() {
        print(word);
    }
}
fn bar() {
    foo(&quot;안녕하세요&quot;);
    foo(&quot;여러분&quot;);
}</code></pre>
<h4 id="after-65"><a class="header" href="#after-65">After</a></h4>
<pre><code class="language-rust">fn print(_: &amp;str) {}

fn bar() {
    {
        let word = &quot;안녕하세요&quot;;
        if !word.is_empty() {
            print(word);
        }
    };
    {
        let word = &quot;여러분&quot;;
        if !word.is_empty() {
            print(word);
        }
    };
}</code></pre>
<h3 id="inline_local_variable"><a class="header" href="#inline_local_variable">inline_local_variable</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_local_variable.rs#L18">inline_local_variable.rs</a></p>
<blockquote>
<p>Inlines a local variable.</p>
</blockquote>
<h4 id="before-66"><a class="header" href="#before-66">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x┃ = 1 + 2;
    x * 4;
}</code></pre>
<h4 id="after-66"><a class="header" href="#after-66">After</a></h4>
<pre><code class="language-rust">fn main() {
    (1 + 2) * 4;
}</code></pre>
<h3 id="inline_macro"><a class="header" href="#inline_macro">inline_macro</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_macro.rs#L6">inline_macro.rs</a></p>
<blockquote>
<p>Takes a macro and inlines it one step.</p>
</blockquote>
<h4 id="before-67"><a class="header" href="#before-67">Before</a></h4>
<pre><code class="language-rust">macro_rules! num {
    (+$($t:tt)+) =&gt; (1 + num!($($t )+));
    (-$($t:tt)+) =&gt; (-1 + num!($($t )+));
    (+) =&gt; (1);
    (-) =&gt; (-1);
}

fn main() {
    let number = num┃!(+ + + - + +);
    println!(&quot;{number}&quot;);
}</code></pre>
<h4 id="after-67"><a class="header" href="#after-67">After</a></h4>
<pre><code class="language-rust">macro_rules! num {
    (+$($t:tt)+) =&gt; (1 + num!($($t )+));
    (-$($t:tt)+) =&gt; (-1 + num!($($t )+));
    (+) =&gt; (1);
    (-) =&gt; (-1);
}

fn main() {
    let number = 1+num!(+ + - + +);
    println!(&quot;{number}&quot;);
}</code></pre>
<h3 id="inline_type_alias"><a class="header" href="#inline_type_alias">inline_type_alias</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_type_alias.rs#L105">inline_type_alias.rs</a></p>
<blockquote>
<p>Replace a type alias with its concrete type.</p>
</blockquote>
<h4 id="before-68"><a class="header" href="#before-68">Before</a></h4>
<pre><code class="language-rust">type A&lt;T = u32&gt; = Vec&lt;T&gt;;

fn main() {
    let a: ┃A;
}</code></pre>
<h4 id="after-68"><a class="header" href="#after-68">After</a></h4>
<pre><code class="language-rust">type A&lt;T = u32&gt; = Vec&lt;T&gt;;

fn main() {
    let a: Vec&lt;u32&gt;;
}</code></pre>
<h3 id="inline_type_alias_uses"><a class="header" href="#inline_type_alias_uses">inline_type_alias_uses</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/inline_type_alias.rs#L24">inline_type_alias.rs</a></p>
<blockquote>
<p>Inline a type alias into all of its uses where possible.</p>
</blockquote>
<h4 id="before-69"><a class="header" href="#before-69">Before</a></h4>
<pre><code class="language-rust">type ┃A = i32;
fn id(x: A) -&gt; A {
    x
};
fn foo() {
    let _: A = 3;
}</code></pre>
<h4 id="after-69"><a class="header" href="#after-69">After</a></h4>
<pre><code class="language-rust">
fn id(x: i32) -&gt; i32 {
    x
};
fn foo() {
    let _: i32 = 3;
}</code></pre>
<h3 id="introduce_named_generic"><a class="header" href="#introduce_named_generic">introduce_named_generic</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/introduce_named_generic.rs#L8">introduce_named_generic.rs</a></p>
<blockquote>
<p>Replaces <code>impl Trait</code> function argument with the named generic.</p>
</blockquote>
<h4 id="before-70"><a class="header" href="#before-70">Before</a></h4>
<pre><code class="language-rust">fn foo(bar: ┃impl Bar) {}</code></pre>
<h4 id="after-70"><a class="header" href="#after-70">After</a></h4>
<pre><code class="language-rust">fn foo&lt;┃B: Bar&gt;(bar: B) {}</code></pre>
<h3 id="introduce_named_lifetime"><a class="header" href="#introduce_named_lifetime">introduce_named_lifetime</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/introduce_named_lifetime.rs#L13">introduce_named_lifetime.rs</a></p>
<blockquote>
<p>Change an anonymous lifetime to a named lifetime.</p>
</blockquote>
<h4 id="before-71"><a class="header" href="#before-71">Before</a></h4>
<pre><code class="language-rust">impl Cursor&lt;'_┃&gt; {
    fn node(self) -&gt; &amp;SyntaxNode {
        match self {
            Cursor::Replace(node) | Cursor::Before(node) =&gt; node,
        }
    }
}</code></pre>
<h4 id="after-71"><a class="header" href="#after-71">After</a></h4>
<pre><code class="language-rust">impl&lt;'a&gt; Cursor&lt;'a&gt; {
    fn node(self) -&gt; &amp;SyntaxNode {
        match self {
            Cursor::Replace(node) | Cursor::Before(node) =&gt; node,
        }
    }
}</code></pre>
<h3 id="invert_if"><a class="header" href="#invert_if">invert_if</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/invert_if.rs#L13">invert_if.rs</a></p>
<blockquote>
<p>This transforms if expressions of the form <code>if !x {A} else {B}</code> into <code>if x {B} else {A}</code>
This also works with <code>!=</code>. This assist can only be applied with the cursor on <code>if</code>.</p>
</blockquote>
<h4 id="before-72"><a class="header" href="#before-72">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if┃ !y { A } else { B }
}</code></pre>
<h4 id="after-72"><a class="header" href="#after-72">After</a></h4>
<pre><code class="language-rust">fn main() {
    if y { B } else { A }
}</code></pre>
<h3 id="line_to_block"><a class="header" href="#line_to_block">line_to_block</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/convert_comment_block.rs#L9">convert_comment_block.rs</a></p>
<blockquote>
<p>Converts comments between block and single-line form.</p>
</blockquote>
<h4 id="before-73"><a class="header" href="#before-73">Before</a></h4>
<pre><code class="language-rust">   // Multi-line┃
   // comment</code></pre>
<h4 id="after-73"><a class="header" href="#after-73">After</a></h4>
<pre><code class="language-rust">  /*
  Multi-line
  comment
  */</code></pre>
<h3 id="make_raw_string"><a class="header" href="#make_raw_string">make_raw_string</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L7">raw_string.rs</a></p>
<blockquote>
<p>Adds <code>r#</code> to a plain string literal.</p>
</blockquote>
<h4 id="before-74"><a class="header" href="#before-74">Before</a></h4>
<pre><code class="language-rust">fn main() {
    &quot;Hello,┃ World!&quot;;
}</code></pre>
<h4 id="after-74"><a class="header" href="#after-74">After</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello, World!&quot;#;
}</code></pre>
<h3 id="make_usual_string"><a class="header" href="#make_usual_string">make_usual_string</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L47">raw_string.rs</a></p>
<blockquote>
<p>Turns a raw string into a plain string.</p>
</blockquote>
<h4 id="before-75"><a class="header" href="#before-75">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello,┃ &quot;World!&quot;&quot;#;
}</code></pre>
<h4 id="after-75"><a class="header" href="#after-75">After</a></h4>
<pre><code class="language-rust">fn main() {
    &quot;Hello, \&quot;World!\&quot;&quot;;
}</code></pre>
<h3 id="merge_imports"><a class="header" href="#merge_imports">merge_imports</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/merge_imports.rs#L17">merge_imports.rs</a></p>
<blockquote>
<p>Merges two imports with a common prefix.</p>
</blockquote>
<h4 id="before-76"><a class="header" href="#before-76">Before</a></h4>
<pre><code class="language-rust">use std::┃fmt::Formatter;
use std::io;</code></pre>
<h4 id="after-76"><a class="header" href="#after-76">After</a></h4>
<pre><code class="language-rust">use std::{fmt::Formatter, io};</code></pre>
<h3 id="merge_match_arms"><a class="header" href="#merge_match_arms">merge_match_arms</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/merge_match_arms.rs#L11">merge_match_arms.rs</a></p>
<blockquote>
<p>Merges the current match arm with the following if their bodies are identical.</p>
</blockquote>
<h4 id="before-77"><a class="header" href="#before-77">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ┃Action::Move(..) =&gt; foo(),
        Action::Stop =&gt; foo(),
    }
}</code></pre>
<h4 id="after-77"><a class="header" href="#after-77">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) | Action::Stop =&gt; foo(),
    }
}</code></pre>
<h3 id="move_arm_cond_to_match_guard"><a class="header" href="#move_arm_cond_to_match_guard">move_arm_cond_to_match_guard</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_guard.rs#L69">move_guard.rs</a></p>
<blockquote>
<p>Moves if expression from match arm body into a guard.</p>
</blockquote>
<h4 id="before-78"><a class="header" href="#before-78">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; ┃if distance &gt; 10 { foo() },
        _ =&gt; (),
    }
}</code></pre>
<h4 id="after-78"><a class="header" href="#after-78">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } if distance &gt; 10 =&gt; foo(),
        _ =&gt; (),
    }
}</code></pre>
<h3 id="move_bounds_to_where_clause"><a class="header" href="#move_bounds_to_where_clause">move_bounds_to_where_clause</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_bounds.rs#L12">move_bounds.rs</a></p>
<blockquote>
<p>Moves inline type bounds to a where clause.</p>
</blockquote>
<h4 id="before-79"><a class="header" href="#before-79">Before</a></h4>
<pre><code class="language-rust">fn apply&lt;T, U, ┃F: FnOnce(T) -&gt; U&gt;(f: F, x: T) -&gt; U {
    f(x)
}</code></pre>
<h4 id="after-79"><a class="header" href="#after-79">After</a></h4>
<pre><code class="language-rust">fn apply&lt;T, U, F&gt;(f: F, x: T) -&gt; U where F: FnOnce(T) -&gt; U {
    f(x)
}</code></pre>
<h3 id="move_const_to_impl"><a class="header" href="#move_const_to_impl">move_const_to_impl</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_const_to_impl.rs#L14">move_const_to_impl.rs</a></p>
<blockquote>
<p>Move a local constant item in a method to impl's associated constant. All the references will be
qualified with <code>Self::</code>.</p>
</blockquote>
<h4 id="before-80"><a class="header" href="#before-80">Before</a></h4>
<pre><code class="language-rust">struct S;
impl S {
    fn foo() -&gt; usize {
        /// The answer.
        const C┃: usize = 42;

        C * C
    }
}</code></pre>
<h4 id="after-80"><a class="header" href="#after-80">After</a></h4>
<pre><code class="language-rust">struct S;
impl S {
    /// The answer.
    const C: usize = 42;

    fn foo() -&gt; usize {
        Self::C * Self::C
    }
}</code></pre>
<h3 id="move_from_mod_rs"><a class="header" href="#move_from_mod_rs">move_from_mod_rs</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_from_mod_rs.rs#L12">move_from_mod_rs.rs</a></p>
<blockquote>
<p>Moves xxx/mod.rs to xxx.rs.</p>
</blockquote>
<h4 id="before-81"><a class="header" href="#before-81">Before</a></h4>
<pre><code class="language-rust">//- /main.rs
mod a;
//- /a/mod.rs
┃fn t() {}┃</code></pre>
<h4 id="after-81"><a class="header" href="#after-81">After</a></h4>
<pre><code class="language-rust">fn t() {}</code></pre>
<h3 id="move_guard_to_arm_body"><a class="header" href="#move_guard_to_arm_body">move_guard_to_arm_body</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_guard.rs#L8">move_guard.rs</a></p>
<blockquote>
<p>Moves match guard into match arm body.</p>
</blockquote>
<h4 id="before-82"><a class="header" href="#before-82">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } ┃if distance &gt; 10 =&gt; foo(),
        _ =&gt; (),
    }
}</code></pre>
<h4 id="after-82"><a class="header" href="#after-82">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; if distance &gt; 10 {
            foo()
        },
        _ =&gt; (),
    }
}</code></pre>
<h3 id="move_module_to_file"><a class="header" href="#move_module_to_file">move_module_to_file</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_module_to_file.rs#L14">move_module_to_file.rs</a></p>
<blockquote>
<p>Moves inline module's contents to a separate file.</p>
</blockquote>
<h4 id="before-83"><a class="header" href="#before-83">Before</a></h4>
<pre><code class="language-rust">mod ┃foo {
    fn t() {}
}</code></pre>
<h4 id="after-83"><a class="header" href="#after-83">After</a></h4>
<pre><code class="language-rust">mod foo;</code></pre>
<h3 id="move_to_mod_rs"><a class="header" href="#move_to_mod_rs">move_to_mod_rs</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/move_to_mod_rs.rs#L12">move_to_mod_rs.rs</a></p>
<blockquote>
<p>Moves xxx.rs to xxx/mod.rs.</p>
</blockquote>
<h4 id="before-84"><a class="header" href="#before-84">Before</a></h4>
<pre><code class="language-rust">//- /main.rs
mod a;
//- /a.rs
┃fn t() {}┃</code></pre>
<h4 id="after-84"><a class="header" href="#after-84">After</a></h4>
<pre><code class="language-rust">fn t() {}</code></pre>
<h3 id="promote_local_to_const"><a class="header" href="#promote_local_to_const">promote_local_to_const</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/promote_local_to_const.rs#L19">promote_local_to_const.rs</a></p>
<blockquote>
<p>Promotes a local variable to a const item changing its name to a <code>SCREAMING_SNAKE_CASE</code> variant
if the local uses no non-const expressions.</p>
</blockquote>
<h4 id="before-85"><a class="header" href="#before-85">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let foo┃ = true;

    if foo {
        println!(&quot;It's true&quot;);
    } else {
        println!(&quot;It's false&quot;);
    }
}</code></pre>
<h4 id="after-85"><a class="header" href="#after-85">After</a></h4>
<pre><code class="language-rust">fn main() {
    const ┃FOO: bool = true;

    if FOO {
        println!(&quot;It's true&quot;);
    } else {
        println!(&quot;It's false&quot;);
    }
}</code></pre>
<h3 id="pull_assignment_up"><a class="header" href="#pull_assignment_up">pull_assignment_up</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/pull_assignment_up.rs#L11">pull_assignment_up.rs</a></p>
<blockquote>
<p>Extracts variable assignment to outside an if or match statement.</p>
</blockquote>
<h4 id="before-86"><a class="header" href="#before-86">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 6;

    if true {
        ┃foo = 5;
    } else {
        foo = 4;
    }
}</code></pre>
<h4 id="after-86"><a class="header" href="#after-86">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 6;

    foo = if true {
        5
    } else {
        4
    };
}</code></pre>
<h3 id="qualify_method_call"><a class="header" href="#qualify_method_call">qualify_method_call</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/qualify_method_call.rs#L10">qualify_method_call.rs</a></p>
<blockquote>
<p>Replaces the method call with a qualified function call.</p>
</blockquote>
<h4 id="before-87"><a class="header" href="#before-87">Before</a></h4>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self) {}
}
fn main() {
    let foo = Foo;
    foo.fo┃o();
}</code></pre>
<h4 id="after-87"><a class="header" href="#after-87">After</a></h4>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self) {}
}
fn main() {
    let foo = Foo;
    Foo::foo(&amp;foo);
}</code></pre>
<h3 id="qualify_path"><a class="header" href="#qualify_path">qualify_path</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/qualify_path.rs#L21">qualify_path.rs</a></p>
<blockquote>
<p>If the name is unresolved, provides all possible qualified paths for it.</p>
</blockquote>
<h4 id="before-88"><a class="header" href="#before-88">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let map = HashMap┃::new();
}</code></pre>
<h4 id="after-88"><a class="header" href="#after-88">After</a></h4>
<pre><code class="language-rust">fn main() {
    let map = std::collections::HashMap::new();
}</code></pre>
<h3 id="reformat_number_literal"><a class="header" href="#reformat_number_literal">reformat_number_literal</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/number_representation.rs#L7">number_representation.rs</a></p>
<blockquote>
<p>Adds or removes separators from integer literal.</p>
</blockquote>
<h4 id="before-89"><a class="header" href="#before-89">Before</a></h4>
<pre><code class="language-rust">const _: i32 = 1012345┃;</code></pre>
<h4 id="after-89"><a class="header" href="#after-89">After</a></h4>
<pre><code class="language-rust">const _: i32 = 1_012_345;</code></pre>
<h3 id="remove_dbg"><a class="header" href="#remove_dbg">remove_dbg</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_dbg.rs#L9">remove_dbg.rs</a></p>
<blockquote>
<p>Removes <code>dbg!()</code> macro call.</p>
</blockquote>
<h4 id="before-90"><a class="header" href="#before-90">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = ┃dbg!(42 * dbg!(4 + 2));┃
}</code></pre>
<h4 id="after-90"><a class="header" href="#after-90">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = 42 * (4 + 2);
}</code></pre>
<h3 id="remove_hash"><a class="header" href="#remove_hash">remove_hash</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/raw_string.rs#L117">raw_string.rs</a></p>
<blockquote>
<p>Removes a hash from a raw string literal.</p>
</blockquote>
<h4 id="before-91"><a class="header" href="#before-91">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello,┃ World!&quot;#;
}</code></pre>
<h4 id="after-91"><a class="header" href="#after-91">After</a></h4>
<pre><code class="language-rust">fn main() {
    r&quot;Hello, World!&quot;;
}</code></pre>
<h3 id="remove_mut"><a class="header" href="#remove_mut">remove_mut</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_mut.rs#L5">remove_mut.rs</a></p>
<blockquote>
<p>Removes the <code>mut</code> keyword.</p>
</blockquote>
<h4 id="before-92"><a class="header" href="#before-92">Before</a></h4>
<pre><code class="language-rust">impl Walrus {
    fn feed(&amp;mut┃ self, amount: u32) {}
}</code></pre>
<h4 id="after-92"><a class="header" href="#after-92">After</a></h4>
<pre><code class="language-rust">impl Walrus {
    fn feed(&amp;self, amount: u32) {}
}</code></pre>
<h3 id="remove_parentheses"><a class="header" href="#remove_parentheses">remove_parentheses</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_parentheses.rs#L5">remove_parentheses.rs</a></p>
<blockquote>
<p>Removes redundant parentheses.</p>
</blockquote>
<h4 id="before-93"><a class="header" href="#before-93">Before</a></h4>
<pre><code class="language-rust">fn main() {
    _ = ┃(2) + 2;
}</code></pre>
<h4 id="after-93"><a class="header" href="#after-93">After</a></h4>
<pre><code class="language-rust">fn main() {
    _ = 2 + 2;
}</code></pre>
<h3 id="remove_unused_param"><a class="header" href="#remove_unused_param">remove_unused_param</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/remove_unused_param.rs#L15">remove_unused_param.rs</a></p>
<blockquote>
<p>Removes unused function parameter.</p>
</blockquote>
<h4 id="before-94"><a class="header" href="#before-94">Before</a></h4>
<pre><code class="language-rust">fn frobnicate(x: i32┃) {}

fn main() {
    frobnicate(92);
}</code></pre>
<h4 id="after-94"><a class="header" href="#after-94">After</a></h4>
<pre><code class="language-rust">fn frobnicate() {}

fn main() {
    frobnicate();
}</code></pre>
<h3 id="reorder_fields"><a class="header" href="#reorder_fields">reorder_fields</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/reorder_fields.rs#L8">reorder_fields.rs</a></p>
<blockquote>
<p>Reorder the fields of record literals and record patterns in the same order as in
the definition.</p>
</blockquote>
<h4 id="before-95"><a class="header" href="#before-95">Before</a></h4>
<pre><code class="language-rust">struct Foo {foo: i32, bar: i32};
const test: Foo = ┃Foo {bar: 0, foo: 1}</code></pre>
<h4 id="after-95"><a class="header" href="#after-95">After</a></h4>
<pre><code class="language-rust">struct Foo {foo: i32, bar: i32};
const test: Foo = Foo {foo: 1, bar: 0}</code></pre>
<h3 id="reorder_impl_items"><a class="header" href="#reorder_impl_items">reorder_impl_items</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/reorder_impl_items.rs#L11">reorder_impl_items.rs</a></p>
<blockquote>
<p>Reorder the items of an <code>impl Trait</code>. The items will be ordered
in the same order as in the trait definition.</p>
</blockquote>
<h4 id="before-96"><a class="header" href="#before-96">Before</a></h4>
<pre><code class="language-rust">trait Foo {
    type A;
    const B: u8;
    fn c();
}

struct Bar;
┃impl Foo for Bar┃ {
    const B: u8 = 17;
    fn c() {}
    type A = String;
}</code></pre>
<h4 id="after-96"><a class="header" href="#after-96">After</a></h4>
<pre><code class="language-rust">trait Foo {
    type A;
    const B: u8;
    fn c();
}

struct Bar;
impl Foo for Bar {
    type A = String;
    const B: u8 = 17;
    fn c() {}
}</code></pre>
<h3 id="replace_arith_with_checked"><a class="header" href="#replace_arith_with_checked">replace_arith_with_checked</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_arith_op.rs#L9">replace_arith_op.rs</a></p>
<blockquote>
<p>Replaces arithmetic on integers with the <code>checked_*</code> equivalent.</p>
</blockquote>
<h4 id="before-97"><a class="header" href="#before-97">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ┃+ 2;
}</code></pre>
<h4 id="after-97"><a class="header" href="#after-97">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.checked_add(2);
}</code></pre>
<h3 id="replace_arith_with_saturating"><a class="header" href="#replace_arith_with_saturating">replace_arith_with_saturating</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_arith_op.rs#L28">replace_arith_op.rs</a></p>
<blockquote>
<p>Replaces arithmetic on integers with the <code>saturating_*</code> equivalent.</p>
</blockquote>
<h4 id="before-98"><a class="header" href="#before-98">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ┃+ 2;
}</code></pre>
<h4 id="after-98"><a class="header" href="#after-98">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.saturating_add(2);
}</code></pre>
<h3 id="replace_arith_with_wrapping"><a class="header" href="#replace_arith_with_wrapping">replace_arith_with_wrapping</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_arith_op.rs#L50">replace_arith_op.rs</a></p>
<blockquote>
<p>Replaces arithmetic on integers with the <code>wrapping_*</code> equivalent.</p>
</blockquote>
<h4 id="before-99"><a class="header" href="#before-99">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ┃+ 2;
}</code></pre>
<h4 id="after-99"><a class="header" href="#after-99">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.wrapping_add(2);
}</code></pre>
<h3 id="replace_char_with_string"><a class="header" href="#replace_char_with_string">replace_char_with_string</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_string_with_char.rs#L51">replace_string_with_char.rs</a></p>
<blockquote>
<p>Replace a char literal with a string literal.</p>
</blockquote>
<h4 id="before-100"><a class="header" href="#before-100">Before</a></h4>
<pre><code class="language-rust">fn main() {
    find('{┃');
}</code></pre>
<h4 id="after-100"><a class="header" href="#after-100">After</a></h4>
<pre><code class="language-rust">fn main() {
    find(&quot;{&quot;);
}</code></pre>
<h3 id="replace_derive_with_manual_impl"><a class="header" href="#replace_derive_with_manual_impl">replace_derive_with_manual_impl</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs#L18">replace_derive_with_manual_impl.rs</a></p>
<blockquote>
<p>Converts a <code>derive</code> impl into a manual one.</p>
</blockquote>
<h4 id="before-101"><a class="header" href="#before-101">Before</a></h4>
<pre><code class="language-rust">#[derive(Deb┃ug, Display)]
struct S;</code></pre>
<h4 id="after-101"><a class="header" href="#after-101">After</a></h4>
<pre><code class="language-rust">#[derive(Display)]
struct S;

impl Debug for S {
    ┃fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;()&gt; {
        f.debug_struct(&quot;S&quot;).finish()
    }
}</code></pre>
<h3 id="replace_if_let_with_match"><a class="header" href="#replace_if_let_with_match">replace_if_let_with_match</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_if_let_with_match.rs#L24">replace_if_let_with_match.rs</a></p>
<blockquote>
<p>Replaces a <code>if let</code> expression with a <code>match</code> expression.</p>
</blockquote>
<h4 id="before-102"><a class="header" href="#before-102">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    ┃if let Action::Move { distance } = action {
        foo(distance)
    } else {
        bar()
    }
}</code></pre>
<h4 id="after-102"><a class="header" href="#after-102">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; foo(distance),
        _ =&gt; bar(),
    }
}</code></pre>
<h3 id="replace_let_with_if_let"><a class="header" href="#replace_let_with_if_let">replace_let_with_if_let</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_let_with_if_let.rs#L15">replace_let_with_if_let.rs</a></p>
<blockquote>
<p>Replaces <code>let</code> with an <code>if let</code>.</p>
</blockquote>
<h4 id="before-103"><a class="header" href="#before-103">Before</a></h4>
<pre><code class="language-rust">
fn main(action: Action) {
    ┃let x = compute();
}

fn compute() -&gt; Option&lt;i32&gt; { None }</code></pre>
<h4 id="after-103"><a class="header" href="#after-103">After</a></h4>
<pre><code class="language-rust">
fn main(action: Action) {
    if let Some(x) = compute() {
    }
}

fn compute() -&gt; Option&lt;i32&gt; { None }</code></pre>
<h3 id="replace_match_with_if_let"><a class="header" href="#replace_match_with_if_let">replace_match_with_if_let</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_if_let_with_match.rs#L187">replace_if_let_with_match.rs</a></p>
<blockquote>
<p>Replaces a binary <code>match</code> with a wildcard pattern and no guards with an <code>if let</code> expression.</p>
</blockquote>
<h4 id="before-104"><a class="header" href="#before-104">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    ┃match action {
        Action::Move { distance } =&gt; foo(distance),
        _ =&gt; bar(),
    }
}</code></pre>
<h4 id="after-104"><a class="header" href="#after-104">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    if let Action::Move { distance } = action {
        foo(distance)
    } else {
        bar()
    }
}</code></pre>
<h3 id="replace_named_generic_with_impl"><a class="header" href="#replace_named_generic_with_impl">replace_named_generic_with_impl</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_named_generic_with_impl.rs#L19">replace_named_generic_with_impl.rs</a></p>
<blockquote>
<p>Replaces named generic with an <code>impl Trait</code> in function argument.</p>
</blockquote>
<h4 id="before-105"><a class="header" href="#before-105">Before</a></h4>
<pre><code class="language-rust">fn new&lt;P┃: AsRef&lt;Path&gt;&gt;(location: P) -&gt; Self {}</code></pre>
<h4 id="after-105"><a class="header" href="#after-105">After</a></h4>
<pre><code class="language-rust">fn new(location: impl AsRef&lt;Path&gt;) -&gt; Self {}</code></pre>
<h3 id="replace_qualified_name_with_use"><a class="header" href="#replace_qualified_name_with_use">replace_qualified_name_with_use</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs#L13">replace_qualified_name_with_use.rs</a></p>
<blockquote>
<p>Adds a use statement for a given fully-qualified name.</p>
</blockquote>
<h4 id="before-106"><a class="header" href="#before-106">Before</a></h4>
<pre><code class="language-rust">fn process(map: std::collections::┃HashMap&lt;String, String&gt;) {}</code></pre>
<h4 id="after-106"><a class="header" href="#after-106">After</a></h4>
<pre><code class="language-rust">use std::collections::HashMap;

fn process(map: HashMap&lt;String, String&gt;) {}</code></pre>
<h3 id="replace_string_with_char"><a class="header" href="#replace_string_with_char">replace_string_with_char</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_string_with_char.rs#L11">replace_string_with_char.rs</a></p>
<blockquote>
<p>Replace string literal with char literal.</p>
</blockquote>
<h4 id="before-107"><a class="header" href="#before-107">Before</a></h4>
<pre><code class="language-rust">fn main() {
    find(&quot;{┃&quot;);
}</code></pre>
<h4 id="after-107"><a class="header" href="#after-107">After</a></h4>
<pre><code class="language-rust">fn main() {
    find('{');
}</code></pre>
<h3 id="replace_try_expr_with_match"><a class="header" href="#replace_try_expr_with_match">replace_try_expr_with_match</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_try_expr_with_match.rs#L18">replace_try_expr_with_match.rs</a></p>
<blockquote>
<p>Replaces a <code>try</code> expression with a <code>match</code> expression.</p>
</blockquote>
<h4 id="before-108"><a class="header" href="#before-108">Before</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = Some(true)┃?;
}</code></pre>
<h4 id="after-108"><a class="header" href="#after-108">After</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = match Some(true) {
        Some(it) =&gt; it,
        None =&gt; return None,
    };
}</code></pre>
<h3 id="replace_turbofish_with_explicit_type"><a class="header" href="#replace_turbofish_with_explicit_type">replace_turbofish_with_explicit_type</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs#L13">replace_turbofish_with_explicit_type.rs</a></p>
<blockquote>
<p>Converts <code>::&lt;_&gt;</code> to an explicit type assignment.</p>
</blockquote>
<h4 id="before-109"><a class="header" href="#before-109">Before</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { ) }
fn main() {
    let a = make┃::&lt;i32&gt;();
}</code></pre>
<h4 id="after-109"><a class="header" href="#after-109">After</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { ) }
fn main() {
    let a: i32 = make();
}</code></pre>
<h3 id="replace_with_eager_method"><a class="header" href="#replace_with_eager_method">replace_with_eager_method</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_method_eager_lazy.rs#L89">replace_method_eager_lazy.rs</a></p>
<blockquote>
<p>Replace <code>unwrap_or_else</code> with <code>unwrap_or</code> and <code>ok_or_else</code> with <code>ok_or</code>.</p>
</blockquote>
<h4 id="before-110"><a class="header" href="#before-110">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwra┃p_or_else(|| 2);
}</code></pre>
<h4 id="after-110"><a class="header" href="#after-110">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwrap_or(2);
}</code></pre>
<h3 id="replace_with_lazy_method"><a class="header" href="#replace_with_lazy_method">replace_with_lazy_method</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/replace_method_eager_lazy.rs#L9">replace_method_eager_lazy.rs</a></p>
<blockquote>
<p>Replace <code>unwrap_or</code> with <code>unwrap_or_else</code> and <code>ok_or</code> with <code>ok_or_else</code>.</p>
</blockquote>
<h4 id="before-111"><a class="header" href="#before-111">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwra┃p_or(2);
}</code></pre>
<h4 id="after-111"><a class="header" href="#after-111">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwrap_or_else(|| 2);
}</code></pre>
<h3 id="sort_items"><a class="header" href="#sort_items">sort_items</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/sort_items.rs#L12">sort_items.rs</a></p>
<blockquote>
<p>Sorts item members alphabetically: fields, enum variants and methods.</p>
</blockquote>
<h4 id="before-112"><a class="header" href="#before-112">Before</a></h4>
<pre><code class="language-rust">struct ┃Foo┃ { second: u32, first: String }</code></pre>
<h4 id="after-112"><a class="header" href="#after-112">After</a></h4>
<pre><code class="language-rust">struct Foo { first: String, second: u32 }</code></pre>
<blockquote>
<hr />
</blockquote>
<h4 id="before-113"><a class="header" href="#before-113">Before</a></h4>
<pre><code class="language-rust">trait ┃Bar┃ {
    fn second(&amp;self) -&gt; u32;
    fn first(&amp;self) -&gt; String;
}</code></pre>
<h4 id="after-113"><a class="header" href="#after-113">After</a></h4>
<pre><code class="language-rust">trait Bar {
    fn first(&amp;self) -&gt; String;
    fn second(&amp;self) -&gt; u32;
}</code></pre>
<blockquote>
<hr />
</blockquote>
<h4 id="before-114"><a class="header" href="#before-114">Before</a></h4>
<pre><code class="language-rust">struct Baz;
impl ┃Baz┃ {
    fn second(&amp;self) -&gt; u32;
    fn first(&amp;self) -&gt; String;
}</code></pre>
<h4 id="after-114"><a class="header" href="#after-114">After</a></h4>
<pre><code class="language-rust">struct Baz;
impl Baz {
    fn first(&amp;self) -&gt; String;
    fn second(&amp;self) -&gt; u32;
}</code></pre>
<blockquote>
<hr />
</blockquote>
<p>There is a difference between sorting enum variants:</p>
<h4 id="before-115"><a class="header" href="#before-115">Before</a></h4>
<pre><code class="language-rust">enum ┃Animal┃ {
  Dog(String, f64),
  Cat { weight: f64, name: String },
}</code></pre>
<h4 id="after-115"><a class="header" href="#after-115">After</a></h4>
<pre><code class="language-rust">enum Animal {
  Cat { weight: f64, name: String },
  Dog(String, f64),
}</code></pre>
<blockquote>
<p>and sorting a single enum struct variant:</p>
</blockquote>
<h4 id="before-116"><a class="header" href="#before-116">Before</a></h4>
<pre><code class="language-rust">enum Animal {
  Dog(String, f64),
  Cat ┃{ weight: f64, name: String }┃,
}</code></pre>
<h4 id="after-116"><a class="header" href="#after-116">After</a></h4>
<pre><code class="language-rust">enum Animal {
  Dog(String, f64),
  Cat { name: String, weight: f64 },
}</code></pre>
<h3 id="split_import"><a class="header" href="#split_import">split_import</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/split_import.rs#L5">split_import.rs</a></p>
<blockquote>
<p>Wraps the tail of import into braces.</p>
</blockquote>
<h4 id="before-117"><a class="header" href="#before-117">Before</a></h4>
<pre><code class="language-rust">use std::┃collections::HashMap;</code></pre>
<h4 id="after-117"><a class="header" href="#after-117">After</a></h4>
<pre><code class="language-rust">use std::{collections::HashMap};</code></pre>
<h3 id="toggle_ignore"><a class="header" href="#toggle_ignore">toggle_ignore</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/toggle_ignore.rs#L8">toggle_ignore.rs</a></p>
<blockquote>
<p>Adds <code>#[ignore]</code> attribute to the test.</p>
</blockquote>
<h4 id="before-118"><a class="header" href="#before-118">Before</a></h4>
<pre><code class="language-rust">┃#[test]
fn arithmetics {
    assert_eq!(2 + 2, 5);
}</code></pre>
<h4 id="after-118"><a class="header" href="#after-118">After</a></h4>
<pre><code class="language-rust">#[test]
#[ignore]
fn arithmetics {
    assert_eq!(2 + 2, 5);
}</code></pre>
<h3 id="unmerge_match_arm"><a class="header" href="#unmerge_match_arm">unmerge_match_arm</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unmerge_match_arm.rs#L10">unmerge_match_arm.rs</a></p>
<blockquote>
<p>Splits the current match with a <code>|</code> pattern into two arms with identical bodies.</p>
</blockquote>
<h4 id="before-119"><a class="header" href="#before-119">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) ┃| Action::Stop =&gt; foo(),
    }
}</code></pre>
<h4 id="after-119"><a class="header" href="#after-119">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) =&gt; foo(),
        Action::Stop =&gt; foo(),
    }
}</code></pre>
<h3 id="unmerge_use"><a class="header" href="#unmerge_use">unmerge_use</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unmerge_use.rs#L12">unmerge_use.rs</a></p>
<blockquote>
<p>Extracts single use item from use list.</p>
</blockquote>
<h4 id="before-120"><a class="header" href="#before-120">Before</a></h4>
<pre><code class="language-rust">use std::fmt::{Debug, Display┃};</code></pre>
<h4 id="after-120"><a class="header" href="#after-120">After</a></h4>
<pre><code class="language-rust">use std::fmt::{Debug};
use std::fmt::Display;</code></pre>
<h3 id="unnecessary_async"><a class="header" href="#unnecessary_async">unnecessary_async</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unnecessary_async.rs#L15">unnecessary_async.rs</a></p>
<blockquote>
<p>Removes the <code>async</code> mark from functions which have no <code>.await</code> in their body.
Looks for calls to the functions and removes the <code>.await</code> on the call site.</p>
</blockquote>
<h4 id="before-121"><a class="header" href="#before-121">Before</a></h4>
<pre><code class="language-rust">pub async f┃n foo() {}
pub async fn bar() { foo().await }</code></pre>
<h4 id="after-121"><a class="header" href="#after-121">After</a></h4>
<pre><code class="language-rust">pub fn foo() {}
pub async fn bar() { foo() }</code></pre>
<h3 id="unqualify_method_call"><a class="header" href="#unqualify_method_call">unqualify_method_call</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unqualify_method_call.rs#L8">unqualify_method_call.rs</a></p>
<blockquote>
<p>Transforms universal function call syntax into a method call.</p>
</blockquote>
<h4 id="before-122"><a class="header" href="#before-122">Before</a></h4>
<pre><code class="language-rust">fn main() {
    std::ops::Add::add┃(1, 2);
}</code></pre>
<h4 id="after-122"><a class="header" href="#after-122">After</a></h4>
<pre><code class="language-rust">fn main() {
    1.add(2);
}</code></pre>
<h3 id="unwrap_block"><a class="header" href="#unwrap_block">unwrap_block</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_block.rs#L12">unwrap_block.rs</a></p>
<blockquote>
<p>This assist removes if...else, for, while and loop control statements to just keep the body.</p>
</blockquote>
<h4 id="before-123"><a class="header" href="#before-123">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    if true {┃
        println!(&quot;foo&quot;);
    }
}</code></pre>
<h4 id="after-123"><a class="header" href="#after-123">After</a></h4>
<pre><code class="language-rust">fn foo() {
    println!(&quot;foo&quot;);
}</code></pre>
<h3 id="unwrap_result_return_type"><a class="header" href="#unwrap_result_return_type">unwrap_result_return_type</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_result_return_type.rs#L13">unwrap_result_return_type.rs</a></p>
<blockquote>
<p>Unwrap the function's return type.</p>
</blockquote>
<h4 id="before-124"><a class="header" href="#before-124">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;i32&gt;┃ { Ok(42i32) }</code></pre>
<h4 id="after-124"><a class="header" href="#after-124">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="unwrap_tuple"><a class="header" href="#unwrap_tuple">unwrap_tuple</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/unwrap_tuple.rs#L8">unwrap_tuple.rs</a></p>
<blockquote>
<p>Unwrap the tuple to different variables.</p>
</blockquote>
<h4 id="before-125"><a class="header" href="#before-125">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ┃let (foo, bar) = (&quot;Foo&quot;, &quot;Bar&quot;);
}</code></pre>
<h4 id="after-125"><a class="header" href="#after-125">After</a></h4>
<pre><code class="language-rust">fn main() {
    let foo = &quot;Foo&quot;;
    let bar = &quot;Bar&quot;;
}</code></pre>
<h3 id="wrap_return_type_in_result"><a class="header" href="#wrap_return_type_in_result">wrap_return_type_in_result</a></h3>
<p><strong>Source:</strong> <a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/ide-assists/src/handlers/wrap_return_type_in_result.rs#L14">wrap_return_type_in_result.rs</a></p>
<blockquote>
<p>Wrap the function's return type into Result.</p>
</blockquote>
<h4 id="before-126"><a class="header" href="#before-126">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32┃ { 42i32 }</code></pre>
<h4 id="after-126"><a class="header" href="#after-126">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;i32, ${0:_}&gt; { Ok(42i32) }</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../features/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../diagnostics/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../features/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../diagnostics/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
