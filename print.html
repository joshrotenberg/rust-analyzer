<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>rust-analyzer</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="installation/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="troubleshooting/index.html"><strong aria-hidden="true">3.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="configuration/index.html"><strong aria-hidden="true">4.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="non_cargo_based_projects/index.html"><strong aria-hidden="true">5.</strong> Non-Cargo Based Projects</a></li><li class="chapter-item expanded "><a href="security/index.html"><strong aria-hidden="true">6.</strong> Security</a></li><li class="chapter-item expanded "><a href="privacy/index.html"><strong aria-hidden="true">7.</strong> Privacy</a></li><li class="chapter-item expanded "><a href="features/index.html"><strong aria-hidden="true">8.</strong> Features</a></li><li class="chapter-item expanded "><a href="assists/index.html"><strong aria-hidden="true">9.</strong> Assists (Code Actions)</a></li><li class="chapter-item expanded "><a href="diagnostics/index.html"><strong aria-hidden="true">10.</strong> Diagnostics</a></li><li class="chapter-item expanded "><a href="editor_features/index.html"><strong aria-hidden="true">11.</strong> Editor Features</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-analyzer</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-analyzer/rust-analyzer/tree/master/manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-analyzer"><a class="header" href="#rust-analyzer">rust-analyzer</a></h1>
<p>At its core, rust-analyzer is a <strong>library</strong> for semantic analysis of
Rust code as it changes over time. This manual focuses on a specific
usage of the library‚Äâ‚Äî‚Äârunning it as part of a server that implements
the <a href="https://microsoft.github.io/language-server-protocol/">Language Server
Protocol</a> (LSP).
The LSP allows various code editors, like VS Code, Emacs or Vim, to
implement semantic features like completion or goto definition by
talking to an external language server process.</p>
<p>To improve this document, send a pull request:<br />
<a href="https://github.com/rust-lang/rust-analyzer/blob/master/docs/user/manual.adoc">https://github.com/rust-analyzer/‚Ä¶‚Äã/manual.adoc</a></p>
<p>The manual is written in <a href="https://asciidoc.org">AsciiDoc</a> and includes
some extra files which are generated from the source code. Run
<code>cargo test</code> and <code>cargo test -p xtask</code> to create these and then
<code>asciidoctor manual.adoc</code> to create an HTML copy.</p>
<p>If you have questions about using rust-analyzer, please ask them in the
<a href="https://users.rust-lang.org/c/ide/14">‚ÄúIDEs and Editors‚Äù</a> topic of Rust
users forum.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>In theory, one should be able to just install the <a href="installation/index.html#rust-analyzer-language-server-binary"><code>rust-analyzer</code>
binary</a> and have it automatically
work with any editor. We are not there yet, so some editor specific
setup is required.</p>
<p>Additionally, rust-analyzer needs the sources of the standard library.
If the source code is not present, rust-analyzer will attempt to install
it automatically.</p>
<p>To add the sources manually, run the following command:</p>
<pre><code>$ rustup component add rust-src
</code></pre>
<h2 id="toolchain"><a class="header" href="#toolchain">Toolchain</a></h2>
<p>Only the latest stable standard library source is officially supported
for use with rust-analyzer. If you are using an older toolchain or have
an override set, rust-analyzer may fail to understand the Rust source.
You will either need to update your toolchain or use an older version of
rust-analyzer that is compatible with your toolchain.</p>
<p>If you are using an override in your project, you can still force
rust-analyzer to use the stable toolchain via the environment variable
<code>RUSTUP_TOOLCHAIN</code>. For example, with VS Code or coc-rust-analyzer:</p>
<pre><code>{ &quot;rust-analyzer.server.extraEnv&quot;: { &quot;RUSTUP_TOOLCHAIN&quot;: &quot;stable&quot; } }
</code></pre>
<h2 id="vs-code"><a class="header" href="#vs-code">VS Code</a></h2>
<p>This is the best supported editor at the moment. The rust-analyzer
plugin for VS Code is maintained <a href="https://github.com/rust-lang/rust-analyzer/tree/master/editors/code">in
tree</a>.</p>
<p>You can install the latest release of the plugin from <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer">the
marketplace</a>.</p>
<p>Note that the plugin may cause conflicts with the <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">previous official
Rust
plugin</a>.
The latter is no longer maintained and should be uninstalled.</p>
<p>The server binary is stored in the extension install directory, which
starts with <code>rust-lang.rust-analyzer-</code> and is located under:</p>
<ul>
<li>
<p>Linux: <code>~/.vscode/extensions</code></p>
</li>
<li>
<p>Linux (Remote, such as WSL): <code>~/.vscode-server/extensions</code></p>
</li>
<li>
<p>macOS: <code>~/.vscode/extensions</code></p>
</li>
<li>
<p>Windows: <code>%USERPROFILE%\.vscode\extensions</code></p>
</li>
</ul>
<p>As an exception, on NixOS, the extension makes a copy of the server and
stores it under
<code>~/.config/Code/User/globalStorage/rust-lang.rust-analyzer</code>.</p>
<p>Note that we only support the two most recent versions of VS Code.</p>
<h3 id="updates"><a class="header" href="#updates">Updates</a></h3>
<p>The extension will be updated automatically as new versions become
available. It will ask your permission to download the matching language
server version binary if needed.</p>
<h4 id="nightly"><a class="header" href="#nightly">Nightly</a></h4>
<p>We ship nightly releases for VS Code. To help us out by testing the
newest code, you can enable pre-release versions in the Code extension
page.</p>
<h3 id="manual-installation"><a class="header" href="#manual-installation">Manual installation</a></h3>
<p>Alternatively, download a VSIX corresponding to your platform from the
<a href="https://github.com/rust-lang/rust-analyzer/releases">releases</a> page.</p>
<p>Install the extension with the <code>Extensions: Install from VSIX</code> command
within VS Code, or from the command line via:</p>
<pre><code>$ code --install-extension /path/to/rust-analyzer.vsix
</code></pre>
<p>If you are running an unsupported platform, you can install
<code>rust-analyzer-no-server.vsix</code> and compile or obtain a server binary.
Copy the server anywhere, then add the path to your settings.json, for
example:</p>
<pre><code>{ &quot;rust-analyzer.server.path&quot;: &quot;~/.local/bin/rust-analyzer-linux&quot; }
</code></pre>
<h3 id="building-from-source"><a class="header" href="#building-from-source">Building From Source</a></h3>
<p>Both the server and the Code plugin can be installed from source:</p>
<pre><code>$ git clone https://github.com/rust-lang/rust-analyzer.git &amp;&amp; cd rust-analyzer
$ cargo xtask install
</code></pre>
<p>You‚Äôll need Cargo, nodejs (matching a supported version of VS Code) and
npm for this.</p>
<p>Note that installing via <code>xtask install</code> does not work for VS Code
Remote, instead you‚Äôll need to install the <code>.vsix</code> manually.</p>
<p>If you‚Äôre not using Code, you can compile and install only the LSP
server:</p>
<pre><code>$ cargo xtask install --server
</code></pre>
<p>Make sure that <code>.cargo/bin</code> is in <code>$PATH</code> and precedes paths where
<code>rust-analyzer</code> may also be installed. Specifically, <code>rustup</code> includes a
proxy called <code>rust-analyzer</code>, which can cause problems if you‚Äôre
planning to use a source build or even a downloaded binary.</p>
<h2 id="rust-analyzer-language-server-binary"><a class="header" href="#rust-analyzer-language-server-binary">rust-analyzer Language Server Binary</a></h2>
<p>Other editors generally require the <code>rust-analyzer</code> binary to be in
<code>$PATH</code>. You can download pre-built binaries from the
<a href="https://github.com/rust-lang/rust-analyzer/releases">releases</a> page.
You will need to uncompress and rename the binary for your platform,
e.g. from <code>rust-analyzer-aarch64-apple-darwin.gz</code> on Mac OS to
<code>rust-analyzer</code>, make it executable, then move it into a directory in
your <code>$PATH</code>.</p>
<p>On Linux to install the <code>rust-analyzer</code> binary into <code>~/.local/bin</code>,
these commands should work:</p>
<pre><code>$ mkdir -p ~/.local/bin
$ curl -L https://github.com/rust-lang/rust-analyzer/releases/latest/download/rust-analyzer-x86_64-unknown-linux-gnu.gz | gunzip -c - &gt; ~/.local/bin/rust-analyzer
$ chmod +x ~/.local/bin/rust-analyzer
</code></pre>
<p>Make sure that <code>~/.local/bin</code> is listed in the <code>$PATH</code> variable and use
the appropriate URL if you‚Äôre not on a <code>x86-64</code> system.</p>
<p>You don‚Äôt have to use <code>~/.local/bin</code>, any other path like <code>~/.cargo/bin</code>
or <code>/usr/local/bin</code> will work just as well.</p>
<p>Alternatively, you can install it from source using the command below.
You‚Äôll need the latest stable version of the Rust toolchain.</p>
<pre><code>$ git clone https://github.com/rust-lang/rust-analyzer.git &amp;&amp; cd rust-analyzer
$ cargo xtask install --server
</code></pre>
<p>If your editor can‚Äôt find the binary even though the binary is on your
<code>$PATH</code>, the likely explanation is that it doesn‚Äôt see the same <code>$PATH</code>
as the shell, see <a href="https://github.com/rust-lang/rust-analyzer/issues/1811">this
issue</a>. On Unix,
running the editor from a shell or changing the <code>.desktop</code> file to set
the environment should help.</p>
<h3 id="rustup"><a class="header" href="#rustup">rustup</a></h3>
<p><code>rust-analyzer</code> is available in <code>rustup</code>:</p>
<pre><code>$ rustup component add rust-analyzer
</code></pre>
<h3 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h3>
<p>The <code>rust-analyzer</code> binary can be installed from the repos or AUR (Arch
User Repository):</p>
<ul>
<li>
<p><a href="https://www.archlinux.org/packages/community/x86_64/rust-analyzer/"><code>rust-analyzer</code></a>
(built from latest tagged source)</p>
</li>
<li>
<p><a href="https://aur.archlinux.org/packages/rust-analyzer-git"><code>rust-analyzer-git</code></a>
(latest Git version)</p>
</li>
</ul>
<p>Install it with pacman, for example:</p>
<pre><code>$ pacman -S rust-analyzer
</code></pre>
<h3 id="gentoo-linux"><a class="header" href="#gentoo-linux">Gentoo Linux</a></h3>
<p><code>rust-analyzer</code> is available in the GURU repository:</p>
<ul>
<li>
<p><a href="https://gitweb.gentoo.org/repo/proj/guru.git/tree/dev-util/rust-analyzer?id=9895cea62602cfe599bd48e0fb02127411ca6e81"><code>dev-util/rust-analyzer</code></a>
builds from source</p>
</li>
<li>
<p><a href="https://gitweb.gentoo.org/repo/proj/guru.git/tree/dev-util/rust-analyzer-bin?id=9895cea62602cfe599bd48e0fb02127411ca6e81"><code>dev-util/rust-analyzer-bin</code></a>
installs an official binary release</p>
</li>
</ul>
<p>If not already, GURU must be enabled (e.g. using
<code>app-eselect/eselect-repository</code>) and sync‚Äôd before running <code>emerge</code>:</p>
<pre><code>$ eselect repository enable guru &amp;&amp; emaint sync -r guru
$ emerge rust-analyzer-bin
</code></pre>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<p>The <code>rust-analyzer</code> binary can be installed via
<a href="https://brew.sh/">Homebrew</a>.</p>
<pre><code>$ brew install rust-analyzer
</code></pre>
<h2 id="vs-code-or-vscodium-in-flatpak"><a class="header" href="#vs-code-or-vscodium-in-flatpak">VS Code or VSCodium in Flatpak</a></h2>
<p>Setting up <code>rust-analyzer</code> with a Flatpak version of Code is not trivial
because of the Flatpak sandbox. While the sandbox can be disabled for
some directories, <code>/usr/bin</code> will always be mounted under
<code>/run/host/usr/bin</code>. This prevents access to the system‚Äôs C compiler, a
system-wide installation of Rust, or any other libraries you might want
to link to. Some compilers and libraries can be acquired as Flatpak
SDKs, such as <code>org.freedesktop.Sdk.Extension.rust-stable</code> or
<code>org.freedesktop.Sdk.Extension.llvm15</code>.</p>
<p>If you use a Flatpak SDK for Rust, there should be no extra steps
necessary.</p>
<p>If you want to use Flatpak in combination with <code>rustup</code>, the following
steps might help:</p>
<ul>
<li>
<p>both Rust and <code>rustup</code> have to be installed using
<a href="https://rustup.rs">https://rustup.rs</a>. Distro packages <em>will not</em> work.</p>
</li>
<li>
<p>you need to launch Code, open a terminal and run <code>echo $PATH</code></p>
</li>
<li>
<p>using
<a href="https://flathub.org/apps/details/com.github.tchx84.Flatseal">Flatseal</a>,
you must add an environment variable called <code>PATH</code>. Set its value to
the output from above, appending <code>:~/.cargo/bin</code>, where <code>~</code> is the
path to your home directory. You must replace <code>~</code>, as it won‚Äôt be
expanded otherwise.</p>
</li>
<li>
<p>while Flatseal is open, you must enable access to &quot;All user files&quot;</p>
</li>
</ul>
<p>A C compiler should already be available via <code>org.freedesktop.Sdk</code>. Any
other tools or libraries you will need to acquire from Flatpak.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>Prerequisites: You have installed the <a href="installation/index.html#rust-analyzer-language-server-binary"><code>rust-analyzer</code>
binary</a>.</p>
<p>To use <code>rust-analyzer</code>, you need to install and enable one of the two
popular LSP client implementations for Emacs,
<a href="https://github.com/joaotavora/eglot">Eglot</a> or <a href="https://github.com/emacs-lsp/lsp-mode">LSP
Mode</a>. Both enable
<code>rust-analyzer</code> by default in rust buffers if it is available.</p>
<h3 id="eglot"><a class="header" href="#eglot">Eglot</a></h3>
<p>Eglot is the more minimalistic and lightweight LSP client for Emacs,
integrates well with existing Emacs functionality and is built into
Emacs starting from release 29.</p>
<p>After installing Eglot, e.g. via <code>M-x package-install</code> (not needed from
Emacs 29), you can enable it via the <code>M-x eglot</code> command or load it
automatically in <code>rust-mode</code> via</p>
<pre><code>(add-hook 'rust-mode-hook 'eglot-ensure)
</code></pre>
<p>To enable clippy, you will need to configure the initialization options
to pass the <code>check.command</code> setting.</p>
<pre><code>(add-to-list 'eglot-server-programs
             '((rust-ts-mode rust-mode) .
               (&quot;rust-analyzer&quot; :initializationOptions (:check (:command &quot;clippy&quot;)))))
</code></pre>
<p>For more detailed instructions and options see the <a href="https://joaotavora.github.io/eglot">Eglot
manual</a> (also available from Emacs
via <code>M-x info</code>) and the <a href="https://github.com/joaotavora/eglot/blob/master/README.md">Eglot
readme</a>.</p>
<p>Eglot does not support the rust-analyzer extensions to the
language-server protocol and does not aim to do so in the future. The
<a href="https://github.com/nemethf/eglot-x#rust-analyzer-extensions">eglot-x</a>
package adds experimental support for those LSP extensions.</p>
<h3 id="lsp-mode"><a class="header" href="#lsp-mode">LSP Mode</a></h3>
<p>LSP-mode is the original LSP-client for emacs. Compared to Eglot it has
a larger codebase and supports more features, like LSP protocol
extensions. With extension packages like <a href="https://github.com/emacs-lsp/lsp-mode">LSP
UI</a> it offers a lot of visual
eyecandy. Further it integrates well with <a href="https://github.com/emacs-lsp/dap-mode">DAP
mode</a> for support of the Debug
Adapter Protocol.</p>
<p>You can install LSP-mode via <code>M-x package-install</code> and then run it via
the <code>M-x lsp</code> command or load it automatically in rust buffers with</p>
<pre><code>(add-hook 'rust-mode-hook 'lsp-deferred)
</code></pre>
<p>For more information on how to set up LSP mode and its extension package
see the instructions in the <a href="https://emacs-lsp.github.io/lsp-mode/page/installation">LSP mode
manual</a>. Also
see the <a href="https://emacs-lsp.github.io/lsp-mode/page/lsp-rust-analyzer/">rust-analyzer
section</a>
for <code>rust-analyzer</code> specific options and commands, which you can
optionally bind to keys.</p>
<p>Note the excellent
<a href="https://robert.kra.hn/posts/2021-02-07_rust-with-emacs/">guide</a> from
<a href="https://github.com/rksm">@rksm</a> on how to set-up Emacs for Rust
development with LSP mode and several other packages.</p>
<h2 id="vimneovim"><a class="header" href="#vimneovim">Vim/Neovim</a></h2>
<p>Prerequisites: You have installed the <a href="installation/index.html#rust-analyzer-language-server-binary"><code>rust-analyzer</code>
binary</a>. Not needed if the
extension can install/update it on its own, coc-rust-analyzer is one
example.</p>
<p>There are several LSP client implementations for Vim or Neovim:</p>
<h3 id="coc-rust-analyzer"><a class="header" href="#coc-rust-analyzer">coc-rust-analyzer</a></h3>
<ol>
<li>
<p>Install coc.nvim by following the instructions at
<a href="https://github.com/neoclide/coc.nvim">coc.nvim</a> (Node.js required)</p>
</li>
<li>
<p>Run <code>:CocInstall coc-rust-analyzer</code> to install
<a href="https://github.com/fannheyward/coc-rust-analyzer">coc-rust-analyzer</a>,
this extension implements <em>most</em> of the features supported in the
VSCode extension:</p>
<ul>
<li>
<p>automatically install and upgrade stable/nightly releases</p>
</li>
<li>
<p>same configurations as VSCode extension,
<code>rust-analyzer.server.path</code>, <code>rust-analyzer.cargo.features</code> etc.</p>
</li>
<li>
<p>same commands too, <code>rust-analyzer.analyzerStatus</code>,
<code>rust-analyzer.ssr</code> etc.</p>
</li>
<li>
<p>inlay hints for variables and method chaining, <em>Neovim Only</em></p>
</li>
</ul>
</li>
</ol>
<p>Note: for code actions, use <code>coc-codeaction-cursor</code> and
<code>coc-codeaction-selected</code>; <code>coc-codeaction</code> and <code>coc-codeaction-line</code>
are unlikely to be useful.</p>
<h3 id="languageclient-neovim"><a class="header" href="#languageclient-neovim">LanguageClient-neovim</a></h3>
<ol>
<li>
<p>Install LanguageClient-neovim by following the instructions
<a href="https://github.com/autozimu/LanguageClient-neovim">here</a></p>
<ul>
<li>The GitHub project wiki has extra tips on configuration</li>
</ul>
</li>
<li>
<p>Configure by adding this to your Vim/Neovim config file (replacing
the existing Rust-specific line if it exists):</p>
<pre><code>let g:LanguageClient_serverCommands = {
\ 'rust': ['rust-analyzer'],
\ }
</code></pre>
</li>
</ol>
<h3 id="youcompleteme"><a class="header" href="#youcompleteme">YouCompleteMe</a></h3>
<p>Install YouCompleteMe by following the instructions
<a href="https://github.com/ycm-core/YouCompleteMe#installation">here</a>.</p>
<p>rust-analyzer is the default in ycm, it should work out of the box.</p>
<h3 id="ale"><a class="header" href="#ale">ALE</a></h3>
<p>To use the LSP server in <a href="https://github.com/dense-analysis/ale">ale</a>:</p>
<pre><code>let g:ale_linters = {'rust': ['analyzer']}
</code></pre>
<h3 id="nvim-lsp"><a class="header" href="#nvim-lsp">nvim-lsp</a></h3>
<p>Neovim 0.5 has built-in language server support. For a quick start
configuration of rust-analyzer, use
<a href="https://github.com/neovim/nvim-lspconfig#rust_analyzer">neovim/nvim-lspconfig</a>.
Once <code>neovim/nvim-lspconfig</code> is installed, use
<code>lua require'lspconfig'.rust_analyzer.setup({})</code> in your <code>init.vim</code>.</p>
<p>You can also pass LSP settings to the server:</p>
<pre><code>lua &lt;&lt; EOF
local nvim_lsp = require'lspconfig'

local on_attach = function(client)
    require'completion'.on_attach(client)
end

nvim_lsp.rust_analyzer.setup({
    on_attach=on_attach,
    settings = {
        [&quot;rust-analyzer&quot;] = {
            imports = {
                granularity = {
                    group = &quot;module&quot;,
                },
                prefix = &quot;self&quot;,
            },
            cargo = {
                buildScripts = {
                    enable = true,
                },
            },
            procMacro = {
                enable = true
            },
        }
    }
})
EOF
</code></pre>
<p>See <a href="https://sharksforarms.dev/posts/neovim-rust/">https://sharksforarms.dev/posts/neovim-rust/</a> for more tips on
getting started.</p>
<p>Check out <a href="https://github.com/simrat39/rust-tools.nvim">https://github.com/simrat39/rust-tools.nvim</a> for a batteries
included rust-analyzer setup for Neovim.</p>
<h3 id="vim-lsp"><a class="header" href="#vim-lsp">vim-lsp</a></h3>
<p>vim-lsp is installed by following <a href="https://github.com/prabirshrestha/vim-lsp">the plugin
instructions</a>. It can be as
simple as adding this line to your <code>.vimrc</code>:</p>
<pre><code>Plug 'prabirshrestha/vim-lsp'
</code></pre>
<p>Next you need to register the <code>rust-analyzer</code> binary. If it is available
in <code>$PATH</code>, you may want to add this to your <code>.vimrc</code>:</p>
<pre><code>if executable('rust-analyzer')
  au User lsp_setup call lsp#register_server({
        \   'name': 'Rust Language Server',
        \   'cmd': {server_info-&gt;['rust-analyzer']},
        \   'whitelist': ['rust'],
        \ })
endif
</code></pre>
<p>There is no dedicated UI for the server configuration, so you would need
to send any options as a value of the <code>initialization_options</code> field, as
described in the <a href="installation/index.html#configuration">Configuration</a> section. Here is an
example of how to enable the proc-macro support:</p>
<pre><code>if executable('rust-analyzer')
  au User lsp_setup call lsp#register_server({
        \   'name': 'Rust Language Server',
        \   'cmd': {server_info-&gt;['rust-analyzer']},
        \   'whitelist': ['rust'],
        \   'initialization_options': {
        \     'cargo': {
        \       'buildScripts': {
        \         'enable': v:true,
        \       },
        \     },
        \     'procMacro': {
        \       'enable': v:true,
        \     },
        \   },
        \ })
endif
</code></pre>
<h2 id="sublime-text"><a class="header" href="#sublime-text">Sublime Text</a></h2>
<h3 id="sublime-text-4"><a class="header" href="#sublime-text-4">Sublime Text 4:</a></h3>
<ul>
<li>Follow the instructions in
<a href="https://github.com/sublimelsp/LSP-rust-analyzer">LSP-rust-analyzer</a>.</li>
</ul>
<p>Install
<a href="https://packagecontrol.io/packages/LSP-file-watcher-chokidar">LSP-file-watcher-chokidar</a>
to enable file watching (<code>workspace/didChangeWatchedFiles</code>).</p>
<h3 id="sublime-text-3"><a class="header" href="#sublime-text-3">Sublime Text 3:</a></h3>
<ul>
<li>
<p>Install the <a href="installation/index.html#rust-analyzer-language-server-binary"><code>rust-analyzer</code>
binary</a>.</p>
</li>
<li>
<p>Install the <a href="https://packagecontrol.io/packages/LSP">LSP package</a>.</p>
</li>
<li>
<p>From the command palette, run <code>LSP: Enable Language Server Globally</code>
and select <code>rust-analyzer</code>.</p>
</li>
</ul>
<p>If it worked, you should see &quot;rust-analyzer, Line X, Column Y&quot; on the
left side of the status bar, and after waiting a bit, functionalities
like tooltips on hovering over variables should become available.</p>
<p>If you get an error saying <code>No such file or directory: 'rust-analyzer'</code>,
see the <a href="installation/index.html#rust-analyzer-language-server-binary"><code>rust-analyzer</code> binary</a>
section on installing the language server binary.</p>
<h2 id="gnome-builder"><a class="header" href="#gnome-builder">GNOME Builder</a></h2>
<p>GNOME Builder 3.37.1 and newer has native <code>rust-analyzer</code> support. If
the LSP binary is not available, GNOME Builder can install it when
opening a Rust file.</p>
<h2 id="eclipse-ide"><a class="header" href="#eclipse-ide">Eclipse IDE</a></h2>
<p>Support for Rust development in the Eclipse IDE is provided by <a href="https://github.com/eclipse/corrosion">Eclipse
Corrosion</a>. If available in PATH
or in some standard location, <code>rust-analyzer</code> is detected and powers
editing of Rust files without further configuration. If <code>rust-analyzer</code>
is not detected, Corrosion will prompt you for configuration of your
Rust toolchain and language server with a link to the <em>Window &gt;
Preferences &gt; Rust</em> preference page; from here a button allows to
download and configure <code>rust-analyzer</code>, but you can also reference
another installation. You‚Äôll need to close and reopen all .rs and Cargo
files, or to restart the IDE, for this change to take effect.</p>
<h2 id="kate-text-editor"><a class="header" href="#kate-text-editor">Kate Text Editor</a></h2>
<p>Support for the language server protocol is built into Kate through the
LSP plugin, which is included by default. It is preconfigured to use
rust-analyzer for Rust sources since Kate 21.12.</p>
<p>To change rust-analyzer config options, start from the following example
and put it into Kate‚Äôs &quot;User Server Settings&quot; tab (located under the LSP
Client settings):</p>
<pre><code>{
    &quot;servers&quot;: {
        &quot;rust&quot;: {
            &quot;initializationOptions&quot;: {
                &quot;cachePriming&quot;: {
                    &quot;enable&quot;: false
                },
                &quot;check&quot;: {
                    &quot;allTargets&quot;: false
                },
                &quot;checkOnSave&quot;: false
            }
        }
    }
}
</code></pre>
<p>Then click on apply, and restart the LSP server for your rust project.</p>
<h2 id="juci"><a class="header" href="#juci">juCi++</a></h2>
<p><a href="https://gitlab.com/cppit/jucipp">juCi++</a> has built-in support for the
language server protocol, and since version 1.7.0 offers installation of
both Rust and rust-analyzer when opening a Rust file.</p>
<h2 id="kakoune"><a class="header" href="#kakoune">Kakoune</a></h2>
<p><a href="https://kakoune.org/">Kakoune</a> supports LSP with the help of
<a href="https://github.com/kak-lsp/kak-lsp"><code>kak-lsp</code></a>. Follow the
<a href="https://github.com/kak-lsp/kak-lsp#installation">instructions</a> to
install <code>kak-lsp</code>. To configure <code>kak-lsp</code>, refer to the <a href="https://github.com/kak-lsp/kak-lsp#configuring-kak-lsp">configuration
section</a> which
is basically about copying the <a href="https://github.com/kak-lsp/kak-lsp/blob/master/kak-lsp.toml">configuration
file</a> in
the right place (latest versions should use <code>rust-analyzer</code> by default).</p>
<p>Finally, you need to configure Kakoune to talk to <code>kak-lsp</code> (see <a href="https://github.com/kak-lsp/kak-lsp#usage">Usage
section</a>). A basic
configuration will only get you LSP but you can also activate inlay
diagnostics and auto-formatting on save. The following might help you
get all of this.</p>
<pre><code>eval %sh{kak-lsp --kakoune -s $kak_session}  # Not needed if you load it with plug.kak.
hook global WinSetOption filetype=rust %{
    # Enable LSP
    lsp-enable-window

    # Auto-formatting on save
    hook window BufWritePre .* lsp-formatting-sync

    # Configure inlay hints (only on save)
    hook window -group rust-inlay-hints BufWritePost .* rust-analyzer-inlay-hints
    hook -once -always window WinSetOption filetype=.* %{
        remove-hooks window rust-inlay-hints
    }
}
</code></pre>
<h2 id="helix"><a class="header" href="#helix">Helix</a></h2>
<p><a href="https://docs.helix-editor.com/">Helix</a> supports LSP by default.
However, it won‚Äôt install <code>rust-analyzer</code> automatically. You can follow
instructions for installing <a href="installation/index.html#rust-analyzer-language-server-binary"><code>rust-analyzer</code>
binary</a>.</p>
<h2 id="visual-studio-2022"><a class="header" href="#visual-studio-2022">Visual Studio 2022</a></h2>
<p>There are multiple rust-analyzer extensions for Visual Studio 2022 on
Windows:</p>
<h3 id="rust-analyzervs"><a class="header" href="#rust-analyzervs">rust-analyzer.vs</a></h3>
<p>(License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0
International)</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=kitamstudios.RustAnalyzer">Visual Studio
Marketplace</a></p>
<p><a href="https://github.com/kitamstudios/rust-analyzer/">GitHub</a></p>
<p>Support for Rust development in the Visual Studio IDE is enabled by the
<a href="https://marketplace.visualstudio.com/items?itemName=kitamstudios.RustAnalyzer">rust-analyzer</a>
package. Either click on the download link or install from IDE‚Äôs
extension manager. For now <a href="https://visualstudio.microsoft.com/downloads/">Visual Studio
2022</a> is required. All
editions are supported viz. Community, Professional &amp; Enterprise. The
package aims to provide 0-friction installation and therefore comes
loaded with most things required including rust-analyzer binary. If
anything it needs is missing, appropriate errors / warnings will guide
the user. E.g. cargo.exe needs to be in path and the package will tell
you as much. This package is under rapid active development. So if you
encounter any issues please file it at
<a href="https://github.com/kitamstudios/rust-analyzer/">rust-analyzer.vs</a>.</p>
<h3 id="vs_rustanalyzer"><a class="header" href="#vs_rustanalyzer">VS_RustAnalyzer</a></h3>
<p>(License: GPL)</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=cchharris.vsrustanalyzer">Visual Studio
Marketplace</a></p>
<p><a href="https://github.com/cchharris/VS-RustAnalyzer">GitHub</a></p>
<h3 id="sourcegear-rust"><a class="header" href="#sourcegear-rust">SourceGear Rust</a></h3>
<p>(License: closed source)</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=SourceGear.SourceGearRust">Visual Studio
Marketplace</a></p>
<p><a href="https://github.com/sourcegear/rust-vs-extension">GitHub (docs, issues,
discussions)</a></p>
<ul>
<li>
<p>Free (no-cost)</p>
</li>
<li>
<p>Supports all editions of Visual Studio 2022 on Windows: Community,
Professional, or Enterprise</p>
</li>
</ul>
<h2 id="lapce"><a class="header" href="#lapce">Lapce</a></h2>
<p><a href="https://lapce.dev/">Lapce</a> has a Rust plugin which you can install
directly. Unfortunately, it downloads an old version of <code>rust-analyzer</code>,
but you can set the server path under Settings.</p>
<h2 id="crates"><a class="header" href="#crates">Crates</a></h2>
<p>There is a package named <code>ra_ap_rust_analyzer</code> available on
<a href="https://crates.io/crates/ra_ap_rust-analyzer">crates.io</a>, for someone
who wants to use it programmatically.</p>
<p>For more details, see <a href="https://github.com/rust-lang/rust-analyzer/blob/master/.github/workflows/publish.yml">the publish
workflow</a>.</p>
<h2 id="zed"><a class="header" href="#zed">Zed</a></h2>
<p><a href="https://zed.dev">Zed</a> has native <code>rust-analyzer</code> support. If the LSP
binary is not available, Zed can install it when opening a Rust file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>Start with looking at the rust-analyzer version. Try <strong>rust-analyzer:
Show RA Version</strong> in VS Code (using <strong>Command Palette</strong> feature
typically activated by Ctrl+Shift+P) or <code>rust-analyzer --version</code> in the
command line. If the date is more than a week ago, it‚Äôs better to update
rust-analyzer version.</p>
<p>The next thing to check would be panic messages in rust-analyzer‚Äôs log.
Log messages are printed to stderr, in VS Code you can see them in the
<code>Output &gt; Rust Analyzer Language Server</code> tab of the panel. To see more
logs, set the <code>RA_LOG=info</code> environment variable, this can be done
either by setting the environment variable manually or by using
<code>rust-analyzer.server.extraEnv</code>, note that both of these approaches
require the server to be restarted.</p>
<p>To fully capture LSP messages between the editor and the server, set
<code>&quot;rust-analyzer.trace.server&quot;: &quot;verbose&quot;</code> config and check
<code>Output &gt; Rust Analyzer Language Server Trace</code>.</p>
<p>The root cause for many ‚Äúnothing works‚Äù problems is that rust-analyzer
fails to understand the project structure. To debug that, first note the
<code>rust-analyzer</code> section in the status bar. If it has an error icon and
red, that‚Äôs the problem (hover will have somewhat helpful error
message). <strong>rust-analyzer: Status</strong> prints dependency information for
the current file. Finally, <code>RA_LOG=project_model=debug</code> enables verbose
logs during project loading.</p>
<p>If rust-analyzer outright crashes, try running
<code>rust-analyzer analysis-stats /path/to/project/directory/</code> on the
command line. This command type checks the whole project in batch mode
bypassing LSP machinery.</p>
<p>When filing issues, it is useful (but not necessary) to try to minimize
examples. An ideal bug reproduction looks like this:</p>
<pre><code>$ git clone https://github.com/username/repo.git &amp;&amp; cd repo &amp;&amp; git switch --detach commit-hash
$ rust-analyzer --version
rust-analyzer dd12184e4 2021-05-08 dev
$ rust-analyzer analysis-stats .
üíÄ üíÄ üíÄ
</code></pre>
<p>It is especially useful when the <code>repo</code> doesn‚Äôt use external crates or
the standard library.</p>
<p>If you want to go as far as to modify the source code to debug the
problem, be sure to take a look at the <a href="https://github.com/rust-lang/rust-analyzer/tree/master/docs/dev">dev
docs</a>!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration"><a class="header" href="#configuration">Configuration</a></h1>
<p><strong>Source:</strong>
<a href="https://github.com/rust-lang/rust-analyzer/blob/master/crates/rust-analyzer/src/config.rs">config.rs</a></p>
<p>The <a href="configuration/index.html#_installation">Installation</a> section contains details on
configuration for some of the editors. In general <code>rust-analyzer</code> is
configured via LSP messages, which means that it‚Äôs up to the editor to
decide on the exact format and location of configuration files.</p>
<p>Some clients, such as <a href="configuration/index.html#vs-code">VS Code</a> or <a href="configuration/index.html#coc-rust-analyzer">COC plugin in
Vim</a> provide <code>rust-analyzer</code> specific configuration
UIs. Others may require you to know a bit more about the interaction
with <code>rust-analyzer</code>.</p>
<p>For the later category, it might help to know that the initial
configuration is specified as a value of the <code>initializationOptions</code>
field of the <a href="https://microsoft.github.io/language-server-protocol/specifications/specification-current/#initialize"><code>InitializeParams</code> message, in the LSP
protocol</a>.
The spec says that the field type is <code>any?</code>, but <code>rust-analyzer</code> is
looking for a JSON object that is constructed using settings from the
list below. Name of the setting, ignoring the <code>rust-analyzer.</code> prefix,
is used as a path, and value of the setting becomes the JSON property
value.</p>
<p>For example, a very common configuration is to enable proc-macro
support, can be achieved by sending this JSON:</p>
<pre><code>{
  &quot;cargo&quot;: {
    &quot;buildScripts&quot;: {
      &quot;enable&quot;: true,
    },
  },
  &quot;procMacro&quot;: {
    &quot;enable&quot;: true,
  }
}
</code></pre>
<p>Please consult your editor‚Äôs documentation to learn more about how to
configure <a href="https://microsoft.github.io/language-server-protocol/">LSP
servers</a>.</p>
<p>To verify which configuration is actually used by <code>rust-analyzer</code>, set
<code>RA_LOG</code> environment variable to <code>rust_analyzer=info</code> and look for
config-related messages. Logs should show both the JSON that
<code>rust-analyzer</code> sees as well as the updated config.</p>
<p>This is the list of config options <code>rust-analyzer</code> supports:</p>
<p><strong>rust-analyzer.assist.emitMustUse</strong> (default: false)</p>
<p>Whether to insert #[must_use] when generating <code>as_</code> methods
for enum variants.</p>
<p><strong>rust-analyzer.assist.expressionFillDefault</strong> (default: &quot;todo&quot;)</p>
<p>Placeholder expression to use for missing expressions in assists.</p>
<p><strong>rust-analyzer.cachePriming.enable</strong> (default: true)</p>
<p>Warm up caches on project load.</p>
<p><strong>rust-analyzer.cachePriming.numThreads</strong> (default: 0)</p>
<p>How many worker threads to handle priming caches. The default <code>0</code> means to pick automatically.</p>
<p><strong>rust-analyzer.cargo.autoreload</strong> (default: true)</p>
<p>Automatically refresh project info via <code>cargo metadata</code> on
<code>Cargo.toml</code> or <code>.cargo/config.toml</code> changes.</p>
<p><strong>rust-analyzer.cargo.buildScripts.enable</strong> (default: true)</p>
<p>Run build scripts (<code>build.rs</code>) for more precise code analysis.</p>
<p><strong>rust-analyzer.cargo.buildScripts.invocationLocation</strong> (default: &quot;workspace&quot;)</p>
<p>Specifies the working directory for running build scripts.</p>
<ul>
<li>&quot;workspace&quot;: run build scripts for a workspace in the workspace's root directory.
This is incompatible with <code>#rust-analyzer.cargo.buildScripts.invocationStrategy#</code> set to <code>once</code>.</li>
<li>&quot;root&quot;: run build scripts in the project's root directory.
This config only has an effect when <code>#rust-analyzer.cargo.buildScripts.overrideCommand#</code>
is set.</li>
</ul>
<p><strong>rust-analyzer.cargo.buildScripts.invocationStrategy</strong> (default: &quot;per_workspace&quot;)</p>
<p>Specifies the invocation strategy to use when running the build scripts command.
If <code>per_workspace</code> is set, the command will be executed for each workspace.
If <code>once</code> is set, the command will be executed once.
This config only has an effect when <code>#rust-analyzer.cargo.buildScripts.overrideCommand#</code>
is set.</p>
<p><strong>rust-analyzer.cargo.buildScripts.overrideCommand</strong> (default: null)</p>
<p>Override the command rust-analyzer uses to run build scripts and
build procedural macros. The command is required to output json
and should therefore include <code>--message-format=json</code> or a similar
option.</p>
<p>If there are multiple linked projects/workspaces, this command is invoked for
each of them, with the working directory being the workspace root
(i.e., the folder containing the <code>Cargo.toml</code>). This can be overwritten
by changing <code>#rust-analyzer.cargo.buildScripts.invocationStrategy#</code> and
<code>#rust-analyzer.cargo.buildScripts.invocationLocation#</code>.</p>
<p>By default, a cargo invocation will be constructed for the configured
targets and features, with the following base command line:</p>
<pre><code class="language-bash">cargo check --quiet --workspace --message-format=json --all-targets
</code></pre>
<p>.</p>
<p><strong>rust-analyzer.cargo.buildScripts.useRustcWrapper</strong> (default: true)</p>
<p>Use <code>RUSTC_WRAPPER=rust-analyzer</code> when running build scripts to
avoid checking unnecessary things.</p>
<p><strong>rust-analyzer.cargo.cfgs</strong> (default: {})</p>
<p>List of cfg options to enable with the given values.</p>
<p><strong>rust-analyzer.cargo.extraArgs</strong> (default: [])</p>
<p>Extra arguments that are passed to every cargo invocation.</p>
<p><strong>rust-analyzer.cargo.extraEnv</strong> (default: {})</p>
<p>Extra environment variables that will be set when running cargo, rustc
or other commands within the workspace. Useful for setting RUSTFLAGS.</p>
<p><strong>rust-analyzer.cargo.features</strong> (default: [])</p>
<p>List of features to activate.</p>
<p>Set this to <code>&quot;all&quot;</code> to pass <code>--all-features</code> to cargo.</p>
<p><strong>rust-analyzer.cargo.noDefaultFeatures</strong> (default: false)</p>
<p>Whether to pass <code>--no-default-features</code> to cargo.</p>
<p><strong>rust-analyzer.cargo.sysroot</strong> (default: &quot;discover&quot;)</p>
<p>Relative path to the sysroot, or &quot;discover&quot; to try to automatically find it via
&quot;rustc --print sysroot&quot;.</p>
<p>Unsetting this disables sysroot loading.</p>
<p>This option does not take effect until rust-analyzer is restarted.</p>
<p><strong>rust-analyzer.cargo.sysrootSrc</strong> (default: null)</p>
<p>Relative path to the sysroot library sources. If left unset, this will default to
<code>{cargo.sysroot}/lib/rustlib/src/rust/library</code>.</p>
<p>This option does not take effect until rust-analyzer is restarted.</p>
<p><strong>rust-analyzer.cargo.target</strong> (default: null)</p>
<p>Compilation target override (target triple).</p>
<p><strong>rust-analyzer.cargo.unsetTest</strong> (default: [&quot;core&quot;])</p>
<p>Unsets the implicit <code>#[cfg(test)]</code> for the specified crates.</p>
<p><strong>rust-analyzer.checkOnSave</strong> (default: true)</p>
<p>Run the check command for diagnostics on save.</p>
<p><strong>rust-analyzer.check.allTargets</strong> (default: true)</p>
<p>Check all targets and tests (<code>--all-targets</code>).</p>
<p><strong>rust-analyzer.check.command</strong> (default: &quot;check&quot;)</p>
<p>Cargo command to use for <code>cargo check</code>.</p>
<p><strong>rust-analyzer.check.extraArgs</strong> (default: [])</p>
<p>Extra arguments for <code>cargo check</code>.</p>
<p><strong>rust-analyzer.check.extraEnv</strong> (default: {})</p>
<p>Extra environment variables that will be set when running <code>cargo check</code>.
Extends <code>#rust-analyzer.cargo.extraEnv#</code>.</p>
<p><strong>rust-analyzer.check.features</strong> (default: null)</p>
<p>List of features to activate. Defaults to
<code>#rust-analyzer.cargo.features#</code>.</p>
<p>Set to <code>&quot;all&quot;</code> to pass <code>--all-features</code> to Cargo.</p>
<p><strong>rust-analyzer.check.ignore</strong> (default: [])</p>
<p>List of <code>cargo check</code> (or other command specified in <code>check.command</code>) diagnostics to ignore.</p>
<p>For example for <code>cargo check</code>: <code>dead_code</code>, <code>unused_imports</code>, <code>unused_variables</code>,...</p>
<p><strong>rust-analyzer.check.invocationLocation</strong> (default: &quot;workspace&quot;)</p>
<p>Specifies the working directory for running checks.</p>
<ul>
<li>&quot;workspace&quot;: run checks for workspaces in the corresponding workspaces' root directories.
This falls back to &quot;root&quot; if <code>#rust-analyzer.cargo.check.invocationStrategy#</code> is set to <code>once</code>.</li>
<li>&quot;root&quot;: run checks in the project's root directory.
This config only has an effect when <code>#rust-analyzer.cargo.check.overrideCommand#</code>
is set.</li>
</ul>
<p><strong>rust-analyzer.check.invocationStrategy</strong> (default: &quot;per_workspace&quot;)</p>
<p>Specifies the invocation strategy to use when running the check command.
If <code>per_workspace</code> is set, the command will be executed for each workspace.
If <code>once</code> is set, the command will be executed once.
This config only has an effect when <code>#rust-analyzer.cargo.check.overrideCommand#</code>
is set.</p>
<p><strong>rust-analyzer.check.noDefaultFeatures</strong> (default: null)</p>
<p>Whether to pass <code>--no-default-features</code> to Cargo. Defaults to
<code>#rust-analyzer.cargo.noDefaultFeatures#</code>.</p>
<p><strong>rust-analyzer.check.overrideCommand</strong> (default: null)</p>
<p>Override the command rust-analyzer uses instead of <code>cargo check</code> for
diagnostics on save. The command is required to output json and
should therefore include <code>--message-format=json</code> or a similar option
(if your client supports the <code>colorDiagnosticOutput</code> experimental
capability, you can use <code>--message-format=json-diagnostic-rendered-ansi</code>).</p>
<p>If you're changing this because you're using some tool wrapping
Cargo, you might also want to change
<code>#rust-analyzer.cargo.buildScripts.overrideCommand#</code>.</p>
<p>If there are multiple linked projects/workspaces, this command is invoked for
each of them, with the working directory being the workspace root
(i.e., the folder containing the <code>Cargo.toml</code>). This can be overwritten
by changing <code>#rust-analyzer.cargo.check.invocationStrategy#</code> and
<code>#rust-analyzer.cargo.check.invocationLocation#</code>.</p>
<p>An example command would be:</p>
<pre><code class="language-bash">cargo check --workspace --message-format=json --all-targets
</code></pre>
<p>.</p>
<p><strong>rust-analyzer.check.targets</strong> (default: null)</p>
<p>Check for specific targets. Defaults to <code>#rust-analyzer.cargo.target#</code> if empty.</p>
<p>Can be a single target, e.g. <code>&quot;x86_64-unknown-linux-gnu&quot;</code> or a list of targets, e.g.
<code>[&quot;aarch64-apple-darwin&quot;, &quot;x86_64-apple-darwin&quot;]</code>.</p>
<p>Aliased as <code>&quot;checkOnSave.targets&quot;</code>.</p>
<p><strong>rust-analyzer.completion.autoimport.enable</strong> (default: true)</p>
<p>Toggles the additional completions that automatically add imports when completed.
Note that your client must specify the <code>additionalTextEdits</code> LSP client capability to truly have this feature enabled.</p>
<p><strong>rust-analyzer.completion.autoself.enable</strong> (default: true)</p>
<p>Toggles the additional completions that automatically show method calls and field accesses
with <code>self</code> prefixed to them when inside a method.</p>
<p><strong>rust-analyzer.completion.callable.snippets</strong> (default: &quot;fill_arguments&quot;)</p>
<p>Whether to add parenthesis and argument snippets when completing function.</p>
<p><strong>rust-analyzer.completion.fullFunctionSignatures.enable</strong> (default: false)</p>
<p>Whether to show full function/method signatures in completion docs.</p>
<p><strong>rust-analyzer.completion.limit</strong> (default: null)</p>
<p>Maximum number of completions to return. If <code>None</code>, the limit is infinite.</p>
<p><strong>rust-analyzer.completion.postfix.enable</strong> (default: true)</p>
<p>Whether to show postfix snippets like <code>dbg</code>, <code>if</code>, <code>not</code>, etc.</p>
<p><strong>rust-analyzer.completion.privateEditable.enable</strong> (default: false)</p>
<p>Enables completions of private items and fields that are defined in the current workspace even if they are not visible at the current position.</p>
<p><strong>rust-analyzer.completion.snippets.custom</strong></p>
<p>Default:</p>
<pre><code class="language-{">            &quot;Arc::new&quot;: {
                &quot;postfix&quot;: &quot;arc&quot;,
                &quot;body&quot;: &quot;Arc::new(${receiver})&quot;,
                &quot;requires&quot;: &quot;std::sync::Arc&quot;,
                &quot;description&quot;: &quot;Put the expression into an `Arc`&quot;,
                &quot;scope&quot;: &quot;expr&quot;
            },
            &quot;Rc::new&quot;: {
                &quot;postfix&quot;: &quot;rc&quot;,
                &quot;body&quot;: &quot;Rc::new(${receiver})&quot;,
                &quot;requires&quot;: &quot;std::rc::Rc&quot;,
                &quot;description&quot;: &quot;Put the expression into an `Rc`&quot;,
                &quot;scope&quot;: &quot;expr&quot;
            },
            &quot;Box::pin&quot;: {
                &quot;postfix&quot;: &quot;pinbox&quot;,
                &quot;body&quot;: &quot;Box::pin(${receiver})&quot;,
                &quot;requires&quot;: &quot;std::boxed::Box&quot;,
                &quot;description&quot;: &quot;Put the expression into a pinned `Box`&quot;,
                &quot;scope&quot;: &quot;expr&quot;
            },
            &quot;Ok&quot;: {
                &quot;postfix&quot;: &quot;ok&quot;,
                &quot;body&quot;: &quot;Ok(${receiver})&quot;,
                &quot;description&quot;: &quot;Wrap the expression in a `Result::Ok`&quot;,
                &quot;scope&quot;: &quot;expr&quot;
            },
            &quot;Err&quot;: {
                &quot;postfix&quot;: &quot;err&quot;,
                &quot;body&quot;: &quot;Err(${receiver})&quot;,
                &quot;description&quot;: &quot;Wrap the expression in a `Result::Err`&quot;,
                &quot;scope&quot;: &quot;expr&quot;
            },
            &quot;Some&quot;: {
                &quot;postfix&quot;: &quot;some&quot;,
                &quot;body&quot;: &quot;Some(${receiver})&quot;,
                &quot;description&quot;: &quot;Wrap the expression in an `Option::Some`&quot;,
                &quot;scope&quot;: &quot;expr&quot;
            }
        }

</code></pre>
<p>Custom completion snippets.</p>
<p><strong>rust-analyzer.diagnostics.disabled</strong> (default: [])</p>
<p>List of rust-analyzer diagnostics to disable.</p>
<p><strong>rust-analyzer.diagnostics.enable</strong> (default: true)</p>
<p>Whether to show native rust-analyzer diagnostics.</p>
<p><strong>rust-analyzer.diagnostics.experimental.enable</strong> (default: false)</p>
<p>Whether to show experimental rust-analyzer diagnostics that might
have more false positives than usual.</p>
<p><strong>rust-analyzer.diagnostics.remapPrefix</strong> (default: {})</p>
<p>Map of prefixes to be substituted when parsing diagnostic file paths.
This should be the reverse mapping of what is passed to <code>rustc</code> as <code>--remap-path-prefix</code>.</p>
<p><strong>rust-analyzer.diagnostics.warningsAsHint</strong> (default: [])</p>
<p>List of warnings that should be displayed with hint severity.</p>
<p>The warnings will be indicated by faded text or three dots in code
and will not show up in the <code>Problems Panel</code>.</p>
<p><strong>rust-analyzer.diagnostics.warningsAsInfo</strong> (default: [])</p>
<p>List of warnings that should be displayed with info severity.</p>
<p>The warnings will be indicated by a blue squiggly underline in code
and a blue icon in the <code>Problems Panel</code>.</p>
<p><strong>rust-analyzer.files.excludeDirs</strong> (default: [])</p>
<p>These directories will be ignored by rust-analyzer. They are
relative to the workspace root, and globs are not supported. You may
also need to add the folders to Code's <code>files.watcherExclude</code>.</p>
<p><strong>rust-analyzer.files.watcher</strong> (default: &quot;client&quot;)</p>
<p>Controls file watching implementation.</p>
<p><strong>rust-analyzer.highlightRelated.breakPoints.enable</strong> (default: true)</p>
<p>Enables highlighting of related references while the cursor is on <code>break</code>, <code>loop</code>, <code>while</code>, or <code>for</code> keywords.</p>
<p><strong>rust-analyzer.highlightRelated.closureCaptures.enable</strong> (default: true)</p>
<p>Enables highlighting of all captures of a closure while the cursor is on the <code>|</code> or move keyword of a closure.</p>
<p><strong>rust-analyzer.highlightRelated.exitPoints.enable</strong> (default: true)</p>
<p>Enables highlighting of all exit points while the cursor is on any <code>return</code>, <code>?</code>, <code>fn</code>, or return type arrow (<code>-&gt;</code>).</p>
<p><strong>rust-analyzer.highlightRelated.references.enable</strong> (default: true)</p>
<p>Enables highlighting of related references while the cursor is on any identifier.</p>
<p><strong>rust-analyzer.highlightRelated.yieldPoints.enable</strong> (default: true)</p>
<p>Enables highlighting of all break points for a loop or block context while the cursor is on any <code>async</code> or <code>await</code> keywords.</p>
<p><strong>rust-analyzer.hover.actions.debug.enable</strong> (default: true)</p>
<p>Whether to show <code>Debug</code> action. Only applies when
<code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<p><strong>rust-analyzer.hover.actions.enable</strong> (default: true)</p>
<p>Whether to show HoverActions in Rust files.</p>
<p><strong>rust-analyzer.hover.actions.gotoTypeDef.enable</strong> (default: true)</p>
<p>Whether to show <code>Go to Type Definition</code> action. Only applies when
<code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<p><strong>rust-analyzer.hover.actions.implementations.enable</strong> (default: true)</p>
<p>Whether to show <code>Implementations</code> action. Only applies when
<code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<p><strong>rust-analyzer.hover.actions.references.enable</strong> (default: false)</p>
<p>Whether to show <code>References</code> action. Only applies when
<code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<p><strong>rust-analyzer.hover.actions.run.enable</strong> (default: true)</p>
<p>Whether to show <code>Run</code> action. Only applies when
<code>#rust-analyzer.hover.actions.enable#</code> is set.</p>
<p><strong>rust-analyzer.hover.documentation.enable</strong> (default: true)</p>
<p>Whether to show documentation on hover.</p>
<p><strong>rust-analyzer.hover.documentation.keywords.enable</strong> (default: true)</p>
<p>Whether to show keyword hover popups. Only applies when
<code>#rust-analyzer.hover.documentation.enable#</code> is set.</p>
<p><strong>rust-analyzer.hover.links.enable</strong> (default: true)</p>
<p>Use markdown syntax for links on hover.</p>
<p><strong>rust-analyzer.hover.memoryLayout.alignment</strong> (default: &quot;hexadecimal&quot;)</p>
<p>How to render the align information in a memory layout hover.</p>
<p><strong>rust-analyzer.hover.memoryLayout.enable</strong> (default: true)</p>
<p>Whether to show memory layout data on hover.</p>
<p><strong>rust-analyzer.hover.memoryLayout.niches</strong> (default: false)</p>
<p>How to render the niche information in a memory layout hover.</p>
<p><strong>rust-analyzer.hover.memoryLayout.offset</strong> (default: &quot;hexadecimal&quot;)</p>
<p>How to render the offset information in a memory layout hover.</p>
<p><strong>rust-analyzer.hover.memoryLayout.size</strong> (default: &quot;both&quot;)</p>
<p>How to render the size information in a memory layout hover.</p>
<p><strong>rust-analyzer.imports.granularity.enforce</strong> (default: false)</p>
<p>Whether to enforce the import granularity setting for all files. If set to false rust-analyzer will try to keep import styles consistent per file.</p>
<p><strong>rust-analyzer.imports.granularity.group</strong> (default: &quot;crate&quot;)</p>
<p>How imports should be grouped into use statements.</p>
<p><strong>rust-analyzer.imports.group.enable</strong> (default: true)</p>
<p>Group inserted imports by the <a href="https://rust-analyzer.github.io/manual.html#auto-import">following order</a>. Groups are separated by newlines.</p>
<p><strong>rust-analyzer.imports.merge.glob</strong> (default: true)</p>
<p>Whether to allow import insertion to merge new imports into single path glob imports like <code>use std::fmt::*;</code>.</p>
<p><strong>rust-analyzer.imports.preferNoStd</strong> (default: false)</p>
<p>Prefer to unconditionally use imports of the core and alloc crate, over the std crate.</p>
<p><strong>rust-analyzer.imports.preferPrelude</strong> (default: false)</p>
<p>Whether to prefer import paths containing a <code>prelude</code> module.</p>
<p><strong>rust-analyzer.imports.prefix</strong> (default: &quot;plain&quot;)</p>
<p>The path structure for newly inserted paths to use.</p>
<p><strong>rust-analyzer.inlayHints.bindingModeHints.enable</strong> (default: false)</p>
<p>Whether to show inlay type hints for binding modes.</p>
<p><strong>rust-analyzer.inlayHints.chainingHints.enable</strong> (default: true)</p>
<p>Whether to show inlay type hints for method chains.</p>
<p><strong>rust-analyzer.inlayHints.closingBraceHints.enable</strong> (default: true)</p>
<p>Whether to show inlay hints after a closing <code>}</code> to indicate what item it belongs to.</p>
<p><strong>rust-analyzer.inlayHints.closingBraceHints.minLines</strong> (default: 25)</p>
<p>Minimum number of lines required before the <code>}</code> until the hint is shown (set to 0 or 1
to always show them).</p>
<p><strong>rust-analyzer.inlayHints.closureCaptureHints.enable</strong> (default: false)</p>
<p>Whether to show inlay hints for closure captures.</p>
<p><strong>rust-analyzer.inlayHints.closureReturnTypeHints.enable</strong> (default: &quot;never&quot;)</p>
<p>Whether to show inlay type hints for return types of closures.</p>
<p><strong>rust-analyzer.inlayHints.closureStyle</strong> (default: &quot;impl_fn&quot;)</p>
<p>Closure notation in type and chaining inlay hints.</p>
<p><strong>rust-analyzer.inlayHints.discriminantHints.enable</strong> (default: &quot;never&quot;)</p>
<p>Whether to show enum variant discriminant hints.</p>
<p><strong>rust-analyzer.inlayHints.expressionAdjustmentHints.enable</strong> (default: &quot;never&quot;)</p>
<p>Whether to show inlay hints for type adjustments.</p>
<p><strong>rust-analyzer.inlayHints.expressionAdjustmentHints.hideOutsideUnsafe</strong> (default: false)</p>
<p>Whether to hide inlay hints for type adjustments outside of <code>unsafe</code> blocks.</p>
<p><strong>rust-analyzer.inlayHints.expressionAdjustmentHints.mode</strong> (default: &quot;prefix&quot;)</p>
<p>Whether to show inlay hints as postfix ops (<code>.*</code> instead of <code>*</code>, etc).</p>
<p><strong>rust-analyzer.inlayHints.lifetimeElisionHints.enable</strong> (default: &quot;never&quot;)</p>
<p>Whether to show inlay type hints for elided lifetimes in function signatures.</p>
<p><strong>rust-analyzer.inlayHints.lifetimeElisionHints.useParameterNames</strong> (default: false)</p>
<p>Whether to prefer using parameter names as the name for elided lifetime hints if possible.</p>
<p><strong>rust-analyzer.inlayHints.maxLength</strong> (default: 25)</p>
<p>Maximum length for inlay hints. Set to null to have an unlimited length.</p>
<p><strong>rust-analyzer.inlayHints.parameterHints.enable</strong> (default: true)</p>
<p>Whether to show function parameter name inlay hints at the call
site.</p>
<p><strong>rust-analyzer.inlayHints.reborrowHints.enable</strong> (default: &quot;never&quot;)</p>
<p>Whether to show inlay hints for compiler inserted reborrows.
This setting is deprecated in favor of #rust-analyzer.inlayHints.expressionAdjustmentHints.enable#.</p>
<p><strong>rust-analyzer.inlayHints.renderColons</strong> (default: true)</p>
<p>Whether to render leading colons for type hints, and trailing colons for parameter hints.</p>
<p><strong>rust-analyzer.inlayHints.typeHints.enable</strong> (default: true)</p>
<p>Whether to show inlay type hints for variables.</p>
<p><strong>rust-analyzer.inlayHints.typeHints.hideClosureInitialization</strong> (default: false)</p>
<p>Whether to hide inlay type hints for <code>let</code> statements that initialize to a closure.
Only applies to closures with blocks, same as <code>#rust-analyzer.inlayHints.closureReturnTypeHints.enable#</code>.</p>
<p><strong>rust-analyzer.inlayHints.typeHints.hideNamedConstructor</strong> (default: false)</p>
<p>Whether to hide inlay type hints for constructors.</p>
<p><strong>rust-analyzer.interpret.tests</strong> (default: false)</p>
<p>Enables the experimental support for interpreting tests.</p>
<p><strong>rust-analyzer.joinLines.joinAssignments</strong> (default: true)</p>
<p>Join lines merges consecutive declaration and initialization of an assignment.</p>
<p><strong>rust-analyzer.joinLines.joinElseIf</strong> (default: true)</p>
<p>Join lines inserts else between consecutive ifs.</p>
<p><strong>rust-analyzer.joinLines.removeTrailingComma</strong> (default: true)</p>
<p>Join lines removes trailing commas.</p>
<p><strong>rust-analyzer.joinLines.unwrapTrivialBlock</strong> (default: true)</p>
<p>Join lines unwraps trivial blocks.</p>
<p><strong>rust-analyzer.lens.debug.enable</strong> (default: true)</p>
<p>Whether to show <code>Debug</code> lens. Only applies when
<code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.lens.enable</strong> (default: true)</p>
<p>Whether to show CodeLens in Rust files.</p>
<p><strong>rust-analyzer.lens.forceCustomCommands</strong> (default: true)</p>
<p>Internal config: use custom client-side commands even when the
client doesn't set the corresponding capability.</p>
<p><strong>rust-analyzer.lens.implementations.enable</strong> (default: true)</p>
<p>Whether to show <code>Implementations</code> lens. Only applies when
<code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.lens.location</strong> (default: &quot;above_name&quot;)</p>
<p>Where to render annotations.</p>
<p><strong>rust-analyzer.lens.references.adt.enable</strong> (default: false)</p>
<p>Whether to show <code>References</code> lens for Struct, Enum, and Union.
Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.lens.references.enumVariant.enable</strong> (default: false)</p>
<p>Whether to show <code>References</code> lens for Enum Variants.
Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.lens.references.method.enable</strong> (default: false)</p>
<p>Whether to show <code>Method References</code> lens. Only applies when
<code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.lens.references.trait.enable</strong> (default: false)</p>
<p>Whether to show <code>References</code> lens for Trait.
Only applies when <code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.lens.run.enable</strong> (default: true)</p>
<p>Whether to show <code>Run</code> lens. Only applies when
<code>#rust-analyzer.lens.enable#</code> is set.</p>
<p><strong>rust-analyzer.linkedProjects</strong> (default: [])</p>
<p>Disable project auto-discovery in favor of explicitly specified set
of projects.</p>
<p>Elements must be paths pointing to <code>Cargo.toml</code>,
<code>rust-project.json</code>, or JSON objects in <code>rust-project.json</code> format.</p>
<p><strong>rust-analyzer.lru.capacity</strong> (default: null)</p>
<p>Number of syntax trees rust-analyzer keeps in memory. Defaults to 128.</p>
<p><strong>rust-analyzer.lru.query.capacities</strong> (default: {})</p>
<p>Sets the LRU capacity of the specified queries.</p>
<p><strong>rust-analyzer.notifications.cargoTomlNotFound</strong> (default: true)</p>
<p>Whether to show <code>can't find Cargo.toml</code> error message.</p>
<p><strong>rust-analyzer.numThreads</strong> (default: null)</p>
<p>How many worker threads in the main loop. The default <code>null</code> means to pick automatically.</p>
<p><strong>rust-analyzer.procMacro.attributes.enable</strong> (default: true)</p>
<p>Expand attribute macros. Requires <code>#rust-analyzer.procMacro.enable#</code> to be set.</p>
<p><strong>rust-analyzer.procMacro.enable</strong> (default: true)</p>
<p>Enable support for procedural macros, implies <code>#rust-analyzer.cargo.buildScripts.enable#</code>.</p>
<p><strong>rust-analyzer.procMacro.ignored</strong> (default: {})</p>
<p>These proc-macros will be ignored when trying to expand them.</p>
<p>This config takes a map of crate names with the exported proc-macro names to ignore as values.</p>
<p><strong>rust-analyzer.procMacro.server</strong> (default: null)</p>
<p>Internal config, path to proc-macro server executable.</p>
<p><strong>rust-analyzer.references.excludeImports</strong> (default: false)</p>
<p>Exclude imports from find-all-references.</p>
<p><strong>rust-analyzer.runnables.command</strong> (default: null)</p>
<p>Command to be executed instead of 'cargo' for runnables.</p>
<p><strong>rust-analyzer.runnables.extraArgs</strong> (default: [])</p>
<p>Additional arguments to be passed to cargo for runnables such as
tests or binaries. For example, it may be <code>--release</code>.</p>
<p><strong>rust-analyzer.rust.analyzerTargetDir</strong> (default: null)</p>
<p>Optional path to a rust-analyzer specific target directory.
This prevents rust-analyzer's <code>cargo check</code> from locking the <code>Cargo.lock</code>
at the expense of duplicating build artifacts.</p>
<p>Set to <code>true</code> to use a subdirectory of the existing target directory or
set to a path relative to the workspace to use that path.</p>
<p><strong>rust-analyzer.rustc.source</strong> (default: null)</p>
<p>Path to the Cargo.toml of the rust compiler workspace, for usage in rustc_private
projects, or &quot;discover&quot; to try to automatically find it if the <code>rustc-dev</code> component
is installed.</p>
<p>Any project which uses rust-analyzer with the rustcPrivate
crates must set <code>[package.metadata.rust-analyzer] rustc_private=true</code> to use it.</p>
<p>This option does not take effect until rust-analyzer is restarted.</p>
<p><strong>rust-analyzer.rustfmt.extraArgs</strong> (default: [])</p>
<p>Additional arguments to <code>rustfmt</code>.</p>
<p><strong>rust-analyzer.rustfmt.overrideCommand</strong> (default: null)</p>
<p>Advanced option, fully override the command rust-analyzer uses for
formatting. This should be the equivalent of <code>rustfmt</code> here, and
not that of <code>cargo fmt</code>. The file contents will be passed on the
standard input and the formatted result will be read from the
standard output.</p>
<p><strong>rust-analyzer.rustfmt.rangeFormatting.enable</strong> (default: false)</p>
<p>Enables the use of rustfmt's unstable range formatting command for the
<code>textDocument/rangeFormatting</code> request. The rustfmt option is unstable and only
available on a nightly build.</p>
<p><strong>rust-analyzer.semanticHighlighting.doc.comment.inject.enable</strong> (default: true)</p>
<p>Inject additional highlighting into doc comments.</p>
<p>When enabled, rust-analyzer will highlight rust source in doc comments as well as intra
doc links.</p>
<p><strong>rust-analyzer.semanticHighlighting.nonStandardTokens</strong> (default: true)</p>
<p>Whether the server is allowed to emit non-standard tokens and modifiers.</p>
<p><strong>rust-analyzer.semanticHighlighting.operator.enable</strong> (default: true)</p>
<p>Use semantic tokens for operators.</p>
<p>When disabled, rust-analyzer will emit semantic tokens only for operator tokens when
they are tagged with modifiers.</p>
<p><strong>rust-analyzer.semanticHighlighting.operator.specialization.enable</strong> (default: false)</p>
<p>Use specialized semantic tokens for operators.</p>
<p>When enabled, rust-analyzer will emit special token types for operator tokens instead
of the generic <code>operator</code> token type.</p>
<p><strong>rust-analyzer.semanticHighlighting.punctuation.enable</strong> (default: false)</p>
<p>Use semantic tokens for punctuation.</p>
<p>When disabled, rust-analyzer will emit semantic tokens only for punctuation tokens when
they are tagged with modifiers or have a special role.</p>
<p><strong>rust-analyzer.semanticHighlighting.punctuation.separate.macro.bang</strong> (default: false)</p>
<p>When enabled, rust-analyzer will emit a punctuation semantic token for the <code>!</code> of macro
calls.</p>
<p><strong>rust-analyzer.semanticHighlighting.punctuation.specialization.enable</strong> (default: false)</p>
<p>Use specialized semantic tokens for punctuation.</p>
<p>When enabled, rust-analyzer will emit special token types for punctuation tokens instead
of the generic <code>punctuation</code> token type.</p>
<p><strong>rust-analyzer.semanticHighlighting.strings.enable</strong> (default: true)</p>
<p>Use semantic tokens for strings.</p>
<p>In some editors (e.g. vscode) semantic tokens override other highlighting grammars.
By disabling semantic tokens for strings, other grammars can be used to highlight
their contents.</p>
<p><strong>rust-analyzer.signatureInfo.detail</strong> (default: &quot;full&quot;)</p>
<p>Show full signature of the callable. Only shows parameters if disabled.</p>
<p><strong>rust-analyzer.signatureInfo.documentation.enable</strong> (default: true)</p>
<p>Show documentation.</p>
<p><strong>rust-analyzer.typing.autoClosingAngleBrackets.enable</strong> (default: false)</p>
<p>Whether to insert closing angle brackets when typing an opening angle bracket of a generic argument list.</p>
<p><strong>rust-analyzer.workspace.symbol.search.kind</strong> (default: &quot;only_types&quot;)</p>
<p>Workspace symbol search kind.</p>
<p><strong>rust-analyzer.workspace.symbol.search.limit</strong> (default: 128)</p>
<p>Limits the number of items returned from a workspace symbol search (Defaults to 128).
Some clients like vs-code issue new searches on result filtering and don't require all results to be returned in the initial search.
Other clients requires all results upfront and might require a higher limit.</p>
<p><strong>rust-analyzer.workspace.symbol.search.scope</strong> (default: &quot;workspace&quot;)</p>
<p>Workspace symbol search scope.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-cargo-based-projects"><a class="header" href="#non-cargo-based-projects">Non-Cargo Based Projects</a></h1>
<p>rust-analyzer does not require Cargo. However, if you use some other
build system, you‚Äôll have to describe the structure of your project for
rust-analyzer in the <code>rust-project.json</code> format:</p>
<pre><code>interface JsonProject {
    /// Path to the sysroot directory.
    ///
    /// The sysroot is where rustc looks for the
    /// crates that are built-in to rust, such as
    /// std.
    ///
    /// https://doc.rust-lang.org/rustc/command-line-arguments.html#--sysroot-override-the-system-root
    ///
    /// To see the current value of sysroot, you
    /// can query rustc:
    ///
    /// ```
    /// $ rustc --print sysroot
    /// /Users/yourname/.rustup/toolchains/stable-x86_64-apple-darwin
    /// ```
    sysroot?: string;
    /// Path to the directory with *source code* of
    /// sysroot crates.
    ///
    /// By default, this is `lib/rustlib/src/rust/library`
    /// relative to the sysroot.
    ///
    /// It should point to the directory where std,
    /// core, and friends can be found:
    ///
    /// https://github.com/rust-lang/rust/tree/master/library.
    ///
    /// If provided, rust-analyzer automatically adds
    /// dependencies on sysroot crates. Conversely,
    /// if you omit this path, you can specify sysroot
    /// dependencies yourself and, for example, have
    /// several different &quot;sysroots&quot; in one graph of
    /// crates.
    sysroot_src?: string;
    /// The set of crates comprising the current
    /// project. Must include all transitive
    /// dependencies as well as sysroot crate (libstd,
    /// libcore and such).
    crates: Crate[];
}

interface Crate {
    /// Optional crate name used for display purposes,
    /// without affecting semantics. See the `deps`
    /// key for semantically-significant crate names.
    display_name?: string;
    /// Path to the root module of the crate.
    root_module: string;
    /// Edition of the crate.
    edition: &quot;2015&quot; | &quot;2018&quot; | &quot;2021&quot;;
    /// Dependencies
    deps: Dep[];
    /// Should this crate be treated as a member of
    /// current &quot;workspace&quot;.
    ///
    /// By default, inferred from the `root_module`
    /// (members are the crates which reside inside
    /// the directory opened in the editor).
    ///
    /// Set this to `false` for things like standard
    /// library and 3rd party crates to enable
    /// performance optimizations (rust-analyzer
    /// assumes that non-member crates don't change).
    is_workspace_member?: boolean;
    /// Optionally specify the (super)set of `.rs`
    /// files comprising this crate.
    ///
    /// By default, rust-analyzer assumes that only
    /// files under `root_module.parent` can belong
    /// to a crate. `include_dirs` are included
    /// recursively, unless a subdirectory is in
    /// `exclude_dirs`.
    ///
    /// Different crates can share the same `source`.
    ///
    /// If two crates share an `.rs` file in common,
    /// they *must* have the same `source`.
    /// rust-analyzer assumes that files from one
    /// source can't refer to files in another source.
    source?: {
        include_dirs: string[],
        exclude_dirs: string[],
    },
    /// The set of cfgs activated for a given crate, like
    /// `[&quot;unix&quot;, &quot;feature=\&quot;foo\&quot;&quot;, &quot;feature=\&quot;bar\&quot;&quot;]`.
    cfg: string[];
    /// Target triple for this Crate.
    ///
    /// Used when running `rustc --print cfg`
    /// to get target-specific cfgs.
    target?: string;
    /// Environment variables, used for
    /// the `env!` macro
    env: { [key: string]: string; },

    /// Whether the crate is a proc-macro crate.
    is_proc_macro: boolean;
    /// For proc-macro crates, path to compiled
    /// proc-macro (.so file).
    proc_macro_dylib_path?: string;
}

interface Dep {
    /// Index of a crate in the `crates` array.
    crate: number,
    /// Name as should appear in the (implicit)
    /// `extern crate name` declaration.
    name: string,
}
</code></pre>
<p>This format is provisional and subject to change. Specifically, the
<code>roots</code> setup will be different eventually.</p>
<p>There are three ways to feed <code>rust-project.json</code> to rust-analyzer:</p>
<ul>
<li>
<p>Place <code>rust-project.json</code> file at the root of the project, and
rust-analyzer will discover it.</p>
</li>
<li>
<p>Specify
<code>&quot;rust-analyzer.linkedProjects&quot;: [ &quot;path/to/rust-project.json&quot; ]</code> in
the settings (and make sure that your LSP client sends settings as a
part of initialize request).</p>
</li>
<li>
<p>Specify
<code>&quot;rust-analyzer.linkedProjects&quot;: [ { &quot;roots&quot;: [‚Ä¶‚Äã], &quot;crates&quot;: [‚Ä¶‚Äã] }]</code>
inline.</p>
</li>
</ul>
<p>Relative paths are interpreted relative to <code>rust-project.json</code> file
location or (for inline JSON) relative to <code>rootUri</code>.</p>
<p>See <a href="https://github.com/rust-analyzer/rust-project.json-example">https://github.com/rust-analyzer/rust-project.json-example</a> for a
small example.</p>
<p>You can set the <code>RA_LOG</code> environment variable to <code>rust_analyzer=info</code> to
inspect how rust-analyzer handles config and project loading.</p>
<p>Note that calls to <code>cargo check</code> are disabled when using
<code>rust-project.json</code> by default, so compilation errors and warnings will
no longer be sent to your LSP client. To enable these compilation errors
you will need to specify explicitly what command rust-analyzer should
run to perform the checks using the
<code>rust-analyzer.check.overrideCommand</code> configuration. As an example, the
following configuration explicitly sets <code>cargo check</code> as the <code>check</code>
command.</p>
<pre><code>{ &quot;rust-analyzer.check.overrideCommand&quot;: [&quot;cargo&quot;, &quot;check&quot;, &quot;--message-format=json&quot;] }
</code></pre>
<p><code>check.overrideCommand</code> requires the command specified to output json
error messages for rust-analyzer to consume. The <code>--message-format=json</code>
flag does this for <code>cargo check</code> so whichever command you use must also
output errors in this format. See the <a href="non_cargo_based_projects/index.html#_configuration">Configuration</a>
section for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security"><a class="header" href="#security">Security</a></h1>
<p>At the moment, rust-analyzer assumes that all code is trusted. Here is a
<strong>non-exhaustive</strong> list of ways to make rust-analyzer execute arbitrary
code:</p>
<ul>
<li>
<p>proc macros and build scripts are executed by default</p>
</li>
<li>
<p><code>.cargo/config</code> can override <code>rustc</code> with an arbitrary executable</p>
</li>
<li>
<p><code>rust-toolchain.toml</code> can override <code>rustc</code> with an arbitrary
executable</p>
</li>
<li>
<p>VS Code plugin reads configuration from project directory, and that
can be used to override paths to various executables, like <code>rustfmt</code>
or <code>rust-analyzer</code> itself.</p>
</li>
<li>
<p>rust-analyzer‚Äôs syntax trees library uses a lot of <code>unsafe</code> and
hasn‚Äôt been properly audited for memory safety.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="privacy"><a class="header" href="#privacy">Privacy</a></h1>
<p>The LSP server performs no network access in itself, but runs
<code>cargo metadata</code> which will update or download the crate registry and
the source code of the project dependencies. If enabled (the default),
build scripts and procedural macros can do anything.</p>
<p>The Code extension does not access the network.</p>
<p>Any other editor plugins are not under the control of the
<code>rust-analyzer</code> developers. For any privacy concerns, you should check
with their respective developers.</p>
<p>For <code>rust-analyzer</code> developers, <code>cargo xtask release</code> uses the GitHub
API to put together the release notes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="features"><a class="header" href="#features">Features</a></h1>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/annotations.rs#20">annotations.rs</a> </p>
<p>Provides user with annotations above items for looking up references or impl blocks
and running/debugging binaries.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020672-b7c34f00-917a-11eb-8f6e-858735660a0e.png" alt="Annotations" /></p>
<h3 id="auto-import"><a class="header" href="#auto-import">Auto Import</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-assists/src/handlers/auto_import.rs#15">auto_import.rs</a> </p>
<p>Using the <code>auto-import</code> assist it is possible to insert missing imports for unresolved items.
When inserting an import it will do so in a structured manner by keeping imports grouped,
separated by a newline in the following order:</p>
<ul>
<li><code>std</code> and <code>core</code></li>
<li>External Crates</li>
<li>Current Crate, paths prefixed by <code>crate</code></li>
<li>Current Module, paths prefixed by <code>self</code></li>
<li>Super Module, paths prefixed by <code>super</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-rust">use std::fs::File;

use itertools::Itertools;
use syntax::ast;

use crate::utils::insert_use;

use self::auto_import;

use super::AssistContext;</code></pre>
<h4 id="import-granularity"><a class="header" href="#import-granularity">Import Granularity</a></h4>
<p>It is possible to configure how use-trees are merged with the <code>imports.granularity.group</code> setting.
It has the following configurations:</p>
<ul>
<li><code>crate</code>: Merge imports from the same crate into a single use statement. This kind of
nesting is only supported in Rust versions later than 1.24.</li>
<li><code>module</code>: Merge imports from the same module into a single use statement.</li>
<li><code>item</code>: Don't merge imports at all, creating one import per item.</li>
<li><code>preserve</code>: Do not change the granularity of any imports. For auto-import this has the same
effect as <code>item</code>.</li>
</ul>
<p>In <code>VS Code</code> the configuration for this is <code>rust-analyzer.imports.granularity.group</code>.</p>
<h4 id="import-prefix"><a class="header" href="#import-prefix">Import Prefix</a></h4>
<p>The style of imports in the same crate is configurable through the <code>imports.prefix</code> setting.
It has the following configurations:</p>
<ul>
<li><code>crate</code>: This setting will force paths to be always absolute, starting with the <code>crate</code>
prefix, unless the item is defined outside of the current crate.</li>
<li><code>self</code>: This setting will force paths that are relative to the current module to always
start with <code>self</code>. This will result in paths that always start with either <code>crate</code>, <code>self</code>,
<code>super</code> or an extern crate identifier.</li>
<li><code>plain</code>: This setting does not impose any restrictions in imports.</li>
</ul>
<p>In <code>VS Code</code> the configuration for this is <code>rust-analyzer.imports.prefix</code>.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020673-b85be580-917a-11eb-9022-59585f35d4f8.gif" alt="Auto Import" /></p>
<h3 id="completion-with-autoimport"><a class="header" href="#completion-with-autoimport">Completion With Autoimport</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-completion/src/completions/flyimport.rs#19">flyimport.rs</a> </p>
<p>When completing names in the current scope, proposes additional imports from other modules or crates,
if they can be qualified in the scope, and their name contains all symbols from the completion input.</p>
<p>To be considered applicable, the name must contain all input symbols in the given order, not necessarily adjacent.
If any input symbol is not lowercased, the name must contain all symbols in exact case; otherwise the containing is checked case-insensitively.</p>
<pre><code>fn main() {
    pda$0
}
# pub mod std { pub mod marker { pub struct PhantomData { } } }
</code></pre>
<p>-&gt;</p>
<pre><code>use std::marker::PhantomData;

fn main() {
    PhantomData
}
# pub mod std { pub mod marker { pub struct PhantomData { } } }
</code></pre>
<p>Also completes associated items, that require trait imports.
If any unresolved and/or partially-qualified path precedes the input, it will be taken into account.
Currently, only the imports with their import path ending with the whole qualifier will be proposed
(no fuzzy matching for qualifier).</p>
<pre><code>mod foo {
    pub mod bar {
        pub struct Item;

        impl Item {
            pub const TEST_ASSOC: usize = 3;
        }
    }
}

fn main() {
    bar::Item::TEST_A$0
}
</code></pre>
<p>-&gt;</p>
<pre><code>use foo::bar;

mod foo {
    pub mod bar {
        pub struct Item;

        impl Item {
            pub const TEST_ASSOC: usize = 3;
        }
    }
}

fn main() {
    bar::Item::TEST_ASSOC
}
</code></pre>
<p>NOTE: currently, if an assoc item comes from a trait that's not currently imported, and it also has an unresolved and/or partially-qualified path,
no imports will be proposed.</p>
<h4 id="fuzzy-search-details"><a class="header" href="#fuzzy-search-details">Fuzzy search details</a></h4>
<p>To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only
(i.e. in <code>HashMap</code> in the <code>std::collections::HashMap</code> path).
For the same reasons, avoids searching for any path imports for inputs with their length less than 2 symbols
(but shows all associated items for any input length).</p>
<h4 id="import-configuration"><a class="header" href="#import-configuration">Import configuration</a></h4>
<p>It is possible to configure how use-trees are merged with the <code>imports.granularity.group</code> setting.
Mimics the corresponding behavior of the <code>Auto Import</code> feature.</p>
<h4 id="lsp-and-performance-implications"><a class="header" href="#lsp-and-performance-implications">LSP and performance implications</a></h4>
<p>The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the <code>additionalTextEdits</code>
(case-sensitive) resolve client capability in its client capabilities.
This way the server is able to defer the costly computations, doing them for a selected completion item only.
For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,
which might be slow ergo the feature is automatically disabled.</p>
<h4 id="feature-toggle"><a class="header" href="#feature-toggle">Feature toggle</a></h4>
<p>The feature can be forcefully turned off in the settings with the <code>rust-analyzer.completion.autoimport.enable</code> flag.
Note that having this flag set to <code>true</code> does not guarantee that the feature is enabled: your client needs to have the corresponding
capability enabled.</p>
<h3 id="debug-itemtree"><a class="header" href="#debug-itemtree">Debug ItemTree</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/view_item_tree.rs#5">view_item_tree.rs</a> </p>
<p>Displays the ItemTree of the currently open file, for debugging.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Debug ItemTree</strong></td></tr>
</tbody></table>
</div>
<h3 id="expand-macro-recursively"><a class="header" href="#expand-macro-recursively">Expand Macro Recursively</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/expand_macro.rs#15">expand_macro.rs</a> </p>
<p>Shows the full macro expansion of the macro at the current caret position.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Expand macro recursively</strong></td></tr>
</tbody></table>
</div>
<p><img src="features//img/features/expand_macro_recursively.gif" alt="Expand Macro Recursively" /></p>
<h3 id="expand-and-shrink-selection"><a class="header" href="#expand-and-shrink-selection">Expand and Shrink Selection</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/extend_selection.rs#15">extend_selection.rs</a> </p>
<p>Extends or shrinks the current selection to the encompassing syntactic construct
(expression, statement, item, module, etc). It works with multiple cursors.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Alt+Shift+‚Üí</kbd>, <kbd>Alt+Shift+‚Üê</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020651-b42fc800-917a-11eb-8a4f-cf1a07859fac.gif" alt="Expand and Shrink Selection" /></p>
<h3 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/file_structure.rs#25">file_structure.rs</a> </p>
<p>Provides a tree of the symbols defined in the file. Can be used to</p>
<ul>
<li>fuzzy search symbol in a file (super useful)</li>
<li>draw breadcrumbs to describe the context around the cursor</li>
<li>draw outline of the file</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+Shift+O</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020654-b42fc800-917a-11eb-8388-e7dc4d92b02e.gif" alt="File Structure" /></p>
<h3 id="find-all-references"><a class="header" href="#find-all-references">Find All References</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/references.rs#43">references.rs</a> </p>
<p>Shows all references of the item at the cursor location</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Shift+Alt+F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020670-b7c34f00-917a-11eb-8003-370ac5f2b3cb.gif" alt="Find All References" /></p>
<h3 id="folding"><a class="header" href="#folding">Folding</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/folding_ranges.rs#36">folding_ranges.rs</a> </p>
<p>Defines folding regions for curly braced blocks, runs of consecutive use, mod, const or static
items, and <code>region</code> / <code>endregion</code> comment markers.</p>
<h3 id="format-string-completion"><a class="header" href="#format-string-completion">Format String Completion</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-completion/src/completions/postfix/format_like.rs#0">format_like.rs</a> </p>
<p><code>&quot;Result {result} is {2 + 2}&quot;</code> is expanded to the <code>&quot;Result {} is {}&quot;, result, 2 + 2</code>.</p>
<p>The following postfix snippets are available:</p>
<ul>
<li><code>format</code> -&gt; <code>format!(...)</code></li>
<li><code>panic</code> -&gt; <code>panic!(...)</code></li>
<li><code>println</code> -&gt; <code>println!(...)</code></li>
<li><code>log</code>:
** <code>logd</code> -&gt; <code>log::debug!(...)</code>
** <code>logt</code> -&gt; <code>log::trace!(...)</code>
** <code>logi</code> -&gt; <code>log::info!(...)</code>
** <code>logw</code> -&gt; <code>log::warn!(...)</code>
** <code>loge</code> -&gt; <code>log::error!(...)</code></li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48062697/113020656-b560f500-917a-11eb-87de-02991f61beb8.gif" alt="Format String Completion" /></p>
<h3 id="go-to-declaration"><a class="header" href="#go-to-declaration">Go to Declaration</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/goto_declaration.rs#13">goto_declaration.rs</a> </p>
<p>Navigates to the declaration of an identifier.</p>
<p>This is the same as <code>Go to Definition</code> with the following exceptions:</p>
<ul>
<li>outline modules will navigate to the <code>mod name;</code> item declaration</li>
<li>trait assoc items will navigate to the assoc item of the trait declaration opposed to the trait impl</li>
<li>fields in patterns will navigate to the field declaration of the struct, union or variant</li>
</ul>
<h3 id="go-to-definition"><a class="header" href="#go-to-definition">Go to Definition</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/goto_definition.rs#17">goto_definition.rs</a> </p>
<p>Navigates to the definition of an identifier.</p>
<p>For outline modules, this will navigate to the source file of the module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065563-025fbe00-91b1-11eb-83e4-a5a703610b23.gif" alt="Go to Definition" /></p>
<h3 id="go-to-implementation"><a class="header" href="#go-to-implementation">Go to Implementation</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/goto_implementation.rs#12">goto_implementation.rs</a> </p>
<p>Navigates to the impl blocks of types.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065566-02f85480-91b1-11eb-9288-aaad8abd8841.gif" alt="Go to Implementation" /></p>
<h3 id="go-to-type-definition"><a class="header" href="#go-to-type-definition">Go to Type Definition</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/goto_type_definition.rs#6">goto_type_definition.rs</a> </p>
<p>Navigates to the type of an identifier.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Go to Type Definition</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020657-b560f500-917a-11eb-9007-0f809733a338.gif" alt="Go to Type Definition" /></p>
<h3 id="highlight-related"><a class="header" href="#highlight-related">Highlight Related</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/highlight_related.rs#40">highlight_related.rs</a> </p>
<p>Highlights constructs related to the thing under the cursor:</p>
<ol>
<li>if on an identifier, highlights all references to that identifier in the current file
<ul>
<li>additionally, if the identifier is a trait in a where clause, type parameter trait bound or use item, highlights all references to that trait's assoc items in the corresponding scope</li>
</ul>
</li>
<li>if on an <code>async</code> or `await token, highlights all yield points for that async context</li>
<li>if on a <code>return</code> or <code>fn</code> keyword, <code>?</code> character or <code>-&gt;</code> return type arrow, highlights all exit points for that context</li>
<li>if on a <code>break</code>, <code>loop</code>, <code>while</code> or <code>for</code> token, highlights all break points for that loop or block context</li>
<li>if on a <code>move</code> or <code>|</code> token that belongs to a closure, highlights all captures of the closure.</li>
</ol>
<p>Note: <code>?</code>, <code>|</code> and <code>-&gt;</code> do not currently trigger this behavior in the VSCode editor.</p>
<h3 id="hover"><a class="header" href="#hover">Hover</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/hover.rs#97">hover.rs</a> </p>
<p>Shows additional information, like the type of an expression or the documentation for a definition when &quot;focusing&quot; code.
Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020658-b5f98b80-917a-11eb-9f88-3dbc27320c95.gif" alt="Hover" /></p>
<h3 id="inlay-hints"><a class="header" href="#inlay-hints">Inlay Hints</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/inlay_hints.rs#421">inlay_hints.rs</a> </p>
<p>rust-analyzer shows additional information inline with the source code.
Editors usually render this using read-only virtual text snippets interspersed with code.</p>
<p>rust-analyzer by default shows hints for</p>
<ul>
<li>types of local variables</li>
<li>names of function arguments</li>
<li>types of chained expressions</li>
</ul>
<p>Optionally, one can enable additional hints for</p>
<ul>
<li>return types of closure expressions</li>
<li>elided lifetimes</li>
<li>compiler inserted reborrows</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/48062697/113020660-b5f98b80-917a-11eb-8d70-3be3fd558cdd.png" alt="Hover" /></p>
<h3 id="interpret-function"><a class="header" href="#interpret-function">Interpret Function</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/interpret_function.rs#9">interpret_function.rs</a> </p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Interpret Function</strong></td></tr>
</tbody></table>
</div>
<h3 id="join-lines"><a class="header" href="#join-lines">Join Lines</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/join_lines.rs#20">join_lines.rs</a> </p>
<p>Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.</p>
<p>See <a href="features/img/features/join_lines-1.gif">this gif</a> for the cases handled specially by joined lines.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Join lines</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020661-b6922200-917a-11eb-87c4-b75acc028f11.gif" alt="Join Lines" /></p>
<h3 id="magic-completions"><a class="header" href="#magic-completions">Magic Completions</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-completion/src/lib.rs#45">lib.rs</a> </p>
<p>In addition to usual reference completion, rust-analyzer provides some ‚ú®magic‚ú®
completions as well:</p>
<p>Keywords like <code>if</code>, <code>else</code> <code>while</code>, <code>loop</code> are completed with braces, and cursor
is placed at the appropriate position. Even though <code>if</code> is easy to type, you
still want to complete it, to get <code> { }</code> for free! <code>return</code> is inserted with a
space or <code>;</code> depending on the return type of the function.</p>
<p>When completing a function call, <code>()</code> are automatically inserted. If a function
takes arguments, the cursor is positioned inside the parenthesis.</p>
<p>There are postfix completions, which can be triggered by typing something like
<code>foo().if</code>. The word after <code>.</code> determines postfix completion. Possible variants are:</p>
<ul>
<li><code>expr.if</code> -&gt; <code>if expr {}</code> or <code>if let ... {}</code> for <code>Option</code> or <code>Result</code></li>
<li><code>expr.match</code> -&gt; <code>match expr {}</code></li>
<li><code>expr.while</code> -&gt; <code>while expr {}</code> or <code>while let ... {}</code> for <code>Option</code> or <code>Result</code></li>
<li><code>expr.ref</code> -&gt; <code>&amp;expr</code></li>
<li><code>expr.refm</code> -&gt; <code>&amp;mut expr</code></li>
<li><code>expr.let</code> -&gt; <code>let $0 = expr;</code></li>
<li><code>expr.letm</code> -&gt; <code>let mut $0 = expr;</code></li>
<li><code>expr.not</code> -&gt; <code>!expr</code></li>
<li><code>expr.dbg</code> -&gt; <code>dbg!(expr)</code></li>
<li><code>expr.dbgr</code> -&gt; <code>dbg!(&amp;expr)</code></li>
<li><code>expr.call</code> -&gt; <code>(expr)</code></li>
</ul>
<p>There also snippet completions:</p>
<h4 id="expressions"><a class="header" href="#expressions">Expressions</a></h4>
<ul>
<li><code>pd</code> -&gt; <code>eprintln!(&quot; = {:?}&quot;, );</code></li>
<li><code>ppd</code> -&gt; <code>eprintln!(&quot; = {:#?}&quot;, );</code></li>
</ul>
<h4 id="items"><a class="header" href="#items">Items</a></h4>
<ul>
<li><code>tfn</code> -&gt; <code>#[test] fn feature(){}</code></li>
<li><code>tmod</code> -&gt;</li>
</ul>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_name() {}
}</code></pre>
<p>And the auto import completions, enabled with the <code>rust-analyzer.completion.autoimport.enable</code> setting and the corresponding LSP client capabilities.
Those are the additional completion options with automatic <code>use</code> import and options from all project importable items,
fuzzy matched against the completion input.</p>
<p><img src="https://user-images.githubusercontent.com/48062697/113020667-b72ab880-917a-11eb-8778-716cf26a0eb3.gif" alt="Magic Completions" /></p>
<h3 id="matching-brace"><a class="header" href="#matching-brace">Matching Brace</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/matching_brace.rs#6">matching_brace.rs</a> </p>
<p>If the cursor is on any brace (<code>&lt;&gt;(){}[]||</code>) which is a part of a brace-pair,
moves cursor to the matching brace. It uses the actual parser to determine
braces, so it won't confuse generics with comparisons.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Find matching brace</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065573-04298180-91b1-11eb-8dec-d4e2a202f304.gif" alt="Matching Brace" /></p>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-db/src/apply_change.rs#43">apply_change.rs</a> </p>
<p>Clears rust-analyzer's internal database and prints memory usage statistics.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Memory Usage (Clears Database)</strong></td></tr>
</tbody></table>
</div>
<h3 id="move-item"><a class="header" href="#move-item">Move Item</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/move_item.rs#15">move_item.rs</a> </p>
<p>Move item under cursor or selection up and down.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Move item up</strong></td></tr>
<tr><td>VS Code</td><td><strong>rust-analyzer: Move item down</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065576-04298180-91b1-11eb-91ce-4505e99ed598.gif" alt="Move Item" /></p>
<h3 id="on-enter"><a class="header" href="#on-enter">On Enter</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/typing/on_enter.rs#16">on_enter.rs</a> </p>
<p>rust-analyzer can override <kbd>Enter</kbd> key to make it smarter:</p>
<ul>
<li><kbd>Enter</kbd> inside triple-slash comments automatically inserts <code>///</code></li>
<li><kbd>Enter</kbd> in the middle or after a trailing space in <code>//</code> inserts <code>//</code></li>
<li><kbd>Enter</kbd> inside <code>//!</code> doc comments automatically inserts <code>//!</code></li>
<li><kbd>Enter</kbd> after <code>{</code> indents contents and closing <code>}</code> of single-line block</li>
</ul>
<p>This action needs to be assigned to shortcut explicitly.</p>
<p>Note that, depending on the other installed extensions, this feature can visibly slow down typing.
Similarly, if rust-analyzer crashes or stops responding, <code>Enter</code> might not work.
In that case, you can still press <code>Shift-Enter</code> to insert a newline.</p>
<h4 id="vs-code-1"><a class="header" href="#vs-code-1">VS Code</a></h4>
<p>Add the following to <code>keybindings.json</code>:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;Enter&quot;,
  &quot;command&quot;: &quot;rust-analyzer.onEnter&quot;,
  &quot;when&quot;: &quot;editorTextFocus &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == rust&quot;
}
</code></pre>
<p>When using the Vim plugin:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;Enter&quot;,
  &quot;command&quot;: &quot;rust-analyzer.onEnter&quot;,
  &quot;when&quot;: &quot;editorTextFocus &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == rust &amp;&amp; vim.mode == 'Insert'&quot;
}
</code></pre>
<p><img src="https://user-images.githubusercontent.com/48062697/113065578-04c21800-91b1-11eb-82b8-22b8c481e645.gif" alt="On Enter" /></p>
<h3 id="on-typing-assists"><a class="header" href="#on-typing-assists">On Typing Assists</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/typing.rs#42">typing.rs</a> </p>
<p>Some features trigger on typing certain characters:</p>
<ul>
<li>typing <code>let =</code> tries to smartly add <code>;</code> if <code>=</code> is followed by an existing expression</li>
<li>typing <code>=</code> between two expressions adds <code>;</code> when in statement position</li>
<li>typing <code>=</code> to turn an assignment into an equality comparison removes <code>;</code> when in expression position</li>
<li>typing <code>.</code> in a chain method call auto-indents</li>
<li>typing <code>{</code> or <code>(</code> in front of an expression inserts a closing <code>}</code> or <code>)</code> after the expression</li>
<li>typing <code>{</code> in a use item adds a closing <code>}</code> in the right place</li>
</ul>
<h4 id="vs-code-2"><a class="header" href="#vs-code-2">VS Code</a></h4>
<p>Add the following to <code>settings.json</code>:</p>
<pre><code class="language-json">&quot;editor.formatOnType&quot;: true,
</code></pre>
<p><img src="https://user-images.githubusercontent.com/48062697/113166163-69758500-923a-11eb-81ee-eb33ec380399.gif" alt="On Typing Assists" />
<img src="https://user-images.githubusercontent.com/48062697/113171066-105c2000-923f-11eb-87ab-f4a263346567.gif" alt="On Typing Assists" /></p>
<h3 id="open-docs"><a class="header" href="#open-docs">Open Docs</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/doc_links.rs#121">doc_links.rs</a> </p>
<p>Retrieve a links to documentation for the given symbol.</p>
<p>The simplest way to use this feature is via the context menu. Right-click on
the selected item. The context menu opens. Select <strong>Open Docs</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Open Docs</strong></td></tr>
</tbody></table>
</div>
<h3 id="parent-module"><a class="header" href="#parent-module">Parent Module</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/parent_module.rs#14">parent_module.rs</a> </p>
<p>Navigates to the parent module of the current module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Locate parent module</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065580-04c21800-91b1-11eb-9a32-00086161c0bd.gif" alt="Parent Module" /></p>
<h3 id="related-tests"><a class="header" href="#related-tests">Related Tests</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/runnables.rs#194">runnables.rs</a> </p>
<p>Provides a sneak peek of all tests where the current item is used.</p>
<p>The simplest way to use this feature is via the context menu. Right-click on
the selected item. The context menu opens. Select <strong>Peek Related Tests</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Peek Related Tests</strong></td></tr>
</tbody></table>
</div>
<h3 id="rename"><a class="header" href="#rename">Rename</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/rename.rs#73">rename.rs</a> </p>
<p>Renames the item below the cursor and all of its references</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>F2</kbd></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065582-055aae80-91b1-11eb-8ade-2b58e6d81883.gif" alt="Rename" /></p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/runnables.rs#111">runnables.rs</a> </p>
<p>Shows a popup suggesting to run a test/benchmark/binary <strong>at the current cursor
location</strong>. Super useful for repeatedly running just a single test. Do bind this
to a shortcut!</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Run</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065583-055aae80-91b1-11eb-958f-d67efcaf6a2f.gif" alt="Run" /></p>
<h3 id="semantic-syntax-highlighting"><a class="header" href="#semantic-syntax-highlighting">Semantic Syntax Highlighting</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/syntax_highlighting.rs#65">syntax_highlighting.rs</a> </p>
<p>rust-analyzer highlights the code semantically.
For example, <code>Bar</code> in <code>foo::Bar</code> might be colored differently depending on whether <code>Bar</code> is an enum or a trait.
rust-analyzer does not specify colors directly, instead it assigns a tag (like <code>struct</code>) and a set of modifiers (like <code>declaration</code>) to each token.
It's up to the client to map those to specific colors.</p>
<p>The general rule is that a reference to an entity gets colored the same way as the entity itself.
We also give special modifier for <code>mut</code> and <code>&amp;mut</code> local variables.</p>
<h4 id="token-tags"><a class="header" href="#token-tags">Token Tags</a></h4>
<p>Rust-analyzer currently emits the following token tags:</p>
<ul>
<li>For items:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>attribute</td><td>Emitted for attribute macros.</td></tr>
<tr><td>enum</td><td>Emitted for enums.</td></tr>
<tr><td>function</td><td>Emitted for free-standing functions.</td></tr>
<tr><td>derive</td><td>Emitted for derive macros.</td></tr>
<tr><td>macro</td><td>Emitted for function-like macros.</td></tr>
<tr><td>method</td><td>Emitted for associated functions, also knowns as methods.</td></tr>
<tr><td>namespace</td><td>Emitted for modules.</td></tr>
<tr><td>struct</td><td>Emitted for structs.</td></tr>
<tr><td>trait</td><td>Emitted for traits.</td></tr>
<tr><td>typeAlias</td><td>Emitted for type aliases and <code>Self</code> in <code>impl</code>s.</td></tr>
<tr><td>union</td><td>Emitted for unions.</td></tr>
</tbody></table>
</div>
<ul>
<li>For literals:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>boolean</td><td>Emitted for the boolean literals <code>true</code> and <code>false</code>.</td></tr>
<tr><td>character</td><td>Emitted for character literals.</td></tr>
<tr><td>number</td><td>Emitted for numeric literals.</td></tr>
<tr><td>string</td><td>Emitted for string literals.</td></tr>
<tr><td>escapeSequence</td><td>Emitted for escaped sequences inside strings like <code>\n</code>.</td></tr>
<tr><td>formatSpecifier</td><td>Emitted for format specifiers <code>{:?}</code> in <code>format!</code>-like macros.</td></tr>
</tbody></table>
</div>
<ul>
<li>For operators:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>operator</td><td>Emitted for general operators.</td></tr>
<tr><td>arithmetic</td><td>Emitted for the arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>.</td></tr>
<tr><td>bitwise</td><td>Emitted for the bitwise operators `</td></tr>
<tr><td>comparison</td><td>Emitted for the comparison oerators <code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>.</td></tr>
<tr><td>logical</td><td>Emitted for the logical operatos `</td></tr>
</tbody></table>
</div>
<ul>
<li>For punctuation:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>punctuation</td><td>Emitted for general punctuation.</td></tr>
<tr><td>attributeBracket</td><td>Emitted for attribute invocation brackets, that is the <code>#[</code> and <code>]</code> tokens.</td></tr>
<tr><td>angle</td><td>Emitted for <code>&lt;&gt;</code> angle brackets.</td></tr>
<tr><td>brace</td><td>Emitted for <code>{}</code> braces.</td></tr>
<tr><td>bracket</td><td>Emitted for <code>[]</code> brackets.</td></tr>
<tr><td>parenthesis</td><td>Emitted for <code>()</code> parentheses.</td></tr>
<tr><td>colon</td><td>Emitted for the <code>:</code> token.</td></tr>
<tr><td>comma</td><td>Emitted for the <code>,</code> token.</td></tr>
<tr><td>dot</td><td>Emitted for the <code>.</code> token.</td></tr>
<tr><td>semi</td><td>Emitted for the <code>;</code> token.</td></tr>
<tr><td>macroBang</td><td>Emitted for the <code>!</code> token in macro calls.</td></tr>
</tbody></table>
</div>
<ul>
<li></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>builtinAttribute</td><td>Emitted for names to builtin attributes in attribute path, the <code>repr</code> in <code>#[repr(u8)]</code> for example.</td></tr>
<tr><td>builtinType</td><td>Emitted for builtin types like <code>u32</code>, <code>str</code> and <code>f32</code>.</td></tr>
<tr><td>comment</td><td>Emitted for comments.</td></tr>
<tr><td>constParameter</td><td>Emitted for const parameters.</td></tr>
<tr><td>deriveHelper</td><td>Emitted for derive helper attributes.</td></tr>
<tr><td>enumMember</td><td>Emitted for enum variants.</td></tr>
<tr><td>generic</td><td>Emitted for generic tokens that have no mapping.</td></tr>
<tr><td>keyword</td><td>Emitted for keywords.</td></tr>
<tr><td>label</td><td>Emitted for labels.</td></tr>
<tr><td>lifetime</td><td>Emitted for lifetimes.</td></tr>
<tr><td>parameter</td><td>Emitted for non-self function parameters.</td></tr>
<tr><td>property</td><td>Emitted for struct and union fields.</td></tr>
<tr><td>selfKeyword</td><td>Emitted for the self function parameter and self path-specifier.</td></tr>
<tr><td>selfTypeKeyword</td><td>Emitted for the Self type parameter.</td></tr>
<tr><td>toolModule</td><td>Emitted for tool modules.</td></tr>
<tr><td>typeParameter</td><td>Emitted for type parameters.</td></tr>
<tr><td>unresolvedReference</td><td>Emitted for unresolved references, names that rust-analyzer can't find the definition of.</td></tr>
<tr><td>variable</td><td>Emitted for locals, constants and statics.</td></tr>
</tbody></table>
</div>
<h4 id="token-modifiers"><a class="header" href="#token-modifiers">Token Modifiers</a></h4>
<p>Token modifiers allow to style some elements in the source code more precisely.</p>
<p>Rust-analyzer currently emits the following token modifiers:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>async</td><td>Emitted for async functions and the <code>async</code> and <code>await</code> keywords.</td></tr>
<tr><td>attribute</td><td>Emitted for tokens inside attributes.</td></tr>
<tr><td>callable</td><td>Emitted for locals whose types implements one of the <code>Fn*</code> taits.</td></tr>
<tr><td>constant</td><td>Emitted for const.</td></tr>
<tr><td>consuming</td><td>Emitted for locals that are being consumed when use in a fuction call.</td></tr>
<tr><td>controlFlow</td><td>Emitted for control-flow related tokens, this includes th <code>?</code> operator.</td></tr>
<tr><td>crateRoot</td><td>Emitted for crate names, like <code>serde</code> and `crate.</td></tr>
<tr><td>declaration</td><td>Emitted for names of definitions, like <code>foo</code> in <code>fn foo(){}</code>.</td></tr>
<tr><td>defaultLibrary</td><td>Emitted for items from built-in crates (std, core, allc, test and proc_macro).</td></tr>
<tr><td>documentation</td><td>Emitted for documentation comment.</td></tr>
<tr><td>injected</td><td>Emitted for doc-string injected highlighting like rust sourc blocks in documentation.</td></tr>
<tr><td>intraDocLink</td><td>Emitted for intra doc links in doc-string.</td></tr>
<tr><td>library</td><td>Emitted for items that are defined outside of the current crae.</td></tr>
<tr><td>macro</td><td>Emitted for tokens inside macro call.</td></tr>
<tr><td>mutable</td><td>Emitted for mutable locals and statics as well as functions tking <code>&amp;mut self</code>.</td></tr>
<tr><td>public</td><td>Emitted for items that are from the current crate and are `pub.</td></tr>
<tr><td>reference</td><td>Emitted for locals behind a reference and functions taking self` by reference.</td></tr>
<tr><td>static</td><td>Emitted for &quot;static&quot; functions, also known as functions that d not take a <code>self</code> param, as well as statics and consts.</td></tr>
<tr><td>trait</td><td>Emitted for associated trait item.</td></tr>
<tr><td>unsafe</td><td>Emitted for unsafe operations, like unsafe function calls, as ell as the <code>unsafe</code> token.</td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113164457-06cfb980-9239-11eb-819b-0f93e646acf8.png" alt="Semantic Syntax Highlighting" />
<img src="https://user-images.githubusercontent.com/48062697/113187625-f7f50100-9250-11eb-825e-91c58f236071.png" alt="Semantic Syntax Highlighting" /></p>
<h3 id="show-dependency-tree"><a class="header" href="#show-dependency-tree">Show Dependency Tree</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/fetch_crates.rs#13">fetch_crates.rs</a> </p>
<p>Shows a view tree with all the dependencies of this project</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Panel Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Rust Dependencies</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/5748995/229394139-2625beab-f4c9-484b-84ed-ad5dee0b1e1a.png" alt="Show Dependency Tree" /></p>
<h3 id="show-syntax-tree"><a class="header" href="#show-syntax-tree">Show Syntax Tree</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/syntax_tree.rs#9">syntax_tree.rs</a> </p>
<p>Shows the parse tree of the current file. It exists mostly for debugging
rust-analyzer itself.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Show Syntax Tree</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065586-068bdb80-91b1-11eb-9507-fee67f9f45a0.gif" alt="Show Syntax Tree" /></p>
<h3 id="shuffle-crate-graph"><a class="header" href="#shuffle-crate-graph">Shuffle Crate Graph</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/shuffle_crate_graph.rs#7">shuffle_crate_graph.rs</a> </p>
<p>Randomizes all crate IDs in the crate graph, for debugging.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Shuffle Crate Graph</strong></td></tr>
</tbody></table>
</div>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/status.rs#28">status.rs</a> </p>
<p>Shows internal statistic about memory usage of rust-analyzer.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Status</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065584-05f34500-91b1-11eb-98cc-5c196f76be7f.gif" alt="Status" /></p>
<h3 id="structural-search-and-replace"><a class="header" href="#structural-search-and-replace">Structural Search and Replace</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-ssr/src/lib.rs#8">lib.rs</a> </p>
<p>Search and replace with named wildcards that will match any expression, type, path, pattern or item.
The syntax for a structural search replace command is <code>&lt;search_pattern&gt; ==&gt;&gt; &lt;replace_pattern&gt;</code>.
A <code>$&lt;name&gt;</code> placeholder in the search pattern will match any AST node and <code>$&lt;name&gt;</code> will reference it in the replacement.
Within a macro call, a placeholder will match up until whatever token follows the placeholder.</p>
<p>All paths in both the search pattern and the replacement template must resolve in the context
in which this command is invoked. Paths in the search pattern will then match the code if they
resolve to the same item, even if they're written differently. For example if we invoke the
command in the module <code>foo</code> with a pattern of <code>Bar</code>, then code in the parent module that refers
to <code>foo::Bar</code> will match.</p>
<p>Paths in the replacement template will be rendered appropriately for the context in which the
replacement occurs. For example if our replacement template is <code>foo::Bar</code> and we match some
code in the <code>foo</code> module, we'll insert just <code>Bar</code>.</p>
<p>Inherent method calls should generally be written in UFCS form. e.g. <code>foo::Bar::baz($s, $a)</code> will
match <code>$s.baz($a)</code>, provided the method call <code>baz</code> resolves to the method <code>foo::Bar::baz</code>. When a
placeholder is the receiver of a method call in the search pattern (e.g. <code>$s.foo()</code>), but not in
the replacement template (e.g. <code>bar($s)</code>), then *, &amp; and &amp;mut will be added as needed to mirror
whatever autoderef and autoref was happening implicitly in the matched code.</p>
<p>The scope of the search / replace will be restricted to the current selection if any, otherwise
it will apply to the whole workspace.</p>
<p>Placeholders may be given constraints by writing them as <code>${&lt;name&gt;:&lt;constraint1&gt;:&lt;constraint2&gt;...}</code>.</p>
<p>Supported constraints:</p>
<div class="table-wrapper"><table><thead><tr><th>Constraint</th><th>Restricts placeholder</th></tr></thead><tbody>
<tr><td>kind(literal)</td><td>Is a literal (e.g. <code>42</code> or <code>&quot;forty two&quot;</code>)</td></tr>
<tr><td>not(a)</td><td>Negates the constraint <code>a</code></td></tr>
</tbody></table>
</div>
<p>Available via the command <code>rust-analyzer.ssr</code>.</p>
<pre><code class="language-rust">// Using structural search replace command [foo($a, $b) ==&gt;&gt; ($a).foo($b)]

// BEFORE
String::from(foo(y + 5, z))

// AFTER
String::from((y + 5).foo(z))</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Structural Search Replace</strong></td></tr>
</tbody></table>
</div>
<p>Also available as an assist, by writing a comment containing the structural
search and replace rule. You will only see the assist if the comment can
be parsed as a valid structural search and replace rule.</p>
<pre><code class="language-rust">// Place the cursor on the line below to see the assist üí°.
// foo($a, $b) ==&gt;&gt; ($a).foo($b)</code></pre>
<h3 id="user-snippet-completions"><a class="header" href="#user-snippet-completions">User Snippet Completions</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-completion/src/snippet.rs#5">snippet.rs</a> </p>
<p>rust-analyzer allows the user to define custom (postfix)-snippets that may depend on items to be accessible for the current scope to be applicable.</p>
<p>A custom snippet can be defined by adding it to the <code>rust-analyzer.completion.snippets.custom</code> object respectively.</p>
<pre><code class="language-json">{
  &quot;rust-analyzer.completion.snippets.custom&quot;: {
    &quot;thread spawn&quot;: {
      &quot;prefix&quot;: [&quot;spawn&quot;, &quot;tspawn&quot;],
      &quot;body&quot;: [
        &quot;thread::spawn(move || {&quot;,
        &quot;\t$0&quot;,
        &quot;});&quot;,
      ],
      &quot;description&quot;: &quot;Insert a thread::spawn call&quot;,
      &quot;requires&quot;: &quot;std::thread&quot;,
      &quot;scope&quot;: &quot;expr&quot;,
    }
  }
}
</code></pre>
<p>In the example above:</p>
<ul>
<li>
<p><code>&quot;thread spawn&quot;</code> is the name of the snippet.</p>
</li>
<li>
<p><code>prefix</code> defines one or more trigger words that will trigger the snippets completion.
Using <code>postfix</code> will instead create a postfix snippet.</p>
</li>
<li>
<p><code>body</code> is one or more lines of content joined via newlines for the final output.</p>
</li>
<li>
<p><code>description</code> is an optional description of the snippet, if unset the snippet name will be used.</p>
</li>
<li>
<p><code>requires</code> is an optional list of item paths that have to be resolvable in the current crate where the completion is rendered.</p>
</li>
</ul>
<h3 id="view-crate-graph"><a class="header" href="#view-crate-graph">View Crate Graph</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/view_crate_graph.rs#8">view_crate_graph.rs</a> </p>
<p>Renders the currently loaded crate graph as an SVG graphic. Requires the <code>dot</code> tool, which
is part of graphviz, to be installed.</p>
<p>Only workspace crates are included, no crates.io dependencies or sysroot crates.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Crate Graph</strong></td></tr>
</tbody></table>
</div>
<h3 id="view-hir"><a class="header" href="#view-hir">View Hir</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/view_hir.rs#6">view_hir.rs</a> </p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Hir</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113065588-068bdb80-91b1-11eb-9a78-0b4ef1e972fb.gif" alt="View Hir" /></p>
<h3 id="view-memory-layout"><a class="header" href="#view-memory-layout">View Memory Layout</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/view_memory_layout.rs#77">view_memory_layout.rs</a> </p>
<p>Displays the recursive memory layout of a datatype.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Memory Layout</strong></td></tr>
</tbody></table>
</div>
<h3 id="view-mir"><a class="header" href="#view-mir">View Mir</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide/src/view_mir.rs#6">view_mir.rs</a> </p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Mir</strong></td></tr>
</tbody></table>
</div>
<h3 id="workspace-symbol"><a class="header" href="#workspace-symbol">Workspace Symbol</a></h3>
<p><strong>Source:</strong>  <a href="features/crates/ide-db/src/symbol_index.rs#181">symbol_index.rs</a> </p>
<p>Uses fuzzy-search to find types, modules and functions by name across your
project and dependencies. This is <strong>the</strong> most useful feature, which improves code
navigation tremendously. It mostly works on top of the built-in LSP
functionality, however <code>#</code> and <code>*</code> symbols can be used to narrow down the
search. Specifically,</p>
<ul>
<li><code>Foo</code> searches for <code>Foo</code> type in the current workspace</li>
<li><code>foo#</code> searches for <code>foo</code> function in the current workspace</li>
<li><code>Foo*</code> searches for <code>Foo</code> type among dependencies, including <code>stdlib</code></li>
<li><code>foo#*</code> searches for <code>foo</code> function among dependencies</li>
</ul>
<p>That is, <code>#</code> switches from &quot;types&quot; to all symbols, <code>*</code> switches from the current
workspace to dependencies.</p>
<p>Note that filtering does not currently work in VSCode due to the editor never
sending the special symbols to the language server. Instead, you can configure
the filtering via the <code>rust-analyzer.workspace.symbol.search.scope</code> and
<code>rust-analyzer.workspace.symbol.search.kind</code> settings.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+T</kbd></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="assists"><a class="header" href="#assists">Assists</a></h1>
<p>Assists, or code actions, are small local refactorings, available in a
particular context. They are usually triggered by a shortcut or by
clicking a light bulb icon in the editor. Cursor position or selection
is signified by <code>‚îÉ</code> character.</p>
<h3 id="add_braces"><a class="header" href="#add_braces"><code>add_braces</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_braces.rs#8">add_braces.rs</a> </p>
<p>Adds braces to lambda and match arm expressions.</p>
<h4 id="before"><a class="header" href="#before">Before</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    match n {
        1 =&gt;‚îÉ n + 1,
        _ =&gt; 0
    }
}</code></pre>
<h4 id="after"><a class="header" href="#after">After</a></h4>
<pre><code class="language-rust">fn foo(n: i32) -&gt; i32 {
    match n {
        1 =&gt; {
            n + 1
        },
        _ =&gt; 0
    }
}</code></pre>
<h3 id="add_explicit_type"><a class="header" href="#add_explicit_type"><code>add_explicit_type</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_explicit_type.rs#7">add_explicit_type.rs</a> </p>
<p>Specify type for a let binding.</p>
<h4 id="before-1"><a class="header" href="#before-1">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x‚îÉ = 92;
}</code></pre>
<h4 id="after-1"><a class="header" href="#after-1">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x: i32 = 92;
}</code></pre>
<h3 id="add_hash"><a class="header" href="#add_hash"><code>add_hash</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/raw_string.rs#89">raw_string.rs</a> </p>
<p>Adds a hash to a raw string literal.</p>
<h4 id="before-2"><a class="header" href="#before-2">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello,‚îÉ World!&quot;#;
}</code></pre>
<h4 id="after-2"><a class="header" href="#after-2">After</a></h4>
<pre><code class="language-rust">fn main() {
    r##&quot;Hello, World!&quot;##;
}</code></pre>
<h3 id="add_impl_default_members"><a class="header" href="#add_impl_default_members"><code>add_impl_default_members</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_missing_impl_members.rs#55">add_missing_impl_members.rs</a> </p>
<p>Adds scaffold for overriding default impl members.</p>
<h4 id="before-3"><a class="header" href="#before-3">Before</a></h4>
<pre><code class="language-rust">trait Trait {
    type X;
    fn foo(&amp;self);
    fn bar(&amp;self) {}
}

impl Trait for () {
    type X = ();
    fn foo(&amp;self) {}‚îÉ
}</code></pre>
<h4 id="after-3"><a class="header" href="#after-3">After</a></h4>
<pre><code class="language-rust">trait Trait {
    type X;
    fn foo(&amp;self);
    fn bar(&amp;self) {}
}

impl Trait for () {
    type X = ();
    fn foo(&amp;self) {}

    ‚îÉfn bar(&amp;self) {}
}</code></pre>
<h3 id="add_impl_missing_members"><a class="header" href="#add_impl_missing_members"><code>add_impl_missing_members</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_missing_impl_members.rs#13">add_missing_impl_members.rs</a> </p>
<p>Adds scaffold for required impl members.</p>
<h4 id="before-4"><a class="header" href="#before-4">Before</a></h4>
<pre><code class="language-rust">trait Trait&lt;T&gt; {
    type X;
    fn foo(&amp;self) -&gt; T;
    fn bar(&amp;self) {}
}

impl Trait&lt;u32&gt; for () {‚îÉ

}</code></pre>
<h4 id="after-4"><a class="header" href="#after-4">After</a></h4>
<pre><code class="language-rust">trait Trait&lt;T&gt; {
    type X;
    fn foo(&amp;self) -&gt; T;
    fn bar(&amp;self) {}
}

impl Trait&lt;u32&gt; for () {
    ‚îÉtype X;

    fn foo(&amp;self) -&gt; u32 {
        todo!()
    }
}</code></pre>
<h3 id="add_label_to_loop"><a class="header" href="#add_label_to_loop"><code>add_label_to_loop</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_label_to_loop.rs#9">add_label_to_loop.rs</a> </p>
<p>Adds a label to a loop.</p>
<h4 id="before-5"><a class="header" href="#before-5">Before</a></h4>
<pre><code class="language-rust">fn main() {
    loop‚îÉ {
        break;
        continue;
    }
}</code></pre>
<h4 id="after-5"><a class="header" href="#after-5">After</a></h4>
<pre><code class="language-rust">fn main() {
    'l: loop {
        break 'l;
        continue 'l;
    }
}</code></pre>
<h3 id="add_lifetime_to_type"><a class="header" href="#add_lifetime_to_type"><code>add_lifetime_to_type</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_lifetime_to_type.rs#5">add_lifetime_to_type.rs</a> </p>
<p>Adds a new lifetime to a struct, enum or union.</p>
<h4 id="before-6"><a class="header" href="#before-6">Before</a></h4>
<pre><code class="language-rust">struct Point {
    x: &amp;‚îÉu32,
    y: u32,
}</code></pre>
<h4 id="after-6"><a class="header" href="#after-6">After</a></h4>
<pre><code class="language-rust">struct Point&lt;'a&gt; {
    x: &amp;'a u32,
    y: u32,
}</code></pre>
<h3 id="add_missing_match_arms"><a class="header" href="#add_missing_match_arms"><code>add_missing_match_arms</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_missing_match_arms.rs#13">add_missing_match_arms.rs</a> </p>
<p>Adds missing clauses to a <code>match</code> expression.</p>
<h4 id="before-7"><a class="header" href="#before-7">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ‚îÉ
    }
}</code></pre>
<h4 id="after-7"><a class="header" href="#after-7">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ‚îÉAction::Move { distance } =&gt; todo!(),
        Action::Stop =&gt; todo!(),
    }
}</code></pre>
<h3 id="add_return_type"><a class="header" href="#add_return_type"><code>add_return_type</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_return_type.rs#6">add_return_type.rs</a> </p>
<p>Adds the return type to a function or closure inferred from its tail expression if it doesn't have a return
type specified. This assists is useable in a functions or closures tail expression or return type position.</p>
<h4 id="before-8"><a class="header" href="#before-8">Before</a></h4>
<pre><code class="language-rust">fn foo() { 4‚îÉ2i32 }</code></pre>
<h4 id="after-8"><a class="header" href="#after-8">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="add_turbo_fish"><a class="header" href="#add_turbo_fish"><code>add_turbo_fish</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/add_turbo_fish.rs#10">add_turbo_fish.rs</a> </p>
<p>Adds <code>::&lt;_&gt;</code> to a call of a generic method or function.</p>
<h4 id="before-9"><a class="header" href="#before-9">Before</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { todo!() }
fn main() {
    let x = make‚îÉ();
}</code></pre>
<h4 id="after-9"><a class="header" href="#after-9">After</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { todo!() }
fn main() {
    let x = make::&lt;${0:_}&gt;();
}</code></pre>
<h3 id="apply_demorgan"><a class="header" href="#apply_demorgan"><code>apply_demorgan</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/apply_demorgan.rs#17">apply_demorgan.rs</a> </p>
<p>Apply https://en.wikipedia.org/wiki/De_Morgan%27s_laws[De Morgan's law].
This transforms expressions of the form <code>!l || !r</code> into <code>!(l &amp;&amp; r)</code>.
This also works with <code>&amp;&amp;</code>. This assist can only be applied with the cursor
on either <code>||</code> or <code>&amp;&amp;</code>.</p>
<h4 id="before-10"><a class="header" href="#before-10">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if x != 4 ||‚îÉ y &lt; 3.14 {}
}</code></pre>
<h4 id="after-10"><a class="header" href="#after-10">After</a></h4>
<pre><code class="language-rust">fn main() {
    if !(x == 4 &amp;&amp; y &gt;= 3.14) {}
}</code></pre>
<h3 id="apply_demorgan_iterator"><a class="header" href="#apply_demorgan_iterator"><code>apply_demorgan_iterator</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/apply_demorgan.rs#153">apply_demorgan.rs</a> </p>
<p>Apply https://en.wikipedia.org/wiki/De_Morgan%27s_laws[De Morgan's law] to
<code>Iterator::all</code> and <code>Iterator::any</code>.</p>
<p>This transforms expressions of the form <code>!iter.any(|x| predicate(x))</code> into
<code>iter.all(|x| !predicate(x))</code> and vice versa. This also works the other way for
<code>Iterator::all</code> into <code>Iterator::any</code>.</p>
<h4 id="before-11"><a class="header" href="#before-11">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let arr = [1, 2, 3];
    if !arr.into_iter().‚îÉany(|num| num == 4) {
        println!(&quot;foo&quot;);
    }
}</code></pre>
<h4 id="after-11"><a class="header" href="#after-11">After</a></h4>
<pre><code class="language-rust">fn main() {
    let arr = [1, 2, 3];
    if arr.into_iter().all(|num| num != 4) {
        println!(&quot;foo&quot;);
    }
}</code></pre>
<h3 id="auto_import"><a class="header" href="#auto_import"><code>auto_import</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/auto_import.rs#71">auto_import.rs</a> </p>
<p>If the name is unresolved, provides all possible imports for it.</p>
<h4 id="before-12"><a class="header" href="#before-12">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let map = HashMap‚îÉ::new();
}</code></pre>
<h4 id="after-12"><a class="header" href="#after-12">After</a></h4>
<pre><code class="language-rust">use std::collections::HashMap;

fn main() {
    let map = HashMap::new();
}</code></pre>
<h3 id="bind_unused_param"><a class="header" href="#bind_unused_param"><code>bind_unused_param</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/bind_unused_param.rs#12">bind_unused_param.rs</a> </p>
<p>Binds unused function parameter to an underscore.</p>
<h4 id="before-13"><a class="header" href="#before-13">Before</a></h4>
<pre><code class="language-rust">fn some_function(x: i32‚îÉ) {}</code></pre>
<h4 id="after-13"><a class="header" href="#after-13">After</a></h4>
<pre><code class="language-rust">fn some_function(x: i32) {
    let _ = x;
}</code></pre>
<h3 id="bool_to_enum"><a class="header" href="#bool_to_enum"><code>bool_to_enum</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/bool_to_enum.rs#25">bool_to_enum.rs</a> </p>
<p>This converts boolean local variables, fields, constants, and statics into a new
enum with two variants <code>Bool::True</code> and <code>Bool::False</code>, as well as replacing
all assignments with the variants and replacing all usages with <code>== Bool::True</code> or
<code>== Bool::False</code>.</p>
<h4 id="before-14"><a class="header" href="#before-14">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let ‚îÉbool = true;

    if bool {
        println!(&quot;foo&quot;);
    }
}</code></pre>
<h4 id="after-14"><a class="header" href="#after-14">After</a></h4>
<pre><code class="language-rust">#[derive(PartialEq, Eq)]
enum Bool { True, False }

fn main() {
    let bool = Bool::True;

    if bool == Bool::True {
        println!(&quot;foo&quot;);
    }
}</code></pre>
<h3 id="change_visibility"><a class="header" href="#change_visibility"><code>change_visibility</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/change_visibility.rs#13">change_visibility.rs</a> </p>
<p>Adds or changes existing visibility specifier.</p>
<h4 id="before-15"><a class="header" href="#before-15">Before</a></h4>
<pre><code class="language-rust">‚îÉfn frobnicate() {}</code></pre>
<h4 id="after-15"><a class="header" href="#after-15">After</a></h4>
<pre><code class="language-rust">pub(crate) fn frobnicate() {}</code></pre>
<h3 id="convert_bool_then_to_if"><a class="header" href="#convert_bool_then_to_if"><code>convert_bool_then_to_if</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_bool_then.rs#131">convert_bool_then.rs</a> </p>
<p>Converts a <code>bool::then</code> method call to an equivalent if expression.</p>
<h4 id="before-16"><a class="header" href="#before-16">Before</a></h4>
<pre><code class="language-rust">fn main() {
    (0 == 0).then‚îÉ(|| val)
}</code></pre>
<h4 id="after-16"><a class="header" href="#after-16">After</a></h4>
<pre><code class="language-rust">fn main() {
    if 0 == 0 {
        Some(val)
    } else {
        None
    }
}</code></pre>
<h3 id="convert_for_loop_with_for_each"><a class="header" href="#convert_for_loop_with_for_each"><code>convert_for_loop_with_for_each</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs#76">convert_iter_for_each_to_for.rs</a> </p>
<p>Converts a for loop into a for_each loop on the Iterator.</p>
<h4 id="before-17"><a class="header" href="#before-17">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    for‚îÉ v in x {
        let y = v * 2;
    }
}</code></pre>
<h4 id="after-17"><a class="header" href="#after-17">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = vec![1, 2, 3];
    x.into_iter().for_each(|v| {
        let y = v * 2;
    });
}</code></pre>
<h3 id="convert_if_to_bool_then"><a class="header" href="#convert_if_to_bool_then"><code>convert_if_to_bool_then</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_bool_then.rs#20">convert_bool_then.rs</a> </p>
<p>Converts an if expression into a corresponding <code>bool::then</code> call.</p>
<h4 id="before-18"><a class="header" href="#before-18">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if‚îÉ cond {
        Some(val)
    } else {
        None
    }
}</code></pre>
<h4 id="after-18"><a class="header" href="#after-18">After</a></h4>
<pre><code class="language-rust">fn main() {
    cond.then(|| val)
}</code></pre>
<h3 id="convert_integer_literal"><a class="header" href="#convert_integer_literal"><code>convert_integer_literal</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_integer_literal.rs#5">convert_integer_literal.rs</a> </p>
<p>Converts the base of integer literals to other bases.</p>
<h4 id="before-19"><a class="header" href="#before-19">Before</a></h4>
<pre><code class="language-rust">const _: i32 = 10‚îÉ;</code></pre>
<h4 id="after-19"><a class="header" href="#after-19">After</a></h4>
<pre><code class="language-rust">const _: i32 = 0b1010;</code></pre>
<h3 id="convert_into_to_from"><a class="header" href="#convert_into_to_from"><code>convert_into_to_from</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_into_to_from.rs#8">convert_into_to_from.rs</a> </p>
<p>Converts an Into impl to an equivalent From impl.</p>
<h4 id="before-20"><a class="header" href="#before-20">Before</a></h4>
<pre><code class="language-rust">impl ‚îÉInto&lt;Thing&gt; for usize {
    fn into(self) -&gt; Thing {
        Thing {
            b: self.to_string(),
            a: self
        }
    }
}</code></pre>
<h4 id="after-20"><a class="header" href="#after-20">After</a></h4>
<pre><code class="language-rust">impl From&lt;usize&gt; for Thing {
    fn from(val: usize) -&gt; Self {
        Thing {
            b: val.to_string(),
            a: val
        }
    }
}</code></pre>
<h3 id="convert_iter_for_each_to_for"><a class="header" href="#convert_iter_for_each_to_for"><code>convert_iter_for_each_to_for</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs#11">convert_iter_for_each_to_for.rs</a> </p>
<p>Converts an Iterator::for_each function into a for loop.</p>
<h4 id="before-21"><a class="header" href="#before-21">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let iter = iter::repeat((9, 2));
    iter.for_each‚îÉ(|(x, y)| {
        println!(&quot;x: {}, y: {}&quot;, x, y);
    });
}</code></pre>
<h4 id="after-21"><a class="header" href="#after-21">After</a></h4>
<pre><code class="language-rust">fn main() {
    let iter = iter::repeat((9, 2));
    for (x, y) in iter {
        println!(&quot;x: {}, y: {}&quot;, x, y);
    }
}</code></pre>
<h3 id="convert_let_else_to_match"><a class="header" href="#convert_let_else_to_match"><code>convert_let_else_to_match</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_let_else_to_match.rs#8">convert_let_else_to_match.rs</a> </p>
<p>Converts let-else statement to let statement and match expression.</p>
<h4 id="before-22"><a class="header" href="#before-22">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let Ok(mut x) = f() else‚îÉ { return };
}</code></pre>
<h4 id="after-22"><a class="header" href="#after-22">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut x = match f() {
        Ok(x) =&gt; x,
        _ =&gt; return,
    };
}</code></pre>
<h3 id="convert_match_to_let_else"><a class="header" href="#convert_match_to_let_else"><code>convert_match_to_let_else</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_match_to_let_else.rs#12">convert_match_to_let_else.rs</a> </p>
<p>Converts let statement with match initializer to let-else statement.</p>
<h4 id="before-23"><a class="header" href="#before-23">Before</a></h4>
<pre><code class="language-rust">fn foo(opt: Option&lt;()&gt;) {
    let val‚îÉ = match opt {
        Some(it) =&gt; it,
        None =&gt; return,
    };
}</code></pre>
<h4 id="after-23"><a class="header" href="#after-23">After</a></h4>
<pre><code class="language-rust">fn foo(opt: Option&lt;()&gt;) {
    let Some(val) = opt else { return };
}</code></pre>
<h3 id="convert_named_struct_to_tuple_struct"><a class="header" href="#convert_named_struct_to_tuple_struct"><code>convert_named_struct_to_tuple_struct</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_named_struct_to_tuple_struct.rs#11">convert_named_struct_to_tuple_struct.rs</a> </p>
<p>Converts struct with named fields to tuple struct, and analogously for enum variants with named
fields.</p>
<h4 id="before-24"><a class="header" href="#before-24">Before</a></h4>
<pre><code class="language-rust">struct Point‚îÉ { x: f32, y: f32 }

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point { x, y }
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.x
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.y
    }
}</code></pre>
<h4 id="after-24"><a class="header" href="#after-24">After</a></h4>
<pre><code class="language-rust">struct Point(f32, f32);

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point(x, y)
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.0
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.1
    }
}</code></pre>
<h3 id="convert_nested_function_to_closure"><a class="header" href="#convert_nested_function_to_closure"><code>convert_nested_function_to_closure</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_nested_function_to_closure.rs#7">convert_nested_function_to_closure.rs</a> </p>
<p>Converts a function that is defined within the body of another function into a closure.</p>
<h4 id="before-25"><a class="header" href="#before-25">Before</a></h4>
<pre><code class="language-rust">fn main() {
    fn fo‚îÉo(label: &amp;str, number: u64) {
        println!(&quot;{}: {}&quot;, label, number);
    }

    foo(&quot;Bar&quot;, 100);
}</code></pre>
<h4 id="after-25"><a class="header" href="#after-25">After</a></h4>
<pre><code class="language-rust">fn main() {
    let foo = |label: &amp;str, number: u64| {
        println!(&quot;{}: {}&quot;, label, number);
    };

    foo(&quot;Bar&quot;, 100);
}</code></pre>
<h3 id="convert_to_guarded_return"><a class="header" href="#convert_to_guarded_return"><code>convert_to_guarded_return</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_to_guarded_return.rs#21">convert_to_guarded_return.rs</a> </p>
<p>Replace a large conditional with a guarded return.</p>
<h4 id="before-26"><a class="header" href="#before-26">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ‚îÉif cond {
        foo();
        bar();
    }
}</code></pre>
<h4 id="after-26"><a class="header" href="#after-26">After</a></h4>
<pre><code class="language-rust">fn main() {
    if !cond {
        return;
    }
    foo();
    bar();
}</code></pre>
<h3 id="convert_tuple_return_type_to_struct"><a class="header" href="#convert_tuple_return_type_to_struct"><code>convert_tuple_return_type_to_struct</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_tuple_return_type_to_struct.rs#20">convert_tuple_return_type_to_struct.rs</a> </p>
<p>This converts the return type of a function from a tuple type
into a tuple struct and updates the body accordingly.</p>
<h4 id="before-27"><a class="header" href="#before-27">Before</a></h4>
<pre><code class="language-rust">fn bar() {
    let (a, b, c) = foo();
}

fn foo() -&gt; (‚îÉu32, u32, u32) {
    (1, 2, 3)
}</code></pre>
<h4 id="after-27"><a class="header" href="#after-27">After</a></h4>
<pre><code class="language-rust">fn bar() {
    let FooResult(a, b, c) = foo();
}

struct FooResult(u32, u32, u32);

fn foo() -&gt; FooResult {
    FooResult(1, 2, 3)
}</code></pre>
<h3 id="convert_tuple_struct_to_named_struct"><a class="header" href="#convert_tuple_struct_to_named_struct"><code>convert_tuple_struct_to_named_struct</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_tuple_struct_to_named_struct.rs#10">convert_tuple_struct_to_named_struct.rs</a> </p>
<p>Converts tuple struct to struct with named fields, and analogously for tuple enum variants.</p>
<h4 id="before-28"><a class="header" href="#before-28">Before</a></h4>
<pre><code class="language-rust">struct Point‚îÉ(f32, f32);

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point(x, y)
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.0
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.1
    }
}</code></pre>
<h4 id="after-28"><a class="header" href="#after-28">After</a></h4>
<pre><code class="language-rust">struct Point { field1: f32, field2: f32 }

impl Point {
    pub fn new(x: f32, y: f32) -&gt; Self {
        Point { field1: x, field2: y }
    }

    pub fn x(&amp;self) -&gt; f32 {
        self.field1
    }

    pub fn y(&amp;self) -&gt; f32 {
        self.field2
    }
}</code></pre>
<h3 id="convert_two_arm_bool_match_to_matches_macro"><a class="header" href="#convert_two_arm_bool_match_to_matches_macro"><code>convert_two_arm_bool_match_to_matches_macro</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_two_arm_bool_match_to_matches_macro.rs#8">convert_two_arm_bool_match_to_matches_macro.rs</a> </p>
<p>Convert 2-arm match that evaluates to a boolean into the equivalent matches! invocation.</p>
<h4 id="before-29"><a class="header" href="#before-29">Before</a></h4>
<pre><code class="language-rust">fn main() {
    match scrutinee‚îÉ {
        Some(val) if val.cond() =&gt; true,
        _ =&gt; false,
    }
}</code></pre>
<h4 id="after-29"><a class="header" href="#after-29">After</a></h4>
<pre><code class="language-rust">fn main() {
    matches!(scrutinee, Some(val) if val.cond())
}</code></pre>
<h3 id="convert_while_to_loop"><a class="header" href="#convert_while_to_loop"><code>convert_while_to_loop</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_while_to_loop.rs#19">convert_while_to_loop.rs</a> </p>
<p>Replace a while with a loop.</p>
<h4 id="before-30"><a class="header" href="#before-30">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ‚îÉwhile cond {
        foo();
    }
}</code></pre>
<h4 id="after-30"><a class="header" href="#after-30">After</a></h4>
<pre><code class="language-rust">fn main() {
    loop {
        if !cond {
            break;
        }
        foo();
    }
}</code></pre>
<h3 id="destructure_tuple_binding"><a class="header" href="#destructure_tuple_binding"><code>destructure_tuple_binding</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/destructure_tuple_binding.rs#13">destructure_tuple_binding.rs</a> </p>
<p>Destructures a tuple binding in place.</p>
<h4 id="before-31"><a class="header" href="#before-31">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let ‚îÉt = (1,2);
    let v = t.0;
}</code></pre>
<h4 id="after-31"><a class="header" href="#after-31">After</a></h4>
<pre><code class="language-rust">fn main() {
    let (‚îÉ_0, _1) = (1,2);
    let v = _0;
}</code></pre>
<h3 id="desugar_doc_comment"><a class="header" href="#desugar_doc_comment"><code>desugar_doc_comment</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/desugar_doc_comment.rs#14">desugar_doc_comment.rs</a> </p>
<p>Desugars doc-comments to the attribute form.</p>
<h4 id="before-32"><a class="header" href="#before-32">Before</a></h4>
<pre><code class="language-rust">/// Multi-line‚îÉ
/// comment</code></pre>
<h4 id="after-32"><a class="header" href="#after-32">After</a></h4>
<pre><code class="language-rust">#[doc = r&quot;Multi-line
comment&quot;]</code></pre>
<h3 id="expand_glob_import"><a class="header" href="#expand_glob_import"><code>expand_glob_import</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/expand_glob_import.rs#18">expand_glob_import.rs</a> </p>
<p>Expands glob imports.</p>
<h4 id="before-33"><a class="header" href="#before-33">Before</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

use foo::*‚îÉ;

fn qux(bar: Bar, baz: Baz) {}</code></pre>
<h4 id="after-33"><a class="header" href="#after-33">After</a></h4>
<pre><code class="language-rust">mod foo {
    pub struct Bar;
    pub struct Baz;
}

use foo::{Bar, Baz};

fn qux(bar: Bar, baz: Baz) {}</code></pre>
<h3 id="extract_expressions_from_format_string"><a class="header" href="#extract_expressions_from_format_string"><code>extract_expressions_from_format_string</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/extract_expressions_from_format_string.rs#13">extract_expressions_from_format_string.rs</a> </p>
<p>Move an expression out of a format string.</p>
<h4 id="before-34"><a class="header" href="#before-34">Before</a></h4>
<pre><code class="language-rust">fn main() {
    print!(&quot;{var} {x + 1}‚îÉ&quot;);
}</code></pre>
<h4 id="after-34"><a class="header" href="#after-34">After</a></h4>
<pre><code class="language-rust">fn main() {
    print!(&quot;{var} {}&quot;‚îÉ, x + 1);
}</code></pre>
<h3 id="extract_function"><a class="header" href="#extract_function"><code>extract_function</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/extract_function.rs#39">extract_function.rs</a> </p>
<p>Extracts selected statements and comments into new function.</p>
<h4 id="before-35"><a class="header" href="#before-35">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let n = 1;
    ‚îÉlet m = n + 2;
    // calculate
    let k = m + n;‚îÉ
    let g = 3;
}</code></pre>
<h4 id="after-35"><a class="header" href="#after-35">After</a></h4>
<pre><code class="language-rust">fn main() {
    let n = 1;
    fun_name(n);
    let g = 3;
}

fn ‚îÉfun_name(n: i32) {
    let m = n + 2;
    // calculate
    let k = m + n;
}</code></pre>
<h3 id="extract_module"><a class="header" href="#extract_module"><code>extract_module</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/extract_module.rs#32">extract_module.rs</a> </p>
<p>Extracts a selected region as separate module. All the references, visibility and imports are
resolved.</p>
<h4 id="before-36"><a class="header" href="#before-36">Before</a></h4>
<pre><code class="language-rust">‚îÉfn foo(name: i32) -&gt; i32 {
    name + 1
}‚îÉ

fn bar(name: i32) -&gt; i32 {
    name + 2
}</code></pre>
<h4 id="after-36"><a class="header" href="#after-36">After</a></h4>
<pre><code class="language-rust">mod modname {
    pub(crate) fn foo(name: i32) -&gt; i32 {
        name + 1
    }
}

fn bar(name: i32) -&gt; i32 {
    name + 2
}</code></pre>
<h3 id="extract_struct_from_enum_variant"><a class="header" href="#extract_struct_from_enum_variant"><code>extract_struct_from_enum_variant</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs#25">extract_struct_from_enum_variant.rs</a> </p>
<p>Extracts a struct from enum variant.</p>
<h4 id="before-37"><a class="header" href="#before-37">Before</a></h4>
<pre><code class="language-rust">enum A { ‚îÉOne(u32, u32) }</code></pre>
<h4 id="after-37"><a class="header" href="#after-37">After</a></h4>
<pre><code class="language-rust">struct One(u32, u32);

enum A { One(One) }</code></pre>
<h3 id="extract_type_alias"><a class="header" href="#extract_type_alias"><code>extract_type_alias</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/extract_type_alias.rs#10">extract_type_alias.rs</a> </p>
<p>Extracts the selected type as a type alias.</p>
<h4 id="before-38"><a class="header" href="#before-38">Before</a></h4>
<pre><code class="language-rust">struct S {
    field: ‚îÉ(u8, u8, u8)‚îÉ,
}</code></pre>
<h4 id="after-38"><a class="header" href="#after-38">After</a></h4>
<pre><code class="language-rust">type ‚îÉType = (u8, u8, u8);

struct S {
    field: Type,
}</code></pre>
<h3 id="extract_variable"><a class="header" href="#extract_variable"><code>extract_variable</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/extract_variable.rs#15">extract_variable.rs</a> </p>
<p>Extracts subexpression into a variable.</p>
<h4 id="before-39"><a class="header" href="#before-39">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ‚îÉ(1 + 2)‚îÉ * 4;
}</code></pre>
<h4 id="after-39"><a class="header" href="#after-39">After</a></h4>
<pre><code class="language-rust">fn main() {
    let ‚îÉvar_name = (1 + 2);
    var_name * 4;
}</code></pre>
<h3 id="fix_visibility"><a class="header" href="#fix_visibility"><code>fix_visibility</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/fix_visibility.rs#12">fix_visibility.rs</a> </p>
<p>Makes inaccessible item public.</p>
<h4 id="before-40"><a class="header" href="#before-40">Before</a></h4>
<pre><code class="language-rust">mod m {
    fn frobnicate() {}
}
fn main() {
    m::frobnicate‚îÉ();
}</code></pre>
<h4 id="after-40"><a class="header" href="#after-40">After</a></h4>
<pre><code class="language-rust">mod m {
    ‚îÉpub(crate) fn frobnicate() {}
}
fn main() {
    m::frobnicate();
}</code></pre>
<h3 id="flip_binexpr"><a class="header" href="#flip_binexpr"><code>flip_binexpr</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/flip_binexpr.rs#5">flip_binexpr.rs</a> </p>
<p>Flips operands of a binary expression.</p>
<h4 id="before-41"><a class="header" href="#before-41">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 90 +‚îÉ 2;
}</code></pre>
<h4 id="after-41"><a class="header" href="#after-41">After</a></h4>
<pre><code class="language-rust">fn main() {
    let _ = 2 + 90;
}</code></pre>
<h3 id="flip_comma"><a class="header" href="#flip_comma"><code>flip_comma</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/flip_comma.rs#5">flip_comma.rs</a> </p>
<p>Flips two comma-separated items.</p>
<h4 id="before-42"><a class="header" href="#before-42">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ((1, 2),‚îÉ (3, 4));
}</code></pre>
<h4 id="after-42"><a class="header" href="#after-42">After</a></h4>
<pre><code class="language-rust">fn main() {
    ((3, 4), (1, 2));
}</code></pre>
<h3 id="flip_trait_bound"><a class="header" href="#flip_trait_bound"><code>flip_trait_bound</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/flip_trait_bound.rs#9">flip_trait_bound.rs</a> </p>
<p>Flips two trait bounds.</p>
<h4 id="before-43"><a class="header" href="#before-43">Before</a></h4>
<pre><code class="language-rust">fn foo&lt;T: Clone +‚îÉ Copy&gt;() { }</code></pre>
<h4 id="after-43"><a class="header" href="#after-43">After</a></h4>
<pre><code class="language-rust">fn foo&lt;T: Copy + Clone&gt;() { }</code></pre>
<h3 id="generate_constant"><a class="header" href="#generate_constant"><code>generate_constant</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_constant.rs#13">generate_constant.rs</a> </p>
<p>Generate a named constant.</p>
<h4 id="before-44"><a class="header" href="#before-44">Before</a></h4>
<pre><code class="language-rust">struct S { i: usize }
impl S { pub fn new(n: usize) {} }
fn main() {
    let v = S::new(CAPA‚îÉCITY);
}</code></pre>
<h4 id="after-44"><a class="header" href="#after-44">After</a></h4>
<pre><code class="language-rust">struct S { i: usize }
impl S { pub fn new(n: usize) {} }
fn main() {
    const CAPACITY: usize = ‚îÉ;
    let v = S::new(CAPACITY);
}</code></pre>
<h3 id="generate_default_from_enum_variant"><a class="header" href="#generate_default_from_enum_variant"><code>generate_default_from_enum_variant</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_default_from_enum_variant.rs#6">generate_default_from_enum_variant.rs</a> </p>
<p>Adds a Default impl for an enum using a variant.</p>
<h4 id="before-45"><a class="header" href="#before-45">Before</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor‚îÉ,
 Major,
}</code></pre>
<h4 id="after-45"><a class="header" href="#after-45">After</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor,
 Major,
}

impl Default for Version {
    fn default() -&gt; Self {
        Self::Minor
    }
}</code></pre>
<h3 id="generate_default_from_new"><a class="header" href="#generate_default_from_new"><code>generate_default_from_new</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_default_from_new.rs#13">generate_default_from_new.rs</a> </p>
<p>Generates default implementation from new method.</p>
<h4 id="before-46"><a class="header" href="#before-46">Before</a></h4>
<pre><code class="language-rust">struct Example { _inner: () }

impl Example {
    pub fn n‚îÉew() -&gt; Self {
        Self { _inner: () }
    }
}</code></pre>
<h4 id="after-46"><a class="header" href="#after-46">After</a></h4>
<pre><code class="language-rust">struct Example { _inner: () }

impl Example {
    pub fn new() -&gt; Self {
        Self { _inner: () }
    }
}

impl Default for Example {
    fn default() -&gt; Self {
        Self::new()
    }
}</code></pre>
<h3 id="generate_delegate_methods"><a class="header" href="#generate_delegate_methods"><code>generate_delegate_methods</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_delegate_methods.rs#16">generate_delegate_methods.rs</a> </p>
<p>Generate delegate methods.</p>
<h4 id="before-47"><a class="header" href="#before-47">Before</a></h4>
<pre><code class="language-rust">struct Age(u8);
impl Age {
    fn age(&amp;self) -&gt; u8 {
        self.0
    }
}

struct Person {
    ag‚îÉe: Age,
}</code></pre>
<h4 id="after-47"><a class="header" href="#after-47">After</a></h4>
<pre><code class="language-rust">struct Age(u8);
impl Age {
    fn age(&amp;self) -&gt; u8 {
        self.0
    }
}

struct Person {
    age: Age,
}

impl Person {
    ‚îÉfn age(&amp;self) -&gt; u8 {
        self.age.age()
    }
}</code></pre>
<h3 id="generate_delegate_trait"><a class="header" href="#generate_delegate_trait"><code>generate_delegate_trait</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_delegate_trait.rs#23">generate_delegate_trait.rs</a> </p>
<p>Generate delegate trait implementation for <code>StructField</code>s.</p>
<h4 id="before-48"><a class="header" href="#before-48">Before</a></h4>
<pre><code class="language-rust">trait SomeTrait {
    type T;
    fn fn_(arg: u32) -&gt; u32;
    fn method_(&amp;mut self) -&gt; bool;
}
struct A;
impl SomeTrait for A {
    type T = u32;

    fn fn_(arg: u32) -&gt; u32 {
        42
    }

    fn method_(&amp;mut self) -&gt; bool {
        false
    }
}
struct B {
    a‚îÉ: A,
}</code></pre>
<h4 id="after-48"><a class="header" href="#after-48">After</a></h4>
<pre><code class="language-rust">trait SomeTrait {
    type T;
    fn fn_(arg: u32) -&gt; u32;
    fn method_(&amp;mut self) -&gt; bool;
}
struct A;
impl SomeTrait for A {
    type T = u32;

    fn fn_(arg: u32) -&gt; u32 {
        42
    }

    fn method_(&amp;mut self) -&gt; bool {
        false
    }
}
struct B {
    a: A,
}

impl SomeTrait for B {
    type T = &lt;A as SomeTrait&gt;::T;

    fn fn_(arg: u32) -&gt; u32 {
        &lt;A as SomeTrait&gt;::fn_(arg)
    }

    fn method_(&amp;mut self) -&gt; bool {
        &lt;A as SomeTrait&gt;::method_( &amp;mut self.a )
    }
}</code></pre>
<h3 id="generate_deref"><a class="header" href="#generate_deref"><code>generate_deref</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_deref.rs#16">generate_deref.rs</a> </p>
<p>Generate <code>Deref</code> impl using the given struct field.</p>
<h4 id="before-49"><a class="header" href="#before-49">Before</a></h4>
<pre><code class="language-rust">struct A;
struct B {
   ‚îÉa: A
}</code></pre>
<h4 id="after-49"><a class="header" href="#after-49">After</a></h4>
<pre><code class="language-rust">struct A;
struct B {
   a: A
}

impl core::ops::Deref for B {
    type Target = A;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.a
    }
}</code></pre>
<h3 id="generate_derive"><a class="header" href="#generate_derive"><code>generate_derive</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_derive.rs#8">generate_derive.rs</a> </p>
<p>Adds a new <code>#[derive()]</code> clause to a struct or enum.</p>
<h4 id="before-50"><a class="header" href="#before-50">Before</a></h4>
<pre><code class="language-rust">struct Point {
    x: u32,
    y: u32,‚îÉ
}</code></pre>
<h4 id="after-50"><a class="header" href="#after-50">After</a></h4>
<pre><code class="language-rust">#[derive(‚îÉ)]
struct Point {
    x: u32,
    y: u32,
}</code></pre>
<h3 id="generate_doc_example"><a class="header" href="#generate_doc_example"><code>generate_doc_example</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_documentation_template.rs#76">generate_documentation_template.rs</a> </p>
<p>Generates a rustdoc example when editing an item's documentation.</p>
<h4 id="before-51"><a class="header" href="#before-51">Before</a></h4>
<pre><code class="language-rust">/// Adds two numbers.‚îÉ
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
<h4 id="after-51"><a class="header" href="#after-51">After</a></h4>
<pre><code class="language-rust">/// Adds two numbers.
///
/// # Examples
///
/// ```
/// use test::add;
///
/// assert_eq!(add(a, b), );
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 { a + b }</code></pre>
<h3 id="generate_documentation_template"><a class="header" href="#generate_documentation_template"><code>generate_documentation_template</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_documentation_template.rs#13">generate_documentation_template.rs</a> </p>
<p>Adds a documentation template above a function definition / declaration.</p>
<h4 id="before-52"><a class="header" href="#before-52">Before</a></h4>
<pre><code class="language-rust">pub struct S;
impl S {
    pub unsafe fn set_len‚îÉ(&amp;mut self, len: usize) -&gt; Result&lt;(), std::io::Error&gt; {
        /* ... */
    }
}</code></pre>
<h4 id="after-52"><a class="header" href="#after-52">After</a></h4>
<pre><code class="language-rust">pub struct S;
impl S {
    /// Sets the length of this [`S`].
    ///
    /// # Errors
    ///
    /// This function will return an error if .
    ///
    /// # Safety
    ///
    /// .
    pub unsafe fn set_len(&amp;mut self, len: usize) -&gt; Result&lt;(), std::io::Error&gt; {
        /* ... */
    }
}</code></pre>
<h3 id="generate_enum_as_method"><a class="header" href="#generate_enum_as_method"><code>generate_enum_as_method</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_enum_projection_method.rs#59">generate_enum_projection_method.rs</a> </p>
<p>Generate an <code>as_</code> method for this enum variant.</p>
<h4 id="before-53"><a class="header" href="#before-53">Before</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String)‚îÉ,
}</code></pre>
<h4 id="after-53"><a class="header" href="#after-53">After</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String),
}

impl Value {
    fn as_text(&amp;self) -&gt; Option&lt;&amp;String&gt; {
        if let Self::Text(v) = self {
            Some(v)
        } else {
            None
        }
    }
}</code></pre>
<h3 id="generate_enum_is_method"><a class="header" href="#generate_enum_is_method"><code>generate_enum_is_method</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_enum_is_method.rs#11">generate_enum_is_method.rs</a> </p>
<p>Generate an <code>is_</code> method for this enum variant.</p>
<h4 id="before-54"><a class="header" href="#before-54">Before</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor‚îÉ,
 Major,
}</code></pre>
<h4 id="after-54"><a class="header" href="#after-54">After</a></h4>
<pre><code class="language-rust">enum Version {
 Undefined,
 Minor,
 Major,
}

impl Version {
    /// Returns `true` if the version is [`Minor`].
    ///
    /// [`Minor`]: Version::Minor
    #[must_use]
    fn is_minor(&amp;self) -&gt; bool {
        matches!(self, Self::Minor)
    }
}</code></pre>
<h3 id="generate_enum_try_into_method"><a class="header" href="#generate_enum_try_into_method"><code>generate_enum_try_into_method</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_enum_projection_method.rs#12">generate_enum_projection_method.rs</a> </p>
<p>Generate a <code>try_into_</code> method for this enum variant.</p>
<h4 id="before-55"><a class="header" href="#before-55">Before</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String)‚îÉ,
}</code></pre>
<h4 id="after-55"><a class="header" href="#after-55">After</a></h4>
<pre><code class="language-rust">enum Value {
 Number(i32),
 Text(String),
}

impl Value {
    fn try_into_text(self) -&gt; Result&lt;String, Self&gt; {
        if let Self::Text(v) = self {
            Ok(v)
        } else {
            Err(self)
        }
    }
}</code></pre>
<h3 id="generate_enum_variant"><a class="header" href="#generate_enum_variant"><code>generate_enum_variant</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_enum_variant.rs#10">generate_enum_variant.rs</a> </p>
<p>Adds a variant to an enum.</p>
<h4 id="before-56"><a class="header" href="#before-56">Before</a></h4>
<pre><code class="language-rust">enum Countries {
    Ghana,
}

fn main() {
    let country = Countries::Lesotho‚îÉ;
}</code></pre>
<h4 id="after-56"><a class="header" href="#after-56">After</a></h4>
<pre><code class="language-rust">enum Countries {
    Ghana,
    Lesotho,
}

fn main() {
    let country = Countries::Lesotho;
}</code></pre>
<h3 id="generate_from_impl_for_enum"><a class="header" href="#generate_from_impl_for_enum"><code>generate_from_impl_for_enum</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_from_impl_for_enum.rs#8">generate_from_impl_for_enum.rs</a> </p>
<p>Adds a From impl for this enum variant with one tuple field.</p>
<h4 id="before-57"><a class="header" href="#before-57">Before</a></h4>
<pre><code class="language-rust">enum A { ‚îÉOne(u32) }</code></pre>
<h4 id="after-57"><a class="header" href="#after-57">After</a></h4>
<pre><code class="language-rust">enum A { One(u32) }

impl From&lt;u32&gt; for A {
    fn from(v: u32) -&gt; Self {
        Self::One(v)
    }
}</code></pre>
<h3 id="generate_function"><a class="header" href="#generate_function"><code>generate_function</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_function.rs#27">generate_function.rs</a> </p>
<p>Adds a stub function with a signature matching the function under the cursor.</p>
<h4 id="before-58"><a class="header" href="#before-58">Before</a></h4>
<pre><code class="language-rust">struct Baz;
fn baz() -&gt; Baz { Baz }
fn foo() {
    bar‚îÉ(&quot;&quot;, baz());
}
</code></pre>
<h4 id="after-58"><a class="header" href="#after-58">After</a></h4>
<pre><code class="language-rust">struct Baz;
fn baz() -&gt; Baz { Baz }
fn foo() {
    bar(&quot;&quot;, baz());
}

fn bar(arg: &amp;str, baz: Baz) ${0:-&gt; _} {
    todo!()
}
</code></pre>
<h3 id="generate_getter"><a class="header" href="#generate_getter"><code>generate_getter</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#73">generate_getter_or_setter.rs</a> </p>
<p>Generate a getter method.</p>
<h4 id="before-59"><a class="header" href="#before-59">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam‚îÉe: String,
}</code></pre>
<h4 id="after-59"><a class="header" href="#after-59">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ‚îÉname(&amp;self) -&gt; &amp;str {
        self.name.as_ref()
    }
}</code></pre>
<h3 id="generate_getter_mut"><a class="header" href="#generate_getter_mut"><code>generate_getter_mut</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#113">generate_getter_or_setter.rs</a> </p>
<p>Generate a mut getter method.</p>
<h4 id="before-60"><a class="header" href="#before-60">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam‚îÉe: String,
}</code></pre>
<h4 id="after-60"><a class="header" href="#after-60">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ‚îÉname_mut(&amp;mut self) -&gt; &amp;mut String {
        &amp;mut self.name
    }
}</code></pre>
<h3 id="generate_impl"><a class="header" href="#generate_impl"><code>generate_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_impl.rs#8">generate_impl.rs</a> </p>
<p>Adds a new inherent impl for a type.</p>
<h4 id="before-61"><a class="header" href="#before-61">Before</a></h4>
<pre><code class="language-rust">struct Ctx‚îÉ&lt;T: Clone&gt; {
    data: T,
}</code></pre>
<h4 id="after-61"><a class="header" href="#after-61">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
    data: T,
}

impl&lt;T: Clone&gt; Ctx&lt;T&gt; {
    ‚îÉ
}</code></pre>
<h3 id="generate_is_empty_from_len"><a class="header" href="#generate_is_empty_from_len"><code>generate_is_empty_from_len</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_is_empty_from_len.rs#12">generate_is_empty_from_len.rs</a> </p>
<p>Generates is_empty implementation from the len method.</p>
<h4 id="before-62"><a class="header" href="#before-62">Before</a></h4>
<pre><code class="language-rust">struct MyStruct { data: Vec&lt;String&gt; }

impl MyStruct {
    #[must_use]
    p‚îÉub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }
}</code></pre>
<h4 id="after-62"><a class="header" href="#after-62">After</a></h4>
<pre><code class="language-rust">struct MyStruct { data: Vec&lt;String&gt; }

impl MyStruct {
    #[must_use]
    pub fn len(&amp;self) -&gt; usize {
        self.data.len()
    }

    #[must_use]
    pub fn is_empty(&amp;self) -&gt; bool {
        self.len() == 0
    }
}</code></pre>
<h3 id="generate_mut_trait_impl"><a class="header" href="#generate_mut_trait_impl"><code>generate_mut_trait_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_mut_trait_impl.rs#12">generate_mut_trait_impl.rs</a> </p>
<p>Adds a IndexMut impl from the <code>Index</code> trait.</p>
<h4 id="before-63"><a class="header" href="#before-63">Before</a></h4>
<pre><code class="language-rust">pub enum Axis { X = 0, Y = 1, Z = 2 }

impl&lt;T&gt; core::ops::Index‚îÉ&lt;Axis&gt; for [T; 3] {
    type Output = T;

    fn index(&amp;self, index: Axis) -&gt; &amp;Self::Output {
        &amp;self[index as usize]
    }
}</code></pre>
<h4 id="after-63"><a class="header" href="#after-63">After</a></h4>
<pre><code class="language-rust">pub enum Axis { X = 0, Y = 1, Z = 2 }

‚îÉimpl&lt;T&gt; core::ops::IndexMut&lt;Axis&gt; for [T; 3] {
    fn index_mut(&amp;mut self, index: Axis) -&gt; &amp;mut Self::Output {
        &amp;self[index as usize]
    }
}

impl&lt;T&gt; core::ops::Index&lt;Axis&gt; for [T; 3] {
    type Output = T;

    fn index(&amp;self, index: Axis) -&gt; &amp;Self::Output {
        &amp;self[index as usize]
    }
}</code></pre>
<h3 id="generate_new"><a class="header" href="#generate_new"><code>generate_new</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_new.rs#13">generate_new.rs</a> </p>
<p>Adds a <code>fn new</code> for a type.</p>
<h4 id="before-64"><a class="header" href="#before-64">Before</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
     data: T,‚îÉ
}</code></pre>
<h4 id="after-64"><a class="header" href="#after-64">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
     data: T,
}

impl&lt;T: Clone&gt; Ctx&lt;T&gt; {
    fn ‚îÉnew(data: T) -&gt; Self { Self { data } }
}</code></pre>
<h3 id="generate_setter"><a class="header" href="#generate_setter"><code>generate_setter</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_getter_or_setter.rs#13">generate_getter_or_setter.rs</a> </p>
<p>Generate a setter method.</p>
<h4 id="before-65"><a class="header" href="#before-65">Before</a></h4>
<pre><code class="language-rust">struct Person {
    nam‚îÉe: String,
}</code></pre>
<h4 id="after-65"><a class="header" href="#after-65">After</a></h4>
<pre><code class="language-rust">struct Person {
    name: String,
}

impl Person {
    fn ‚îÉset_name(&amp;mut self, name: String) {
        self.name = name;
    }
}</code></pre>
<h3 id="generate_trait_from_impl"><a class="header" href="#generate_trait_from_impl"><code>generate_trait_from_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_trait_from_impl.rs#13">generate_trait_from_impl.rs</a> </p>
<p>Generate trait for an already defined inherent impl and convert impl to a trait impl.</p>
<h4 id="before-66"><a class="header" href="#before-66">Before</a></h4>
<pre><code class="language-rust">struct Foo&lt;const N: usize&gt;([i32; N]);

macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; {
        const CONST: $t = $v;
    };
}

impl&lt;const N: usize&gt; Fo‚îÉo&lt;N&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt; {
        Some(())
    }

    const_maker! {i32, 7}
}</code></pre>
<h4 id="after-66"><a class="header" href="#after-66">After</a></h4>
<pre><code class="language-rust">struct Foo&lt;const N: usize&gt;([i32; N]);

macro_rules! const_maker {
    ($t:ty, $v:tt) =&gt; {
        const CONST: $t = $v;
    };
}

trait ${0:TraitName}&lt;const N: usize&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt;;

    const_maker! {i32, 7}
}

impl&lt;const N: usize&gt; ${0:TraitName}&lt;N&gt; for Foo&lt;N&gt; {
    // Used as an associated constant.
    const CONST_ASSOC: usize = N * 4;

    fn create() -&gt; Option&lt;()&gt; {
        Some(())
    }

    const_maker! {i32, 7}
}</code></pre>
<h3 id="generate_trait_impl"><a class="header" href="#generate_trait_impl"><code>generate_trait_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/generate_impl.rs#56">generate_impl.rs</a> </p>
<p>Adds a new trait impl for a type.</p>
<h4 id="before-67"><a class="header" href="#before-67">Before</a></h4>
<pre><code class="language-rust">struct ‚îÉCtx&lt;T: Clone&gt; {
    data: T,
}</code></pre>
<h4 id="after-67"><a class="header" href="#after-67">After</a></h4>
<pre><code class="language-rust">struct Ctx&lt;T: Clone&gt; {
    data: T,
}

impl&lt;T: Clone&gt; ‚îÉ for Ctx&lt;T&gt; {

}</code></pre>
<h3 id="inline_call"><a class="header" href="#inline_call"><code>inline_call</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_call.rs#161">inline_call.rs</a> </p>
<p>Inlines a function or method body creating a <code>let</code> statement per parameter unless the parameter
can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
or if the parameter is only accessed inside the function body once.</p>
<h4 id="before-68"><a class="header" href="#before-68">Before</a></h4>
<pre><code class="language-rust">fn foo(name: Option&lt;&amp;str&gt;) {
    let name = name.unwrap‚îÉ();
}</code></pre>
<h4 id="after-68"><a class="header" href="#after-68">After</a></h4>
<pre><code class="language-rust">fn foo(name: Option&lt;&amp;str&gt;) {
    let name = match name {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        };
}</code></pre>
<h3 id="inline_const_as_literal"><a class="header" href="#inline_const_as_literal"><code>inline_const_as_literal</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_const_as_literal.rs#5">inline_const_as_literal.rs</a> </p>
<p>Evaluate and inline const variable as literal.</p>
<h4 id="before-69"><a class="header" href="#before-69">Before</a></h4>
<pre><code class="language-rust">const STRING: &amp;str = &quot;Hello, World!&quot;;

fn something() -&gt; &amp;'static str {
    STRING‚îÉ
}</code></pre>
<h4 id="after-69"><a class="header" href="#after-69">After</a></h4>
<pre><code class="language-rust">const STRING: &amp;str = &quot;Hello, World!&quot;;

fn something() -&gt; &amp;'static str {
    &quot;Hello, World!&quot;
}</code></pre>
<h3 id="inline_into_callers"><a class="header" href="#inline_into_callers"><code>inline_into_callers</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_call.rs#27">inline_call.rs</a> </p>
<p>Inline a function or method body into all of its callers where possible, creating a <code>let</code> statement per parameter
unless the parameter can be inlined. The parameter will be inlined either if it the supplied argument is a simple local
or if the parameter is only accessed inside the function body once.
If all calls can be inlined the function will be removed.</p>
<h4 id="before-70"><a class="header" href="#before-70">Before</a></h4>
<pre><code class="language-rust">fn print(_: &amp;str) {}
fn foo‚îÉ(word: &amp;str) {
    if !word.is_empty() {
        print(word);
    }
}
fn bar() {
    foo(&quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;);
    foo(&quot;Ïó¨Îü¨Î∂Ñ&quot;);
}</code></pre>
<h4 id="after-70"><a class="header" href="#after-70">After</a></h4>
<pre><code class="language-rust">fn print(_: &amp;str) {}

fn bar() {
    {
        let word = &quot;ÏïàÎÖïÌïòÏÑ∏Ïöî&quot;;
        if !word.is_empty() {
            print(word);
        }
    };
    {
        let word = &quot;Ïó¨Îü¨Î∂Ñ&quot;;
        if !word.is_empty() {
            print(word);
        }
    };
}</code></pre>
<h3 id="inline_local_variable"><a class="header" href="#inline_local_variable"><code>inline_local_variable</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_local_variable.rs#18">inline_local_variable.rs</a> </p>
<p>Inlines a local variable.</p>
<h4 id="before-71"><a class="header" href="#before-71">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x‚îÉ = 1 + 2;
    x * 4;
}</code></pre>
<h4 id="after-71"><a class="header" href="#after-71">After</a></h4>
<pre><code class="language-rust">fn main() {
    (1 + 2) * 4;
}</code></pre>
<h3 id="inline_macro"><a class="header" href="#inline_macro"><code>inline_macro</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_macro.rs#6">inline_macro.rs</a> </p>
<p>Takes a macro and inlines it one step.</p>
<h4 id="before-72"><a class="header" href="#before-72">Before</a></h4>
<pre><code class="language-rust">macro_rules! num {
    (+$($t:tt)+) =&gt; (1 + num!($($t )+));
    (-$($t:tt)+) =&gt; (-1 + num!($($t )+));
    (+) =&gt; (1);
    (-) =&gt; (-1);
}

fn main() {
    let number = num‚îÉ!(+ + + - + +);
    println!(&quot;{number}&quot;);
}</code></pre>
<h4 id="after-72"><a class="header" href="#after-72">After</a></h4>
<pre><code class="language-rust">macro_rules! num {
    (+$($t:tt)+) =&gt; (1 + num!($($t )+));
    (-$($t:tt)+) =&gt; (-1 + num!($($t )+));
    (+) =&gt; (1);
    (-) =&gt; (-1);
}

fn main() {
    let number = 1+num!(+ + - + +);
    println!(&quot;{number}&quot;);
}</code></pre>
<h3 id="inline_type_alias"><a class="header" href="#inline_type_alias"><code>inline_type_alias</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_type_alias.rs#105">inline_type_alias.rs</a> </p>
<p>Replace a type alias with its concrete type.</p>
<h4 id="before-73"><a class="header" href="#before-73">Before</a></h4>
<pre><code class="language-rust">type A&lt;T = u32&gt; = Vec&lt;T&gt;;

fn main() {
    let a: ‚îÉA;
}</code></pre>
<h4 id="after-73"><a class="header" href="#after-73">After</a></h4>
<pre><code class="language-rust">type A&lt;T = u32&gt; = Vec&lt;T&gt;;

fn main() {
    let a: Vec&lt;u32&gt;;
}</code></pre>
<h3 id="inline_type_alias_uses"><a class="header" href="#inline_type_alias_uses"><code>inline_type_alias_uses</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/inline_type_alias.rs#24">inline_type_alias.rs</a> </p>
<p>Inline a type alias into all of its uses where possible.</p>
<h4 id="before-74"><a class="header" href="#before-74">Before</a></h4>
<pre><code class="language-rust">type ‚îÉA = i32;
fn id(x: A) -&gt; A {
    x
};
fn foo() {
    let _: A = 3;
}</code></pre>
<h4 id="after-74"><a class="header" href="#after-74">After</a></h4>
<pre><code class="language-rust">
fn id(x: i32) -&gt; i32 {
    x
};
fn foo() {
    let _: i32 = 3;
}</code></pre>
<h3 id="into_to_qualified_from"><a class="header" href="#into_to_qualified_from"><code>into_to_qualified_from</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/into_to_qualified_from.rs#10">into_to_qualified_from.rs</a> </p>
<p>Convert an <code>into</code> method call to a fully qualified <code>from</code> call.</p>
<h4 id="before-75"><a class="header" href="#before-75">Before</a></h4>
<pre><code class="language-rust">//- minicore: from
struct B;
impl From&lt;i32&gt; for B {
    fn from(a: i32) -&gt; Self {
       B
    }
}

fn main() -&gt; () {
    let a = 3;
    let b: B = a.in‚îÉto();
}</code></pre>
<h4 id="after-75"><a class="header" href="#after-75">After</a></h4>
<pre><code class="language-rust">struct B;
impl From&lt;i32&gt; for B {
    fn from(a: i32) -&gt; Self {
       B
    }
}

fn main() -&gt; () {
    let a = 3;
    let b: B = B::from(a);
}</code></pre>
<h3 id="introduce_named_generic"><a class="header" href="#introduce_named_generic"><code>introduce_named_generic</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/introduce_named_generic.rs#8">introduce_named_generic.rs</a> </p>
<p>Replaces <code>impl Trait</code> function argument with the named generic.</p>
<h4 id="before-76"><a class="header" href="#before-76">Before</a></h4>
<pre><code class="language-rust">fn foo(bar: ‚îÉimpl Bar) {}</code></pre>
<h4 id="after-76"><a class="header" href="#after-76">After</a></h4>
<pre><code class="language-rust">fn foo&lt;‚îÉB: Bar&gt;(bar: B) {}</code></pre>
<h3 id="introduce_named_lifetime"><a class="header" href="#introduce_named_lifetime"><code>introduce_named_lifetime</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/introduce_named_lifetime.rs#13">introduce_named_lifetime.rs</a> </p>
<p>Change an anonymous lifetime to a named lifetime.</p>
<h4 id="before-77"><a class="header" href="#before-77">Before</a></h4>
<pre><code class="language-rust">impl Cursor&lt;'_‚îÉ&gt; {
    fn node(self) -&gt; &amp;SyntaxNode {
        match self {
            Cursor::Replace(node) | Cursor::Before(node) =&gt; node,
        }
    }
}</code></pre>
<h4 id="after-77"><a class="header" href="#after-77">After</a></h4>
<pre><code class="language-rust">impl&lt;'a&gt; Cursor&lt;'a&gt; {
    fn node(self) -&gt; &amp;SyntaxNode {
        match self {
            Cursor::Replace(node) | Cursor::Before(node) =&gt; node,
        }
    }
}</code></pre>
<h3 id="invert_if"><a class="header" href="#invert_if"><code>invert_if</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/invert_if.rs#13">invert_if.rs</a> </p>
<p>This transforms if expressions of the form <code>if !x {A} else {B}</code> into <code>if x {B} else {A}</code>
This also works with <code>!=</code>. This assist can only be applied with the cursor on <code>if</code>.</p>
<h4 id="before-78"><a class="header" href="#before-78">Before</a></h4>
<pre><code class="language-rust">fn main() {
    if‚îÉ !y { A } else { B }
}</code></pre>
<h4 id="after-78"><a class="header" href="#after-78">After</a></h4>
<pre><code class="language-rust">fn main() {
    if y { B } else { A }
}</code></pre>
<h3 id="line_to_block"><a class="header" href="#line_to_block"><code>line_to_block</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/convert_comment_block.rs#9">convert_comment_block.rs</a> </p>
<p>Converts comments between block and single-line form.</p>
<h4 id="before-79"><a class="header" href="#before-79">Before</a></h4>
<pre><code class="language-rust">   // Multi-line‚îÉ
   // comment</code></pre>
<h4 id="after-79"><a class="header" href="#after-79">After</a></h4>
<pre><code class="language-rust">  /*
  Multi-line
  comment
  */</code></pre>
<h3 id="make_raw_string"><a class="header" href="#make_raw_string"><code>make_raw_string</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/raw_string.rs#7">raw_string.rs</a> </p>
<p>Adds <code>r#</code> to a plain string literal.</p>
<h4 id="before-80"><a class="header" href="#before-80">Before</a></h4>
<pre><code class="language-rust">fn main() {
    &quot;Hello,‚îÉ World!&quot;;
}</code></pre>
<h4 id="after-80"><a class="header" href="#after-80">After</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello, World!&quot;#;
}</code></pre>
<h3 id="make_usual_string"><a class="header" href="#make_usual_string"><code>make_usual_string</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/raw_string.rs#47">raw_string.rs</a> </p>
<p>Turns a raw string into a plain string.</p>
<h4 id="before-81"><a class="header" href="#before-81">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello,‚îÉ &quot;World!&quot;&quot;#;
}</code></pre>
<h4 id="after-81"><a class="header" href="#after-81">After</a></h4>
<pre><code class="language-rust">fn main() {
    &quot;Hello, \&quot;World!\&quot;&quot;;
}</code></pre>
<h3 id="merge_imports"><a class="header" href="#merge_imports"><code>merge_imports</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/merge_imports.rs#17">merge_imports.rs</a> </p>
<p>Merges two imports with a common prefix.</p>
<h4 id="before-82"><a class="header" href="#before-82">Before</a></h4>
<pre><code class="language-rust">use std::‚îÉfmt::Formatter;
use std::io;</code></pre>
<h4 id="after-82"><a class="header" href="#after-82">After</a></h4>
<pre><code class="language-rust">use std::{fmt::Formatter, io};</code></pre>
<h3 id="merge_match_arms"><a class="header" href="#merge_match_arms"><code>merge_match_arms</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/merge_match_arms.rs#11">merge_match_arms.rs</a> </p>
<p>Merges the current match arm with the following if their bodies are identical.</p>
<h4 id="before-83"><a class="header" href="#before-83">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        ‚îÉAction::Move(..) =&gt; foo(),
        Action::Stop =&gt; foo(),
    }
}</code></pre>
<h4 id="after-83"><a class="header" href="#after-83">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) | Action::Stop =&gt; foo(),
    }
}</code></pre>
<h3 id="move_arm_cond_to_match_guard"><a class="header" href="#move_arm_cond_to_match_guard"><code>move_arm_cond_to_match_guard</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_guard.rs#69">move_guard.rs</a> </p>
<p>Moves if expression from match arm body into a guard.</p>
<h4 id="before-84"><a class="header" href="#before-84">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; ‚îÉif distance &gt; 10 { foo() },
        _ =&gt; (),
    }
}</code></pre>
<h4 id="after-84"><a class="header" href="#after-84">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } if distance &gt; 10 =&gt; foo(),
        _ =&gt; (),
    }
}</code></pre>
<h3 id="move_bounds_to_where_clause"><a class="header" href="#move_bounds_to_where_clause"><code>move_bounds_to_where_clause</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_bounds.rs#12">move_bounds.rs</a> </p>
<p>Moves inline type bounds to a where clause.</p>
<h4 id="before-85"><a class="header" href="#before-85">Before</a></h4>
<pre><code class="language-rust">fn apply&lt;T, U, ‚îÉF: FnOnce(T) -&gt; U&gt;(f: F, x: T) -&gt; U {
    f(x)
}</code></pre>
<h4 id="after-85"><a class="header" href="#after-85">After</a></h4>
<pre><code class="language-rust">fn apply&lt;T, U, F&gt;(f: F, x: T) -&gt; U where F: FnOnce(T) -&gt; U {
    f(x)
}</code></pre>
<h3 id="move_const_to_impl"><a class="header" href="#move_const_to_impl"><code>move_const_to_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_const_to_impl.rs#14">move_const_to_impl.rs</a> </p>
<p>Move a local constant item in a method to impl's associated constant. All the references will be
qualified with <code>Self::</code>.</p>
<h4 id="before-86"><a class="header" href="#before-86">Before</a></h4>
<pre><code class="language-rust">struct S;
impl S {
    fn foo() -&gt; usize {
        /// The answer.
        const C‚îÉ: usize = 42;

        C * C
    }
}</code></pre>
<h4 id="after-86"><a class="header" href="#after-86">After</a></h4>
<pre><code class="language-rust">struct S;
impl S {
    /// The answer.
    const C: usize = 42;

    fn foo() -&gt; usize {
        Self::C * Self::C
    }
}</code></pre>
<h3 id="move_from_mod_rs"><a class="header" href="#move_from_mod_rs"><code>move_from_mod_rs</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_from_mod_rs.rs#12">move_from_mod_rs.rs</a> </p>
<p>Moves xxx/mod.rs to xxx.rs.</p>
<h4 id="before-87"><a class="header" href="#before-87">Before</a></h4>
<pre><code class="language-rust">//- /main.rs
mod a;
//- /a/mod.rs
‚îÉfn t() {}‚îÉ</code></pre>
<h4 id="after-87"><a class="header" href="#after-87">After</a></h4>
<pre><code class="language-rust">fn t() {}</code></pre>
<h3 id="move_guard_to_arm_body"><a class="header" href="#move_guard_to_arm_body"><code>move_guard_to_arm_body</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_guard.rs#8">move_guard.rs</a> </p>
<p>Moves match guard into match arm body.</p>
<h4 id="before-88"><a class="header" href="#before-88">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } ‚îÉif distance &gt; 10 =&gt; foo(),
        _ =&gt; (),
    }
}</code></pre>
<h4 id="after-88"><a class="header" href="#after-88">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; if distance &gt; 10 {
            foo()
        },
        _ =&gt; (),
    }
}</code></pre>
<h3 id="move_module_to_file"><a class="header" href="#move_module_to_file"><code>move_module_to_file</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_module_to_file.rs#14">move_module_to_file.rs</a> </p>
<p>Moves inline module's contents to a separate file.</p>
<h4 id="before-89"><a class="header" href="#before-89">Before</a></h4>
<pre><code class="language-rust">mod ‚îÉfoo {
    fn t() {}
}</code></pre>
<h4 id="after-89"><a class="header" href="#after-89">After</a></h4>
<pre><code class="language-rust">mod foo;</code></pre>
<h3 id="move_to_mod_rs"><a class="header" href="#move_to_mod_rs"><code>move_to_mod_rs</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/move_to_mod_rs.rs#12">move_to_mod_rs.rs</a> </p>
<p>Moves xxx.rs to xxx/mod.rs.</p>
<h4 id="before-90"><a class="header" href="#before-90">Before</a></h4>
<pre><code class="language-rust">//- /main.rs
mod a;
//- /a.rs
‚îÉfn t() {}‚îÉ</code></pre>
<h4 id="after-90"><a class="header" href="#after-90">After</a></h4>
<pre><code class="language-rust">fn t() {}</code></pre>
<h3 id="promote_local_to_const"><a class="header" href="#promote_local_to_const"><code>promote_local_to_const</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/promote_local_to_const.rs#16">promote_local_to_const.rs</a> </p>
<p>Promotes a local variable to a const item changing its name to a <code>SCREAMING_SNAKE_CASE</code> variant
if the local uses no non-const expressions.</p>
<h4 id="before-91"><a class="header" href="#before-91">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let foo‚îÉ = true;

    if foo {
        println!(&quot;It's true&quot;);
    } else {
        println!(&quot;It's false&quot;);
    }
}</code></pre>
<h4 id="after-91"><a class="header" href="#after-91">After</a></h4>
<pre><code class="language-rust">fn main() {
    const ‚îÉFOO: bool = true;

    if FOO {
        println!(&quot;It's true&quot;);
    } else {
        println!(&quot;It's false&quot;);
    }
}</code></pre>
<h3 id="pull_assignment_up"><a class="header" href="#pull_assignment_up"><code>pull_assignment_up</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/pull_assignment_up.rs#11">pull_assignment_up.rs</a> </p>
<p>Extracts variable assignment to outside an if or match statement.</p>
<h4 id="before-92"><a class="header" href="#before-92">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 6;

    if true {
        ‚îÉfoo = 5;
    } else {
        foo = 4;
    }
}</code></pre>
<h4 id="after-92"><a class="header" href="#after-92">After</a></h4>
<pre><code class="language-rust">fn main() {
    let mut foo = 6;

    foo = if true {
        5
    } else {
        4
    };
}</code></pre>
<h3 id="qualify_method_call"><a class="header" href="#qualify_method_call"><code>qualify_method_call</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/qualify_method_call.rs#10">qualify_method_call.rs</a> </p>
<p>Replaces the method call with a qualified function call.</p>
<h4 id="before-93"><a class="header" href="#before-93">Before</a></h4>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self) {}
}
fn main() {
    let foo = Foo;
    foo.fo‚îÉo();
}</code></pre>
<h4 id="after-93"><a class="header" href="#after-93">After</a></h4>
<pre><code class="language-rust">struct Foo;
impl Foo {
    fn foo(&amp;self) {}
}
fn main() {
    let foo = Foo;
    Foo::foo(&amp;foo);
}</code></pre>
<h3 id="qualify_path"><a class="header" href="#qualify_path"><code>qualify_path</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/qualify_path.rs#21">qualify_path.rs</a> </p>
<p>If the name is unresolved, provides all possible qualified paths for it.</p>
<h4 id="before-94"><a class="header" href="#before-94">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let map = HashMap‚îÉ::new();
}</code></pre>
<h4 id="after-94"><a class="header" href="#after-94">After</a></h4>
<pre><code class="language-rust">fn main() {
    let map = std::collections::HashMap::new();
}</code></pre>
<h3 id="reformat_number_literal"><a class="header" href="#reformat_number_literal"><code>reformat_number_literal</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/number_representation.rs#7">number_representation.rs</a> </p>
<p>Adds or removes separators from integer literal.</p>
<h4 id="before-95"><a class="header" href="#before-95">Before</a></h4>
<pre><code class="language-rust">const _: i32 = 1012345‚îÉ;</code></pre>
<h4 id="after-95"><a class="header" href="#after-95">After</a></h4>
<pre><code class="language-rust">const _: i32 = 1_012_345;</code></pre>
<h3 id="remove_dbg"><a class="header" href="#remove_dbg"><code>remove_dbg</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/remove_dbg.rs#9">remove_dbg.rs</a> </p>
<p>Removes <code>dbg!()</code> macro call.</p>
<h4 id="before-96"><a class="header" href="#before-96">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = ‚îÉdbg!(42 * dbg!(4 + 2));‚îÉ
}</code></pre>
<h4 id="after-96"><a class="header" href="#after-96">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = 42 * (4 + 2);
}</code></pre>
<h3 id="remove_hash"><a class="header" href="#remove_hash"><code>remove_hash</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/raw_string.rs#117">raw_string.rs</a> </p>
<p>Removes a hash from a raw string literal.</p>
<h4 id="before-97"><a class="header" href="#before-97">Before</a></h4>
<pre><code class="language-rust">fn main() {
    r#&quot;Hello,‚îÉ World!&quot;#;
}</code></pre>
<h4 id="after-97"><a class="header" href="#after-97">After</a></h4>
<pre><code class="language-rust">fn main() {
    r&quot;Hello, World!&quot;;
}</code></pre>
<h3 id="remove_mut"><a class="header" href="#remove_mut"><code>remove_mut</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/remove_mut.rs#5">remove_mut.rs</a> </p>
<p>Removes the <code>mut</code> keyword.</p>
<h4 id="before-98"><a class="header" href="#before-98">Before</a></h4>
<pre><code class="language-rust">impl Walrus {
    fn feed(&amp;mut‚îÉ self, amount: u32) {}
}</code></pre>
<h4 id="after-98"><a class="header" href="#after-98">After</a></h4>
<pre><code class="language-rust">impl Walrus {
    fn feed(&amp;self, amount: u32) {}
}</code></pre>
<h3 id="remove_parentheses"><a class="header" href="#remove_parentheses"><code>remove_parentheses</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/remove_parentheses.rs#5">remove_parentheses.rs</a> </p>
<p>Removes redundant parentheses.</p>
<h4 id="before-99"><a class="header" href="#before-99">Before</a></h4>
<pre><code class="language-rust">fn main() {
    _ = ‚îÉ(2) + 2;
}</code></pre>
<h4 id="after-99"><a class="header" href="#after-99">After</a></h4>
<pre><code class="language-rust">fn main() {
    _ = 2 + 2;
}</code></pre>
<h3 id="remove_unused_imports"><a class="header" href="#remove_unused_imports"><code>remove_unused_imports</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/remove_unused_imports.rs#15">remove_unused_imports.rs</a> </p>
<p>Removes any use statements in the current selection that are unused.</p>
<h4 id="before-100"><a class="header" href="#before-100">Before</a></h4>
<pre><code class="language-rust">struct X();
mod foo {
    use super::X‚îÉ;
}</code></pre>
<h4 id="after-100"><a class="header" href="#after-100">After</a></h4>
<pre><code class="language-rust">struct X();
mod foo {
}</code></pre>
<h3 id="remove_unused_param"><a class="header" href="#remove_unused_param"><code>remove_unused_param</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/remove_unused_param.rs#15">remove_unused_param.rs</a> </p>
<p>Removes unused function parameter.</p>
<h4 id="before-101"><a class="header" href="#before-101">Before</a></h4>
<pre><code class="language-rust">fn frobnicate(x: i32‚îÉ) {}

fn main() {
    frobnicate(92);
}</code></pre>
<h4 id="after-101"><a class="header" href="#after-101">After</a></h4>
<pre><code class="language-rust">fn frobnicate() {}

fn main() {
    frobnicate();
}</code></pre>
<h3 id="reorder_fields"><a class="header" href="#reorder_fields"><code>reorder_fields</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/reorder_fields.rs#8">reorder_fields.rs</a> </p>
<p>Reorder the fields of record literals and record patterns in the same order as in
the definition.</p>
<h4 id="before-102"><a class="header" href="#before-102">Before</a></h4>
<pre><code class="language-rust">struct Foo {foo: i32, bar: i32};
const test: Foo = ‚îÉFoo {bar: 0, foo: 1}</code></pre>
<h4 id="after-102"><a class="header" href="#after-102">After</a></h4>
<pre><code class="language-rust">struct Foo {foo: i32, bar: i32};
const test: Foo = Foo {foo: 1, bar: 0}</code></pre>
<h3 id="reorder_impl_items"><a class="header" href="#reorder_impl_items"><code>reorder_impl_items</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/reorder_impl_items.rs#11">reorder_impl_items.rs</a> </p>
<p>Reorder the items of an <code>impl Trait</code>. The items will be ordered
in the same order as in the trait definition.</p>
<h4 id="before-103"><a class="header" href="#before-103">Before</a></h4>
<pre><code class="language-rust">trait Foo {
    type A;
    const B: u8;
    fn c();
}

struct Bar;
‚îÉimpl Foo for Bar‚îÉ {
    const B: u8 = 17;
    fn c() {}
    type A = String;
}</code></pre>
<h4 id="after-103"><a class="header" href="#after-103">After</a></h4>
<pre><code class="language-rust">trait Foo {
    type A;
    const B: u8;
    fn c();
}

struct Bar;
impl Foo for Bar {
    type A = String;
    const B: u8 = 17;
    fn c() {}
}</code></pre>
<h3 id="replace_arith_with_checked"><a class="header" href="#replace_arith_with_checked"><code>replace_arith_with_checked</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_arith_op.rs#9">replace_arith_op.rs</a> </p>
<p>Replaces arithmetic on integers with the <code>checked_*</code> equivalent.</p>
<h4 id="before-104"><a class="header" href="#before-104">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ‚îÉ+ 2;
}</code></pre>
<h4 id="after-104"><a class="header" href="#after-104">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.checked_add(2);
}</code></pre>
<h3 id="replace_arith_with_saturating"><a class="header" href="#replace_arith_with_saturating"><code>replace_arith_with_saturating</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_arith_op.rs#28">replace_arith_op.rs</a> </p>
<p>Replaces arithmetic on integers with the <code>saturating_*</code> equivalent.</p>
<h4 id="before-105"><a class="header" href="#before-105">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ‚îÉ+ 2;
}</code></pre>
<h4 id="after-105"><a class="header" href="#after-105">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.saturating_add(2);
}</code></pre>
<h3 id="replace_arith_with_wrapping"><a class="header" href="#replace_arith_with_wrapping"><code>replace_arith_with_wrapping</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_arith_op.rs#50">replace_arith_op.rs</a> </p>
<p>Replaces arithmetic on integers with the <code>wrapping_*</code> equivalent.</p>
<h4 id="before-106"><a class="header" href="#before-106">Before</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1 ‚îÉ+ 2;
}</code></pre>
<h4 id="after-106"><a class="header" href="#after-106">After</a></h4>
<pre><code class="language-rust">fn main() {
  let x = 1.wrapping_add(2);
}</code></pre>
<h3 id="replace_char_with_string"><a class="header" href="#replace_char_with_string"><code>replace_char_with_string</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_string_with_char.rs#51">replace_string_with_char.rs</a> </p>
<p>Replace a char literal with a string literal.</p>
<h4 id="before-107"><a class="header" href="#before-107">Before</a></h4>
<pre><code class="language-rust">fn main() {
    find('{‚îÉ');
}</code></pre>
<h4 id="after-107"><a class="header" href="#after-107">After</a></h4>
<pre><code class="language-rust">fn main() {
    find(&quot;{&quot;);
}</code></pre>
<h3 id="replace_derive_with_manual_impl"><a class="header" href="#replace_derive_with_manual_impl"><code>replace_derive_with_manual_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_derive_with_manual_impl.rs#18">replace_derive_with_manual_impl.rs</a> </p>
<p>Converts a <code>derive</code> impl into a manual one.</p>
<h4 id="before-108"><a class="header" href="#before-108">Before</a></h4>
<pre><code class="language-rust">#[derive(Deb‚îÉug, Display)]
struct S;</code></pre>
<h4 id="after-108"><a class="header" href="#after-108">After</a></h4>
<pre><code class="language-rust">#[derive(Display)]
struct S;

impl Debug for S {
    ‚îÉfn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;()&gt; {
        f.debug_struct(&quot;S&quot;).finish()
    }
}</code></pre>
<h3 id="replace_if_let_with_match"><a class="header" href="#replace_if_let_with_match"><code>replace_if_let_with_match</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_if_let_with_match.rs#24">replace_if_let_with_match.rs</a> </p>
<p>Replaces a <code>if let</code> expression with a <code>match</code> expression.</p>
<h4 id="before-109"><a class="header" href="#before-109">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    ‚îÉif let Action::Move { distance } = action {
        foo(distance)
    } else {
        bar()
    }
}</code></pre>
<h4 id="after-109"><a class="header" href="#after-109">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move { distance } =&gt; foo(distance),
        _ =&gt; bar(),
    }
}</code></pre>
<h3 id="replace_is_some_with_if_let_some"><a class="header" href="#replace_is_some_with_if_let_some"><code>replace_is_some_with_if_let_some</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_is_method_with_if_let_method.rs#5">replace_is_method_with_if_let_method.rs</a> </p>
<p>Replace <code>if x.is_some()</code> with <code>if let Some(_tmp) = x</code> or <code>if x.is_ok()</code> with <code>if let Ok(_tmp) = x</code>.</p>
<h4 id="before-110"><a class="header" href="#before-110">Before</a></h4>
<pre><code class="language-rust">fn main() {
    let x = Some(1);
    if x.is_som‚îÉe() {}
}</code></pre>
<h4 id="after-110"><a class="header" href="#after-110">After</a></h4>
<pre><code class="language-rust">fn main() {
    let x = Some(1);
    if let Some(${0:x}) = x {}
}</code></pre>
<h3 id="replace_let_with_if_let"><a class="header" href="#replace_let_with_if_let"><code>replace_let_with_if_let</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_let_with_if_let.rs#15">replace_let_with_if_let.rs</a> </p>
<p>Replaces <code>let</code> with an <code>if let</code>.</p>
<h4 id="before-111"><a class="header" href="#before-111">Before</a></h4>
<pre><code class="language-rust">
fn main(action: Action) {
    ‚îÉlet x = compute();
}

fn compute() -&gt; Option&lt;i32&gt; { None }</code></pre>
<h4 id="after-111"><a class="header" href="#after-111">After</a></h4>
<pre><code class="language-rust">
fn main(action: Action) {
    if let Some(x) = compute() {
    }
}

fn compute() -&gt; Option&lt;i32&gt; { None }</code></pre>
<h3 id="replace_match_with_if_let"><a class="header" href="#replace_match_with_if_let"><code>replace_match_with_if_let</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_if_let_with_match.rs#187">replace_if_let_with_match.rs</a> </p>
<p>Replaces a binary <code>match</code> with a wildcard pattern and no guards with an <code>if let</code> expression.</p>
<h4 id="before-112"><a class="header" href="#before-112">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    ‚îÉmatch action {
        Action::Move { distance } =&gt; foo(distance),
        _ =&gt; bar(),
    }
}</code></pre>
<h4 id="after-112"><a class="header" href="#after-112">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    if let Action::Move { distance } = action {
        foo(distance)
    } else {
        bar()
    }
}</code></pre>
<h3 id="replace_named_generic_with_impl"><a class="header" href="#replace_named_generic_with_impl"><code>replace_named_generic_with_impl</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_named_generic_with_impl.rs#19">replace_named_generic_with_impl.rs</a> </p>
<p>Replaces named generic with an <code>impl Trait</code> in function argument.</p>
<h4 id="before-113"><a class="header" href="#before-113">Before</a></h4>
<pre><code class="language-rust">fn new&lt;P‚îÉ: AsRef&lt;Path&gt;&gt;(location: P) -&gt; Self {}</code></pre>
<h4 id="after-113"><a class="header" href="#after-113">After</a></h4>
<pre><code class="language-rust">fn new(location: impl AsRef&lt;Path&gt;) -&gt; Self {}</code></pre>
<h3 id="replace_qualified_name_with_use"><a class="header" href="#replace_qualified_name_with_use"><code>replace_qualified_name_with_use</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_qualified_name_with_use.rs#13">replace_qualified_name_with_use.rs</a> </p>
<p>Adds a use statement for a given fully-qualified name.</p>
<h4 id="before-114"><a class="header" href="#before-114">Before</a></h4>
<pre><code class="language-rust">fn process(map: std::collections::‚îÉHashMap&lt;String, String&gt;) {}</code></pre>
<h4 id="after-114"><a class="header" href="#after-114">After</a></h4>
<pre><code class="language-rust">use std::collections::HashMap;

fn process(map: HashMap&lt;String, String&gt;) {}</code></pre>
<h3 id="replace_string_with_char"><a class="header" href="#replace_string_with_char"><code>replace_string_with_char</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_string_with_char.rs#11">replace_string_with_char.rs</a> </p>
<p>Replace string literal with char literal.</p>
<h4 id="before-115"><a class="header" href="#before-115">Before</a></h4>
<pre><code class="language-rust">fn main() {
    find(&quot;{‚îÉ&quot;);
}</code></pre>
<h4 id="after-115"><a class="header" href="#after-115">After</a></h4>
<pre><code class="language-rust">fn main() {
    find('{');
}</code></pre>
<h3 id="replace_try_expr_with_match"><a class="header" href="#replace_try_expr_with_match"><code>replace_try_expr_with_match</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_try_expr_with_match.rs#18">replace_try_expr_with_match.rs</a> </p>
<p>Replaces a <code>try</code> expression with a <code>match</code> expression.</p>
<h4 id="before-116"><a class="header" href="#before-116">Before</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = Some(true)‚îÉ?;
}</code></pre>
<h4 id="after-116"><a class="header" href="#after-116">After</a></h4>
<pre><code class="language-rust">fn handle() {
    let pat = match Some(true) {
        Some(it) =&gt; it,
        None =&gt; return None,
    };
}</code></pre>
<h3 id="replace_turbofish_with_explicit_type"><a class="header" href="#replace_turbofish_with_explicit_type"><code>replace_turbofish_with_explicit_type</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_turbofish_with_explicit_type.rs#13">replace_turbofish_with_explicit_type.rs</a> </p>
<p>Converts <code>::&lt;_&gt;</code> to an explicit type assignment.</p>
<h4 id="before-117"><a class="header" href="#before-117">Before</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { ) }
fn main() {
    let a = make‚îÉ::&lt;i32&gt;();
}</code></pre>
<h4 id="after-117"><a class="header" href="#after-117">After</a></h4>
<pre><code class="language-rust">fn make&lt;T&gt;() -&gt; T { ) }
fn main() {
    let a: i32 = make();
}</code></pre>
<h3 id="replace_with_eager_method"><a class="header" href="#replace_with_eager_method"><code>replace_with_eager_method</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_method_eager_lazy.rs#89">replace_method_eager_lazy.rs</a> </p>
<p>Replace <code>unwrap_or_else</code> with <code>unwrap_or</code> and <code>ok_or_else</code> with <code>ok_or</code>.</p>
<h4 id="before-118"><a class="header" href="#before-118">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwra‚îÉp_or_else(|| 2);
}</code></pre>
<h4 id="after-118"><a class="header" href="#after-118">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwrap_or(2);
}</code></pre>
<h3 id="replace_with_lazy_method"><a class="header" href="#replace_with_lazy_method"><code>replace_with_lazy_method</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/replace_method_eager_lazy.rs#9">replace_method_eager_lazy.rs</a> </p>
<p>Replace <code>unwrap_or</code> with <code>unwrap_or_else</code> and <code>ok_or</code> with <code>ok_or_else</code>.</p>
<h4 id="before-119"><a class="header" href="#before-119">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwra‚îÉp_or(2);
}</code></pre>
<h4 id="after-119"><a class="header" href="#after-119">After</a></h4>
<pre><code class="language-rust">fn foo() {
    let a = Some(1);
    a.unwrap_or_else(|| 2);
}</code></pre>
<h3 id="sort_items"><a class="header" href="#sort_items"><code>sort_items</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/sort_items.rs#12">sort_items.rs</a> </p>
<p>Sorts item members alphabetically: fields, enum variants and methods.</p>
<h4 id="before-120"><a class="header" href="#before-120">Before</a></h4>
<pre><code class="language-rust">struct ‚îÉFoo‚îÉ { second: u32, first: String }</code></pre>
<h4 id="after-120"><a class="header" href="#after-120">After</a></h4>
<pre><code class="language-rust">struct Foo { first: String, second: u32 }</code></pre>
<hr />
<h4 id="before-121"><a class="header" href="#before-121">Before</a></h4>
<pre><code class="language-rust">trait ‚îÉBar‚îÉ {
    fn second(&amp;self) -&gt; u32;
    fn first(&amp;self) -&gt; String;
}</code></pre>
<h4 id="after-121"><a class="header" href="#after-121">After</a></h4>
<pre><code class="language-rust">trait Bar {
    fn first(&amp;self) -&gt; String;
    fn second(&amp;self) -&gt; u32;
}</code></pre>
<hr />
<h4 id="before-122"><a class="header" href="#before-122">Before</a></h4>
<pre><code class="language-rust">struct Baz;
impl ‚îÉBaz‚îÉ {
    fn second(&amp;self) -&gt; u32;
    fn first(&amp;self) -&gt; String;
}</code></pre>
<h4 id="after-122"><a class="header" href="#after-122">After</a></h4>
<pre><code class="language-rust">struct Baz;
impl Baz {
    fn first(&amp;self) -&gt; String;
    fn second(&amp;self) -&gt; u32;
}</code></pre>
<hr />
<p>There is a difference between sorting enum variants:</p>
<h4 id="before-123"><a class="header" href="#before-123">Before</a></h4>
<pre><code class="language-rust">enum ‚îÉAnimal‚îÉ {
  Dog(String, f64),
  Cat { weight: f64, name: String },
}</code></pre>
<h4 id="after-123"><a class="header" href="#after-123">After</a></h4>
<pre><code class="language-rust">enum Animal {
  Cat { weight: f64, name: String },
  Dog(String, f64),
}</code></pre>
<p>and sorting a single enum struct variant:</p>
<h4 id="before-124"><a class="header" href="#before-124">Before</a></h4>
<pre><code class="language-rust">enum Animal {
  Dog(String, f64),
  Cat ‚îÉ{ weight: f64, name: String }‚îÉ,
}</code></pre>
<h4 id="after-124"><a class="header" href="#after-124">After</a></h4>
<pre><code class="language-rust">enum Animal {
  Dog(String, f64),
  Cat { name: String, weight: f64 },
}</code></pre>
<h3 id="split_import"><a class="header" href="#split_import"><code>split_import</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/split_import.rs#5">split_import.rs</a> </p>
<p>Wraps the tail of import into braces.</p>
<h4 id="before-125"><a class="header" href="#before-125">Before</a></h4>
<pre><code class="language-rust">use std::‚îÉcollections::HashMap;</code></pre>
<h4 id="after-125"><a class="header" href="#after-125">After</a></h4>
<pre><code class="language-rust">use std::{collections::HashMap};</code></pre>
<h3 id="toggle_ignore"><a class="header" href="#toggle_ignore"><code>toggle_ignore</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/toggle_ignore.rs#8">toggle_ignore.rs</a> </p>
<p>Adds <code>#[ignore]</code> attribute to the test.</p>
<h4 id="before-126"><a class="header" href="#before-126">Before</a></h4>
<pre><code class="language-rust">‚îÉ#[test]
fn arithmetics {
    assert_eq!(2 + 2, 5);
}</code></pre>
<h4 id="after-126"><a class="header" href="#after-126">After</a></h4>
<pre><code class="language-rust">#[test]
#[ignore]
fn arithmetics {
    assert_eq!(2 + 2, 5);
}</code></pre>
<h3 id="unmerge_match_arm"><a class="header" href="#unmerge_match_arm"><code>unmerge_match_arm</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unmerge_match_arm.rs#10">unmerge_match_arm.rs</a> </p>
<p>Splits the current match with a <code>|</code> pattern into two arms with identical bodies.</p>
<h4 id="before-127"><a class="header" href="#before-127">Before</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) ‚îÉ| Action::Stop =&gt; foo(),
    }
}</code></pre>
<h4 id="after-127"><a class="header" href="#after-127">After</a></h4>
<pre><code class="language-rust">enum Action { Move { distance: u32 }, Stop }

fn handle(action: Action) {
    match action {
        Action::Move(..) =&gt; foo(),
        Action::Stop =&gt; foo(),
    }
}</code></pre>
<h3 id="unmerge_use"><a class="header" href="#unmerge_use"><code>unmerge_use</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unmerge_use.rs#12">unmerge_use.rs</a> </p>
<p>Extracts single use item from use list.</p>
<h4 id="before-128"><a class="header" href="#before-128">Before</a></h4>
<pre><code class="language-rust">use std::fmt::{Debug, Display‚îÉ};</code></pre>
<h4 id="after-128"><a class="header" href="#after-128">After</a></h4>
<pre><code class="language-rust">use std::fmt::{Debug};
use std::fmt::Display;</code></pre>
<h3 id="unnecessary_async"><a class="header" href="#unnecessary_async"><code>unnecessary_async</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unnecessary_async.rs#15">unnecessary_async.rs</a> </p>
<p>Removes the <code>async</code> mark from functions which have no <code>.await</code> in their body.
Looks for calls to the functions and removes the <code>.await</code> on the call site.</p>
<h4 id="before-129"><a class="header" href="#before-129">Before</a></h4>
<pre><code class="language-rust">pub async f‚îÉn foo() {}
pub async fn bar() { foo().await }</code></pre>
<h4 id="after-129"><a class="header" href="#after-129">After</a></h4>
<pre><code class="language-rust">pub fn foo() {}
pub async fn bar() { foo() }</code></pre>
<h3 id="unqualify_method_call"><a class="header" href="#unqualify_method_call"><code>unqualify_method_call</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unqualify_method_call.rs#9">unqualify_method_call.rs</a> </p>
<p>Transforms universal function call syntax into a method call.</p>
<h4 id="before-130"><a class="header" href="#before-130">Before</a></h4>
<pre><code class="language-rust">fn main() {
    std::ops::Add::add‚îÉ(1, 2);
}</code></pre>
<h4 id="after-130"><a class="header" href="#after-130">After</a></h4>
<pre><code class="language-rust">use std::ops::Add;

fn main() {
    1.add(2);
}</code></pre>
<h3 id="unwrap_block"><a class="header" href="#unwrap_block"><code>unwrap_block</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unwrap_block.rs#12">unwrap_block.rs</a> </p>
<p>This assist removes if...else, for, while and loop control statements to just keep the body.</p>
<h4 id="before-131"><a class="header" href="#before-131">Before</a></h4>
<pre><code class="language-rust">fn foo() {
    if true {‚îÉ
        println!(&quot;foo&quot;);
    }
}</code></pre>
<h4 id="after-131"><a class="header" href="#after-131">After</a></h4>
<pre><code class="language-rust">fn foo() {
    println!(&quot;foo&quot;);
}</code></pre>
<h3 id="unwrap_result_return_type"><a class="header" href="#unwrap_result_return_type"><code>unwrap_result_return_type</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unwrap_result_return_type.rs#13">unwrap_result_return_type.rs</a> </p>
<p>Unwrap the function's return type.</p>
<h4 id="before-132"><a class="header" href="#before-132">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;i32&gt;‚îÉ { Ok(42i32) }</code></pre>
<h4 id="after-132"><a class="header" href="#after-132">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32 { 42i32 }</code></pre>
<h3 id="unwrap_tuple"><a class="header" href="#unwrap_tuple"><code>unwrap_tuple</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/unwrap_tuple.rs#8">unwrap_tuple.rs</a> </p>
<p>Unwrap the tuple to different variables.</p>
<h4 id="before-133"><a class="header" href="#before-133">Before</a></h4>
<pre><code class="language-rust">fn main() {
    ‚îÉlet (foo, bar) = (&quot;Foo&quot;, &quot;Bar&quot;);
}</code></pre>
<h4 id="after-133"><a class="header" href="#after-133">After</a></h4>
<pre><code class="language-rust">fn main() {
    let foo = &quot;Foo&quot;;
    let bar = &quot;Bar&quot;;
}</code></pre>
<h3 id="wrap_return_type_in_result"><a class="header" href="#wrap_return_type_in_result"><code>wrap_return_type_in_result</code></a></h3>
<p><strong>Source:</strong>  <a href="assists/crates/ide-assists/src/handlers/wrap_return_type_in_result.rs#14">wrap_return_type_in_result.rs</a> </p>
<p>Wrap the function's return type into Result.</p>
<h4 id="before-134"><a class="header" href="#before-134">Before</a></h4>
<pre><code class="language-rust">fn foo() -&gt; i32‚îÉ { 42i32 }</code></pre>
<h4 id="after-134"><a class="header" href="#after-134">After</a></h4>
<pre><code class="language-rust">fn foo() -&gt; Result&lt;i32, ${0:_}&gt; { Ok(42i32) }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diagnostics"><a class="header" href="#diagnostics">Diagnostics</a></h1>
<p>While most errors and warnings provided by rust-analyzer come from the
<code>cargo check</code> integration, there‚Äôs a growing number of diagnostics
implemented using rust-analyzer‚Äôs own analysis. Some of these
diagnostics don‚Äôt respect <code>#[allow]</code> or <code>\#[deny]</code> attributes yet, but
can be turned off using the <code>rust-analyzer.diagnostics.enable</code>,
<code>rust-analyzer.diagnostics.experimental.enable</code> or
<code>rust-analyzer.diagnostics.disabled</code> settings.</p>
<h2 id="clippy"><a class="header" href="#clippy">Clippy</a></h2>
<p>To run <code>cargo clippy</code> instead of <code>cargo check</code>, you can set
<code>&quot;rust-analyzer.check.command&quot;: &quot;clippy&quot;</code>.</p>
<h4 id="break-outside-of-loop"><a class="header" href="#break-outside-of-loop">break-outside-of-loop</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/break_outside_of_loop.rs#3">break_outside_of_loop.rs</a> </p>
<p>This diagnostic is triggered if the <code>break</code> keyword is used outside of a loop.</p>
<h4 id="expected-function"><a class="header" href="#expected-function">expected-function</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/expected_function.rs#5">expected_function.rs</a> </p>
<p>This diagnostic is triggered if a call is made on something that is not callable.</p>
<h4 id="inactive-code"><a class="header" href="#inactive-code">inactive-code</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/inactive_code.rs#6">inactive_code.rs</a> </p>
<p>This diagnostic is shown for code with inactive <code>#[cfg]</code> attributes.</p>
<h4 id="incoherent-impl"><a class="header" href="#incoherent-impl">incoherent-impl</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/incoherent_impl.rs#5">incoherent_impl.rs</a> </p>
<p>This diagnostic is triggered if the targe type of an impl is from a foreign crate.</p>
<h4 id="incorrect-ident-case"><a class="header" href="#incorrect-ident-case">incorrect-ident-case</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/incorrect_case.rs#13">incorrect_case.rs</a> </p>
<p>This diagnostic is triggered if an item name doesn't follow <a href="https://doc.rust-lang.org/1.0.0/style/style/naming/README.html">Rust naming convention</a>.</p>
<h4 id="invalid-derive-target"><a class="header" href="#invalid-derive-target">invalid-derive-target</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/invalid_derive_target.rs#3">invalid_derive_target.rs</a> </p>
<p>This diagnostic is shown when the derive attribute is used on an item other than a <code>struct</code>,
<code>enum</code> or <code>union</code>.</p>
<h4 id="macro-error"><a class="header" href="#macro-error">macro-error</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/macro_error.rs#3">macro_error.rs</a> </p>
<p>This diagnostic is shown for macro expansion errors.</p>
<h4 id="macro-error-1"><a class="header" href="#macro-error-1">macro-error</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/macro_error.rs#17">macro_error.rs</a> </p>
<p>This diagnostic is shown for macro expansion errors.</p>
<h4 id="malformed-derive"><a class="header" href="#malformed-derive">malformed-derive</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/malformed_derive.rs#3">malformed_derive.rs</a> </p>
<p>This diagnostic is shown when the derive attribute has invalid input.</p>
<h4 id="mismatched-arg-count"><a class="header" href="#mismatched-arg-count">mismatched-arg-count</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/mismatched_arg_count.rs#30">mismatched_arg_count.rs</a> </p>
<p>This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.</p>
<h4 id="mismatched-tuple-struct-pat-arg-count"><a class="header" href="#mismatched-tuple-struct-pat-arg-count">mismatched-tuple-struct-pat-arg-count</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/mismatched_arg_count.rs#10">mismatched_arg_count.rs</a> </p>
<p>This diagnostic is triggered if a function is invoked with an incorrect amount of arguments.</p>
<h4 id="missing-fields"><a class="header" href="#missing-fields">missing-fields</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/missing_fields.rs#20">missing_fields.rs</a> </p>
<p>This diagnostic is triggered if record lacks some fields that exist in the corresponding structure.</p>
<p>Example:</p>
<pre><code class="language-rust">struct A { a: u8, b: u8 }

let a = A { a: 10 };</code></pre>
<h4 id="missing-match-arm"><a class="header" href="#missing-match-arm">missing-match-arm</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/missing_match_arms.rs#3">missing_match_arms.rs</a> </p>
<p>This diagnostic is triggered if <code>match</code> block is missing one or more match arms.</p>
<h4 id="missing-unsafe"><a class="header" href="#missing-unsafe">missing-unsafe</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/missing_unsafe.rs#9">missing_unsafe.rs</a> </p>
<p>This diagnostic is triggered if an operation marked as <code>unsafe</code> is used outside of an <code>unsafe</code> function or block.</p>
<h4 id="moved-out-of-ref"><a class="header" href="#moved-out-of-ref">moved-out-of-ref</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/moved_out_of_ref.rs#4">moved_out_of_ref.rs</a> </p>
<p>This diagnostic is triggered on moving non copy things out of references.</p>
<h4 id="need-mut"><a class="header" href="#need-mut">need-mut</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/mutability_errors.rs#7">mutability_errors.rs</a> </p>
<p>This diagnostic is triggered on mutating an immutable variable.</p>
<h4 id="no-such-field"><a class="header" href="#no-such-field">no-such-field</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/no_such_field.rs#12">no_such_field.rs</a> </p>
<p>This diagnostic is triggered if created structure does not have field provided in record.</p>
<h4 id="private-assoc-item"><a class="header" href="#private-assoc-item">private-assoc-item</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/private_assoc_item.rs#3">private_assoc_item.rs</a> </p>
<p>This diagnostic is triggered if the referenced associated item is not visible from the current
module.</p>
<h4 id="private-field"><a class="header" href="#private-field">private-field</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/private_field.rs#3">private_field.rs</a> </p>
<p>This diagnostic is triggered if the accessed field is not visible from the current module.</p>
<h4 id="replace-filter-map-next-with-find-map"><a class="header" href="#replace-filter-map-next-with-find-map">replace-filter-map-next-with-find-map</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/replace_filter_map_next_with_find_map.rs#11">replace_filter_map_next_with_find_map.rs</a> </p>
<p>This diagnostic is triggered when <code>.filter_map(..).next()</code> is used, rather than the more concise <code>.find_map(..)</code>.</p>
<h4 id="type-mismatch"><a class="header" href="#type-mismatch">type-mismatch</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/type_mismatch.rs#11">type_mismatch.rs</a> </p>
<p>This diagnostic is triggered when the type of an expression or pattern does not match
the expected type.</p>
<h4 id="typed-hole"><a class="header" href="#typed-hole">typed-hole</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/typed_hole.rs#12">typed_hole.rs</a> </p>
<p>This diagnostic is triggered when an underscore expression is used in an invalid position.</p>
<h4 id="undeclared-label"><a class="header" href="#undeclared-label">undeclared-label</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/undeclared_label.rs#3">undeclared_label.rs</a> </p>
<h4 id="unimplemented-builtin-macro"><a class="header" href="#unimplemented-builtin-macro">unimplemented-builtin-macro</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unimplemented_builtin_macro.rs#3">unimplemented_builtin_macro.rs</a> </p>
<p>This diagnostic is shown for builtin macros which are not yet implemented by rust-analyzer</p>
<h4 id="unlinked-file"><a class="header" href="#unlinked-file">unlinked-file</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unlinked_file.rs#19">unlinked_file.rs</a> </p>
<p>This diagnostic is shown for files that are not included in any crate, or files that are part of
crates rust-analyzer failed to discover. The file will not have IDE features available.</p>
<h4 id="unnecessary-braces"><a class="header" href="#unnecessary-braces">unnecessary-braces</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/useless_braces.rs#9">useless_braces.rs</a> </p>
<p>Diagnostic for unnecessary braces in <code>use</code> items.</p>
<h4 id="unreachable-label"><a class="header" href="#unreachable-label">unreachable-label</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unreachable_label.rs#3">unreachable_label.rs</a> </p>
<h4 id="unresolved-extern-crate"><a class="header" href="#unresolved-extern-crate">unresolved-extern-crate</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_extern_crate.rs#3">unresolved_extern_crate.rs</a> </p>
<p>This diagnostic is triggered if rust-analyzer is unable to discover referred extern crate.</p>
<h4 id="unresolved-field"><a class="header" href="#unresolved-field">unresolved-field</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_field.rs#13">unresolved_field.rs</a> </p>
<p>This diagnostic is triggered if a field does not exist on a given type.</p>
<h4 id="unresolved-import"><a class="header" href="#unresolved-import">unresolved-import</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_import.rs#3">unresolved_import.rs</a> </p>
<p>This diagnostic is triggered if rust-analyzer is unable to resolve a path in
a <code>use</code> declaration.</p>
<h4 id="unresolved-macro-call"><a class="header" href="#unresolved-macro-call">unresolved-macro-call</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs#3">unresolved_macro_call.rs</a> </p>
<p>This diagnostic is triggered if rust-analyzer is unable to resolve the path
to a macro in a macro invocation.</p>
<h4 id="unresolved-method"><a class="header" href="#unresolved-method">unresolved-method</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_method.rs#13">unresolved_method.rs</a> </p>
<p>This diagnostic is triggered if a method does not exist on a given type.</p>
<h4 id="unresolved-module"><a class="header" href="#unresolved-module">unresolved-module</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_module.rs#8">unresolved_module.rs</a> </p>
<p>This diagnostic is triggered if rust-analyzer is unable to discover referred module.</p>
<h4 id="unresolved-proc-macro"><a class="header" href="#unresolved-proc-macro">unresolved-proc-macro</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unresolved_proc_macro.rs#5">unresolved_proc_macro.rs</a> </p>
<p>This diagnostic is shown when a procedural macro can not be found. This usually means that
procedural macro support is simply disabled (and hence is only a weak hint instead of an error),
but can also indicate project setup problems.</p>
<p>If you are seeing a lot of &quot;proc macro not expanded&quot; warnings, you can add this option to the
<code>rust-analyzer.diagnostics.disabled</code> list to prevent them from showing. Alternatively you can
enable support for procedural macros (see <code>rust-analyzer.procMacro.attributes.enable</code>).</p>
<h4 id="unused-mut"><a class="header" href="#unused-mut">unused-mut</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/mutability_errors.rs#45">mutability_errors.rs</a> </p>
<p>This diagnostic is triggered when a mutable variable isn't actually mutated.</p>
<h4 id="unused-variables"><a class="header" href="#unused-variables">unused-variables</a></h4>
<p>Source:  <a href="diagnostics/crates/ide-diagnostics/src/handlers/unused_variables.rs#3">unused_variables.rs</a> </p>
<p>This diagnostic is triggered when a local variable is not used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editor-features"><a class="header" href="#editor-features">Editor Features</a></h1>
<h2 id="vs-code-3"><a class="header" href="#vs-code-3">VS Code</a></h2>
<h3 id="color-configurations"><a class="header" href="#color-configurations">Color configurations</a></h3>
<p>It is possible to change the foreground/background color and font
family/size of inlay hints. Just add this to your <code>settings.json</code>:</p>
<pre><code>{
  &quot;editor.inlayHints.fontFamily&quot;: &quot;Courier New&quot;,
  &quot;editor.inlayHints.fontSize&quot;: 11,

  &quot;workbench.colorCustomizations&quot;: {
    // Name of the theme you are currently using
    &quot;[Default Dark+]&quot;: {
      &quot;editorInlayHint.foreground&quot;: &quot;#868686f0&quot;,
      &quot;editorInlayHint.background&quot;: &quot;#3d3d3d48&quot;,

      // Overrides for specific kinds of inlay hints
      &quot;editorInlayHint.typeForeground&quot;: &quot;#fdb6fdf0&quot;,
      &quot;editorInlayHint.parameterForeground&quot;: &quot;#fdb6fdf0&quot;,
    }
  }
}
</code></pre>
<h3 id="semantic-style-customizations"><a class="header" href="#semantic-style-customizations">Semantic style customizations</a></h3>
<p>You can customize the look of different semantic elements in the source
code. For example, mutable bindings are underlined by default and you
can override this behavior by adding the following section to your
<code>settings.json</code>:</p>
<pre><code>{
  &quot;editor.semanticTokenColorCustomizations&quot;: {
    &quot;rules&quot;: {
      &quot;*.mutable&quot;: {
        &quot;fontStyle&quot;: &quot;&quot;, // underline is the default
      },
    }
  },
}
</code></pre>
<p>Most themes doesn‚Äôt support styling unsafe operations differently yet.
You can fix this by adding overrides for the rules <code>operator.unsafe</code>,
<code>function.unsafe</code>, and <code>method.unsafe</code>:</p>
<pre><code>{
   &quot;editor.semanticTokenColorCustomizations&quot;: {
         &quot;rules&quot;: {
             &quot;operator.unsafe&quot;: &quot;#ff6600&quot;,
             &quot;function.unsafe&quot;: &quot;#ff6600&quot;,
             &quot;method.unsafe&quot;: &quot;#ff6600&quot;
         }
    },
}
</code></pre>
<p>In addition to the top-level rules you can specify overrides for
specific themes. For example, if you wanted to use a darker text color
on a specific light theme, you might write:</p>
<pre><code>{
   &quot;editor.semanticTokenColorCustomizations&quot;: {
         &quot;rules&quot;: {
             &quot;operator.unsafe&quot;: &quot;#ff6600&quot;
         },
         &quot;[Ayu Light]&quot;: {
            &quot;rules&quot;: {
               &quot;operator.unsafe&quot;: &quot;#572300&quot;
            }
         }
    },
}
</code></pre>
<p>Make sure you include the brackets around the theme name. For example,
use <code>&quot;[Ayu Light]&quot;</code> to customize the theme Ayu Light.</p>
<h3 id="special-when-clause-context-for-keybindings"><a class="header" href="#special-when-clause-context-for-keybindings">Special <code>when</code> clause context for keybindings.</a></h3>
<p>You may use <code>inRustProject</code> context to configure keybindings for rust
projects only. For example:</p>
<pre><code>{
  &quot;key&quot;: &quot;ctrl+alt+d&quot;,
  &quot;command&quot;: &quot;rust-analyzer.openDocs&quot;,
  &quot;when&quot;: &quot;inRustProject&quot;
}
</code></pre>
<p>More about <code>when</code> clause contexts
<a href="https://code.visualstudio.com/docs/getstarted/keybindings#_when-clause-contexts">here</a>.</p>
<h3 id="setting-runnable-environment-variables"><a class="header" href="#setting-runnable-environment-variables">Setting runnable environment variables</a></h3>
<p>You can use &quot;rust-analyzer.runnables.extraEnv&quot; setting to define
runnable environment-specific substitution variables. The simplest way
for all runnables in a bunch:</p>
<pre><code>&quot;rust-analyzer.runnables.extraEnv&quot;: {
    &quot;RUN_SLOW_TESTS&quot;: &quot;1&quot;
}
</code></pre>
<p>Or it is possible to specify vars more granularly:</p>
<pre><code>&quot;rust-analyzer.runnables.extraEnv&quot;: [
    {
        // &quot;mask&quot;: null, // null mask means that this rule will be applied for all runnables
        env: {
             &quot;APP_ID&quot;: &quot;1&quot;,
             &quot;APP_DATA&quot;: &quot;asdf&quot;
        }
    },
    {
        &quot;mask&quot;: &quot;test_name&quot;,
        &quot;env&quot;: {
             &quot;APP_ID&quot;: &quot;2&quot;, // overwrites only APP_ID
        }
    }
]
</code></pre>
<p>You can use any valid regular expression as a mask. Also note that a
full runnable name is something like <strong>run bin_or_example_name</strong>,
<strong>test some::mod::test_name</strong> or <strong>test-mod some::mod</strong>, so it is
possible to distinguish binaries, single tests, and test modules with
this masks: <code>&quot;^run&quot;</code>, <code>&quot;^test &quot;</code> (the trailing space matters!), and
<code>&quot;^test-mod&quot;</code> respectively.</p>
<p>If needed, you can set different values for different platforms:</p>
<pre><code>&quot;rust-analyzer.runnables.extraEnv&quot;: [
    {
        &quot;platform&quot;: &quot;win32&quot;, // windows only
        env: {
             &quot;APP_DATA&quot;: &quot;windows specific data&quot;
        }
    },
    {
        &quot;platform&quot;: [&quot;linux&quot;],
        &quot;env&quot;: {
             &quot;APP_DATA&quot;: &quot;linux data&quot;,
        }
    },
    { // for all platforms
        &quot;env&quot;: {
             &quot;APP_COMMON_DATA&quot;: &quot;xxx&quot;,
        }
    }
]
</code></pre>
<h3 id="compiler-feedback-from-external-commands"><a class="header" href="#compiler-feedback-from-external-commands">Compiler feedback from external commands</a></h3>
<p>Instead of relying on the built-in <code>cargo check</code>, you can configure Code
to run a command in the background and use the <code>$rustc-watch</code> problem
matcher to generate inline error markers from its output.</p>
<p>To do this you need to create a new <a href="https://code.visualstudio.com/docs/editor/tasks">VS Code
Task</a> and set
<code>&quot;rust-analyzer.checkOnSave&quot;: false</code> in preferences.</p>
<p>For example, if you want to run
<a href="https://crates.io/crates/cargo-watch"><code>cargo watch</code></a> instead, you might
add the following to <code>.vscode/tasks.json</code>:</p>
<pre><code>{
    &quot;label&quot;: &quot;Watch&quot;,
    &quot;group&quot;: &quot;build&quot;,
    &quot;type&quot;: &quot;shell&quot;,
    &quot;command&quot;: &quot;cargo watch&quot;,
    &quot;problemMatcher&quot;: &quot;$rustc-watch&quot;,
    &quot;isBackground&quot;: true
}
</code></pre>
<h3 id="live-share"><a class="header" href="#live-share">Live Share</a></h3>
<p>VS Code Live Share has partial support for rust-analyzer.</p>
<p>Live Share <em>requires</em> the official Microsoft build of VS Code, OSS
builds will not work correctly.</p>
<p>The host‚Äôs rust-analyzer instance will be shared with all guests joining
the session. The guests do not have to have the rust-analyzer extension
installed for this to work.</p>
<p>If you are joining a Live Share session and <em>do</em> have rust-analyzer
installed locally, commands from the command palette will not work
correctly since they will attempt to communicate with the local server.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
