<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Features - rust-analyzer</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../installation/index.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../troubleshooting/index.html"><strong aria-hidden="true">3.</strong> Troubleshooting</a></li><li class="chapter-item expanded "><a href="../configuration/index.html"><strong aria-hidden="true">4.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="../non_cargo_based_projects/index.html"><strong aria-hidden="true">5.</strong> Non-Cargo Based Projects</a></li><li class="chapter-item expanded "><a href="../security/index.html"><strong aria-hidden="true">6.</strong> Security</a></li><li class="chapter-item expanded "><a href="../privacy/index.html"><strong aria-hidden="true">7.</strong> Privacy</a></li><li class="chapter-item expanded "><a href="../features/index.html" class="active"><strong aria-hidden="true">8.</strong> Features</a></li><li class="chapter-item expanded "><a href="../assists/index.html"><strong aria-hidden="true">9.</strong> Assists (Code Actions)</a></li><li class="chapter-item expanded "><a href="../diagnostics/index.html"><strong aria-hidden="true">10.</strong> Diagnostics</a></li><li class="chapter-item expanded "><a href="../editor_features/index.html"><strong aria-hidden="true">11.</strong> Editor Features</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">rust-analyzer</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-analyzer/rust-analyzer/tree/master/manual" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-analyzer/rust-analyzer/edit/master/manual/src/features/README.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="features"><a class="header" href="#features">Features</a></h1>
<h3 id="annotations"><a class="header" href="#annotations">Annotations</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/annotations.rs#20">annotations.rs</a> </p>
<p>Provides user with annotations above items for looking up references or impl blocks
and running/debugging binaries.</p>
<p><img src="/img/features/annotations.png" alt="Annotations" /></p>
<h3 id="auto-import"><a class="header" href="#auto-import">Auto Import</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-assists/src/handlers/auto_import.rs#15">auto_import.rs</a> </p>
<p>Using the <code>auto-import</code> assist it is possible to insert missing imports for unresolved items.
When inserting an import it will do so in a structured manner by keeping imports grouped,
separated by a newline in the following order:</p>
<ul>
<li><code>std</code> and <code>core</code></li>
<li>External Crates</li>
<li>Current Crate, paths prefixed by <code>crate</code></li>
<li>Current Module, paths prefixed by <code>self</code></li>
<li>Super Module, paths prefixed by <code>super</code></li>
</ul>
<p>Example:</p>
<pre><code class="language-rust">use std::fs::File;

use itertools::Itertools;
use syntax::ast;

use crate::utils::insert_use;

use self::auto_import;

use super::AssistContext;</code></pre>
<h4 id="import-granularity"><a class="header" href="#import-granularity">Import Granularity</a></h4>
<p>It is possible to configure how use-trees are merged with the <code>imports.granularity.group</code> setting.
It has the following configurations:</p>
<ul>
<li><code>crate</code>: Merge imports from the same crate into a single use statement. This kind of
nesting is only supported in Rust versions later than 1.24.</li>
<li><code>module</code>: Merge imports from the same module into a single use statement.</li>
<li><code>item</code>: Don't merge imports at all, creating one import per item.</li>
<li><code>preserve</code>: Do not change the granularity of any imports. For auto-import this has the same
effect as <code>item</code>.</li>
</ul>
<p>In <code>VS Code</code> the configuration for this is <code>rust-analyzer.imports.granularity.group</code>.</p>
<h4 id="import-prefix"><a class="header" href="#import-prefix">Import Prefix</a></h4>
<p>The style of imports in the same crate is configurable through the <code>imports.prefix</code> setting.
It has the following configurations:</p>
<ul>
<li><code>crate</code>: This setting will force paths to be always absolute, starting with the <code>crate</code>
prefix, unless the item is defined outside of the current crate.</li>
<li><code>self</code>: This setting will force paths that are relative to the current module to always
start with <code>self</code>. This will result in paths that always start with either <code>crate</code>, <code>self</code>,
<code>super</code> or an extern crate identifier.</li>
<li><code>plain</code>: This setting does not impose any restrictions in imports.</li>
</ul>
<p>In <code>VS Code</code> the configuration for this is <code>rust-analyzer.imports.prefix</code>.</p>
<p><img src="/img/features/auto_import.gif" alt="Auto Import" /></p>
<h3 id="completion-with-autoimport"><a class="header" href="#completion-with-autoimport">Completion With Autoimport</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-completion/src/completions/flyimport.rs#19">flyimport.rs</a> </p>
<p>When completing names in the current scope, proposes additional imports from other modules or crates,
if they can be qualified in the scope, and their name contains all symbols from the completion input.</p>
<p>To be considered applicable, the name must contain all input symbols in the given order, not necessarily adjacent.
If any input symbol is not lowercased, the name must contain all symbols in exact case; otherwise the containing is checked case-insensitively.</p>
<pre><code>fn main() {
    pda$0
}
# pub mod std { pub mod marker { pub struct PhantomData { } } }
</code></pre>
<p>-&gt;</p>
<pre><code>use std::marker::PhantomData;

fn main() {
    PhantomData
}
# pub mod std { pub mod marker { pub struct PhantomData { } } }
</code></pre>
<p>Also completes associated items, that require trait imports.
If any unresolved and/or partially-qualified path precedes the input, it will be taken into account.
Currently, only the imports with their import path ending with the whole qualifier will be proposed
(no fuzzy matching for qualifier).</p>
<pre><code>mod foo {
    pub mod bar {
        pub struct Item;

        impl Item {
            pub const TEST_ASSOC: usize = 3;
        }
    }
}

fn main() {
    bar::Item::TEST_A$0
}
</code></pre>
<p>-&gt;</p>
<pre><code>use foo::bar;

mod foo {
    pub mod bar {
        pub struct Item;

        impl Item {
            pub const TEST_ASSOC: usize = 3;
        }
    }
}

fn main() {
    bar::Item::TEST_ASSOC
}
</code></pre>
<p>NOTE: currently, if an assoc item comes from a trait that's not currently imported, and it also has an unresolved and/or partially-qualified path,
no imports will be proposed.</p>
<h4 id="fuzzy-search-details"><a class="header" href="#fuzzy-search-details">Fuzzy search details</a></h4>
<p>To avoid an excessive amount of the results returned, completion input is checked for inclusion in the names only
(i.e. in <code>HashMap</code> in the <code>std::collections::HashMap</code> path).
For the same reasons, avoids searching for any path imports for inputs with their length less than 2 symbols
(but shows all associated items for any input length).</p>
<h4 id="import-configuration"><a class="header" href="#import-configuration">Import configuration</a></h4>
<p>It is possible to configure how use-trees are merged with the <code>imports.granularity.group</code> setting.
Mimics the corresponding behavior of the <code>Auto Import</code> feature.</p>
<h4 id="lsp-and-performance-implications"><a class="header" href="#lsp-and-performance-implications">LSP and performance implications</a></h4>
<p>The feature is enabled only if the LSP client supports LSP protocol version 3.16+ and reports the <code>additionalTextEdits</code>
(case-sensitive) resolve client capability in its client capabilities.
This way the server is able to defer the costly computations, doing them for a selected completion item only.
For clients with no such support, all edits have to be calculated on the completion request, including the fuzzy search completion ones,
which might be slow ergo the feature is automatically disabled.</p>
<h4 id="feature-toggle"><a class="header" href="#feature-toggle">Feature toggle</a></h4>
<p>The feature can be forcefully turned off in the settings with the <code>rust-analyzer.completion.autoimport.enable</code> flag.
Note that having this flag set to <code>true</code> does not guarantee that the feature is enabled: your client needs to have the corresponding
capability enabled.</p>
<h3 id="debug-itemtree"><a class="header" href="#debug-itemtree">Debug ItemTree</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/view_item_tree.rs#5">view_item_tree.rs</a> </p>
<p>Displays the ItemTree of the currently open file, for debugging.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Debug ItemTree</strong></td></tr>
</tbody></table>
</div>
<h3 id="expand-macro-recursively"><a class="header" href="#expand-macro-recursively">Expand Macro Recursively</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/expand_macro.rs#15">expand_macro.rs</a> </p>
<p>Shows the full macro expansion of the macro at the current caret position.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Expand macro recursively</strong></td></tr>
</tbody></table>
</div>
<p><img src="https://user-images.githubusercontent.com/48062697/113020648-b3973180-917a-11eb-84a9-ecb921293dc5.gif" alt="Expand Macro Recursively" /></p>
<h3 id="expand-and-shrink-selection"><a class="header" href="#expand-and-shrink-selection">Expand and Shrink Selection</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/extend_selection.rs#15">extend_selection.rs</a> </p>
<p>Extends or shrinks the current selection to the encompassing syntactic construct
(expression, statement, item, module, etc). It works with multiple cursors.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Alt+Shift+→</kbd>, <kbd>Alt+Shift+←</kbd></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/expand_and_shrink_selection.gif" alt="Expand and Shrink Selection" /></p>
<h3 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/file_structure.rs#25">file_structure.rs</a> </p>
<p>Provides a tree of the symbols defined in the file. Can be used to</p>
<ul>
<li>fuzzy search symbol in a file (super useful)</li>
<li>draw breadcrumbs to describe the context around the cursor</li>
<li>draw outline of the file</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+Shift+O</kbd></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/file_structure.gif" alt="File Structure" /></p>
<h3 id="find-all-references"><a class="header" href="#find-all-references">Find All References</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/references.rs#43">references.rs</a> </p>
<p>Shows all references of the item at the cursor location</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Shift+Alt+F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/find_all_references.gif" alt="Find All References" /></p>
<h3 id="folding"><a class="header" href="#folding">Folding</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/folding_ranges.rs#36">folding_ranges.rs</a> </p>
<p>Defines folding regions for curly braced blocks, runs of consecutive use, mod, const or static
items, and <code>region</code> / <code>endregion</code> comment markers.</p>
<h3 id="format-string-completion"><a class="header" href="#format-string-completion">Format String Completion</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-completion/src/completions/postfix/format_like.rs#0">format_like.rs</a> </p>
<p><code>&quot;Result {result} is {2 + 2}&quot;</code> is expanded to the <code>&quot;Result {} is {}&quot;, result, 2 + 2</code>.</p>
<p>The following postfix snippets are available:</p>
<ul>
<li><code>format</code> -&gt; <code>format!(...)</code></li>
<li><code>panic</code> -&gt; <code>panic!(...)</code></li>
<li><code>println</code> -&gt; <code>println!(...)</code></li>
<li><code>log</code>:
** <code>logd</code> -&gt; <code>log::debug!(...)</code>
** <code>logt</code> -&gt; <code>log::trace!(...)</code>
** <code>logi</code> -&gt; <code>log::info!(...)</code>
** <code>logw</code> -&gt; <code>log::warn!(...)</code>
** <code>loge</code> -&gt; <code>log::error!(...)</code></li>
</ul>
<p><img src="/img/features/format_string_completion.gif" alt="Format String Completion" /></p>
<h3 id="go-to-declaration"><a class="header" href="#go-to-declaration">Go to Declaration</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/goto_declaration.rs#13">goto_declaration.rs</a> </p>
<p>Navigates to the declaration of an identifier.</p>
<p>This is the same as <code>Go to Definition</code> with the following exceptions:</p>
<ul>
<li>outline modules will navigate to the <code>mod name;</code> item declaration</li>
<li>trait assoc items will navigate to the assoc item of the trait declaration opposed to the trait impl</li>
<li>fields in patterns will navigate to the field declaration of the struct, union or variant</li>
</ul>
<h3 id="go-to-definition"><a class="header" href="#go-to-definition">Go to Definition</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/goto_definition.rs#17">goto_definition.rs</a> </p>
<p>Navigates to the definition of an identifier.</p>
<p>For outline modules, this will navigate to the source file of the module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/go_to_definition.gif" alt="Go to Definition" /></p>
<h3 id="go-to-implementation"><a class="header" href="#go-to-implementation">Go to Implementation</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/goto_implementation.rs#12">goto_implementation.rs</a> </p>
<p>Navigates to the impl blocks of types.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+F12</kbd></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/go_to_implementation.gif" alt="Go to Implementation" /></p>
<h3 id="go-to-type-definition"><a class="header" href="#go-to-type-definition">Go to Type Definition</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/goto_type_definition.rs#6">goto_type_definition.rs</a> </p>
<p>Navigates to the type of an identifier.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Go to Type Definition</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/go_to_type_definition.gif" alt="Go to Type Definition" /></p>
<h3 id="highlight-related"><a class="header" href="#highlight-related">Highlight Related</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/highlight_related.rs#40">highlight_related.rs</a> </p>
<p>Highlights constructs related to the thing under the cursor:</p>
<p>. if on an identifier, highlights all references to that identifier in the current file
.. additionally, if the identifier is a trait in a where clause, type parameter trait bound or use item, highlights all references to that trait's assoc items in the corresponding scope
. if on an <code>async</code> or <code>await token, highlights all yield points for that async context . if on a </code>return<code>or</code>fn<code>keyword,</code>?<code>character or</code>-&gt;<code>return type arrow, highlights all exit points for that context . if on a</code>break<code>, </code>loop<code>, </code>while<code>or</code>for<code>token, highlights all break points for that loop or block context . if on a</code>move<code>or</code>|` token that belongs to a closure, highlights all captures of the closure.</p>
<p>Note: <code>?</code>, <code>|</code> and <code>-&gt;</code> do not currently trigger this behavior in the VSCode editor.</p>
<h3 id="hover"><a class="header" href="#hover">Hover</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/hover.rs#97">hover.rs</a> </p>
<p>Shows additional information, like the type of an expression or the documentation for a definition when &quot;focusing&quot; code.
Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.</p>
<p><img src="/img/features/hover.gif" alt="Hover" /></p>
<h3 id="inlay-hints"><a class="header" href="#inlay-hints">Inlay Hints</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/inlay_hints.rs#421">inlay_hints.rs</a> </p>
<p>rust-analyzer shows additional information inline with the source code.
Editors usually render this using read-only virtual text snippets interspersed with code.</p>
<p>rust-analyzer by default shows hints for</p>
<ul>
<li>types of local variables</li>
<li>names of function arguments</li>
<li>types of chained expressions</li>
</ul>
<p>Optionally, one can enable additional hints for</p>
<ul>
<li>return types of closure expressions</li>
<li>elided lifetimes</li>
<li>compiler inserted reborrows</li>
</ul>
<p><img src="/img/features/inlay_hints.png" alt="Hover" /></p>
<h3 id="interpret-function"><a class="header" href="#interpret-function">Interpret Function</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/interpret_function.rs#9">interpret_function.rs</a> </p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Interpret Function</strong></td></tr>
</tbody></table>
</div>
<h3 id="join-lines"><a class="header" href="#join-lines">Join Lines</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/join_lines.rs#20">join_lines.rs</a> </p>
<p>Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.</p>
<p>See <a href="img/features/join_lines-1.gif">this gif</a> for the cases handled specially by joined lines.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Join lines</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/join_lines-2.gif" alt="Join Lines" /></p>
<h3 id="magic-completions"><a class="header" href="#magic-completions">Magic Completions</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-completion/src/lib.rs#45">lib.rs</a> </p>
<p>In addition to usual reference completion, rust-analyzer provides some ✨magic✨
completions as well:</p>
<p>Keywords like <code>if</code>, <code>else</code> <code>while</code>, <code>loop</code> are completed with braces, and cursor
is placed at the appropriate position. Even though <code>if</code> is easy to type, you
still want to complete it, to get <code> { }</code> for free! <code>return</code> is inserted with a
space or <code>;</code> depending on the return type of the function.</p>
<p>When completing a function call, <code>()</code> are automatically inserted. If a function
takes arguments, the cursor is positioned inside the parenthesis.</p>
<p>There are postfix completions, which can be triggered by typing something like
<code>foo().if</code>. The word after <code>.</code> determines postfix completion. Possible variants are:</p>
<ul>
<li><code>expr.if</code> -&gt; <code>if expr {}</code> or <code>if let ... {}</code> for <code>Option</code> or <code>Result</code></li>
<li><code>expr.match</code> -&gt; <code>match expr {}</code></li>
<li><code>expr.while</code> -&gt; <code>while expr {}</code> or <code>while let ... {}</code> for <code>Option</code> or <code>Result</code></li>
<li><code>expr.ref</code> -&gt; <code>&amp;expr</code></li>
<li><code>expr.refm</code> -&gt; <code>&amp;mut expr</code></li>
<li><code>expr.let</code> -&gt; <code>let $0 = expr;</code></li>
<li><code>expr.letm</code> -&gt; <code>let mut $0 = expr;</code></li>
<li><code>expr.not</code> -&gt; <code>!expr</code></li>
<li><code>expr.dbg</code> -&gt; <code>dbg!(expr)</code></li>
<li><code>expr.dbgr</code> -&gt; <code>dbg!(&amp;expr)</code></li>
<li><code>expr.call</code> -&gt; <code>(expr)</code></li>
</ul>
<p>There also snippet completions:</p>
<h4 id="expressions"><a class="header" href="#expressions">Expressions</a></h4>
<ul>
<li><code>pd</code> -&gt; <code>eprintln!(&quot; = {:?}&quot;, );</code></li>
<li><code>ppd</code> -&gt; <code>eprintln!(&quot; = {:#?}&quot;, );</code></li>
</ul>
<h4 id="items"><a class="header" href="#items">Items</a></h4>
<ul>
<li><code>tfn</code> -&gt; <code>#[test] fn feature(){}</code></li>
<li><code>tmod</code> -&gt;</li>
</ul>
<pre><code class="language-rust">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_name() {}
}</code></pre>
<p>And the auto import completions, enabled with the <code>rust-analyzer.completion.autoimport.enable</code> setting and the corresponding LSP client capabilities.
Those are the additional completion options with automatic <code>use</code> import and options from all project importable items,
fuzzy matched against the completion input.</p>
<p><img src="/img/features/magic_completions.gif" alt="Magic Completions" /></p>
<h3 id="matching-brace"><a class="header" href="#matching-brace">Matching Brace</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/matching_brace.rs#6">matching_brace.rs</a> </p>
<p>If the cursor is on any brace (<code>&lt;&gt;(){}[]||</code>) which is a part of a brace-pair,
moves cursor to the matching brace. It uses the actual parser to determine
braces, so it won't confuse generics with comparisons.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Find matching brace</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/matching_brace.gif" alt="Matching Brace" /></p>
<h3 id="memory-usage"><a class="header" href="#memory-usage">Memory Usage</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-db/src/apply_change.rs#43">apply_change.rs</a> </p>
<p>Clears rust-analyzer's internal database and prints memory usage statistics.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Memory Usage (Clears Database)</strong></td></tr>
</tbody></table>
</div>
<h3 id="move-item"><a class="header" href="#move-item">Move Item</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/move_item.rs#15">move_item.rs</a> </p>
<p>Move item under cursor or selection up and down.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Move item up</strong></td></tr>
<tr><td>VS Code</td><td><strong>rust-analyzer: Move item down</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/move_item.gif" alt="Move Item" /></p>
<h3 id="on-enter"><a class="header" href="#on-enter">On Enter</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/typing/on_enter.rs#16">on_enter.rs</a> </p>
<p>rust-analyzer can override kbd:[Enter] key to make it smarter:</p>
<ul>
<li><kbd>Enter</kbd> inside triple-slash comments automatically inserts <code>///</code></li>
<li><kbd>Enter</kbd> in the middle or after a trailing space in <code>//</code> inserts <code>//</code></li>
<li><kbd>Enter</kbd> inside <code>//!</code> doc comments automatically inserts <code>//!</code></li>
<li><kbd>Enter</kbd> after <code>{</code> indents contents and closing <code>}</code> of single-line block</li>
</ul>
<p>This action needs to be assigned to shortcut explicitly.</p>
<p>Note that, depending on the other installed extensions, this feature can visibly slow down typing.
Similarly, if rust-analyzer crashes or stops responding, <code>Enter</code> might not work.
In that case, you can still press <code>Shift-Enter</code> to insert a newline.</p>
<p>VS Code::</p>
<p>Add the following to <code>keybindings.json</code>:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;Enter&quot;,
  &quot;command&quot;: &quot;rust-analyzer.onEnter&quot;,
  &quot;when&quot;: &quot;editorTextFocus &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == rust&quot;
}
</code></pre>
<p>When using the Vim plugin:</p>
<pre><code class="language-json">{
  &quot;key&quot;: &quot;Enter&quot;,
  &quot;command&quot;: &quot;rust-analyzer.onEnter&quot;,
  &quot;when&quot;: &quot;editorTextFocus &amp;&amp; !suggestWidgetVisible &amp;&amp; editorLangId == rust &amp;&amp; vim.mode == 'Insert'&quot;
}
</code></pre>
<p><img src="/img/features/on_enter.gif" alt="On Enter" /></p>
<h3 id="on-typing-assists"><a class="header" href="#on-typing-assists">On Typing Assists</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/typing.rs#42">typing.rs</a> </p>
<p>Some features trigger on typing certain characters:</p>
<ul>
<li>typing <code>let =</code> tries to smartly add <code>;</code> if <code>=</code> is followed by an existing expression</li>
<li>typing <code>=</code> between two expressions adds <code>;</code> when in statement position</li>
<li>typing <code>=</code> to turn an assignment into an equality comparison removes <code>;</code> when in expression position</li>
<li>typing <code>.</code> in a chain method call auto-indents</li>
<li>typing <code>{</code> or <code>(</code> in front of an expression inserts a closing <code>}</code> or <code>)</code> after the expression</li>
<li>typing <code>{</code> in a use item adds a closing <code>}</code> in the right place</li>
</ul>
<p>VS Code::</p>
<p>Add the following to <code>settings.json</code>:</p>
<pre><code class="language-json">&quot;editor.formatOnType&quot;: true,
</code></pre>
<p><img src="/img/features/on_typing_assists-1.gif" alt="On Typing Assists" />
<img src="/img/features/on_typing_assists-2.gif" alt="On Typing Assists" /></p>
<h3 id="open-docs"><a class="header" href="#open-docs">Open Docs</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/doc_links.rs#121">doc_links.rs</a> </p>
<p>Retrieve a links to documentation for the given symbol.</p>
<p>The simplest way to use this feature is via the context menu. Right-click on
the selected item. The context menu opens. Select <strong>Open Docs</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Open Docs</strong></td></tr>
</tbody></table>
</div>
<h3 id="parent-module"><a class="header" href="#parent-module">Parent Module</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/parent_module.rs#14">parent_module.rs</a> </p>
<p>Navigates to the parent module of the current module.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Locate parent module</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/parent_module.gif" alt="Parent Module" /></p>
<h3 id="related-tests"><a class="header" href="#related-tests">Related Tests</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/runnables.rs#194">runnables.rs</a> </p>
<p>Provides a sneak peek of all tests where the current item is used.</p>
<p>The simplest way to use this feature is via the context menu. Right-click on
the selected item. The context menu opens. Select <strong>Peek Related Tests</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Peek Related Tests</strong></td></tr>
</tbody></table>
</div>
<h3 id="rename"><a class="header" href="#rename">Rename</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/rename.rs#73">rename.rs</a> </p>
<p>Renames the item below the cursor and all of its references</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>F2</kbd></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/rename.gif" alt="Rename" /></p>
<h3 id="run"><a class="header" href="#run">Run</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/runnables.rs#111">runnables.rs</a> </p>
<p>Shows a popup suggesting to run a test/benchmark/binary <strong>at the current cursor
location</strong>. Super useful for repeatedly running just a single test. Do bind this
to a shortcut!</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Run</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/run.gif" alt="Run" /></p>
<h3 id="semantic-syntax-highlighting"><a class="header" href="#semantic-syntax-highlighting">Semantic Syntax Highlighting</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/syntax_highlighting.rs#65">syntax_highlighting.rs</a> </p>
<p>rust-analyzer highlights the code semantically.
For example, <code>Bar</code> in <code>foo::Bar</code> might be colored differently depending on whether <code>Bar</code> is an enum or a trait.
rust-analyzer does not specify colors directly, instead it assigns a tag (like <code>struct</code>) and a set of modifiers (like <code>declaration</code>) to each token.
It's up to the client to map those to specific colors.</p>
<p>The general rule is that a reference to an entity gets colored the same way as the entity itself.
We also give special modifier for <code>mut</code> and <code>&amp;mut</code> local variables.</p>
<h4 id="token-tags"><a class="header" href="#token-tags">Token Tags</a></h4>
<p>Rust-analyzer currently emits the following token tags:</p>
<ul>
<li>For items:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>attribute</td><td>Emitted for attribute macros.</td></tr>
<tr><td>enum</td><td>Emitted for enums.</td></tr>
<tr><td>function</td><td>Emitted for free-standing functions.</td></tr>
<tr><td>derive</td><td>Emitted for derive macros.</td></tr>
<tr><td>macro</td><td>Emitted for function-like macros.</td></tr>
<tr><td>method</td><td>Emitted for associated functions, also knowns as methods.</td></tr>
<tr><td>namespace</td><td>Emitted for modules.</td></tr>
<tr><td>struct</td><td>Emitted for structs.</td></tr>
<tr><td>trait</td><td>Emitted for traits.</td></tr>
<tr><td>typeAlias</td><td>Emitted for type aliases and <code>Self</code> in <code>impl</code>s.</td></tr>
<tr><td>union</td><td>Emitted for unions.</td></tr>
</tbody></table>
</div>
<ul>
<li>For literals:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>boolean</td><td>Emitted for the boolean literals <code>true</code> and <code>false</code>.</td></tr>
<tr><td>character</td><td>Emitted for character literals.</td></tr>
<tr><td>number</td><td>Emitted for numeric literals.</td></tr>
<tr><td>string</td><td>Emitted for string literals.</td></tr>
<tr><td>escapeSequence</td><td>Emitted for escaped sequences inside strings like <code>\n</code>.</td></tr>
<tr><td>formatSpecifier</td><td>Emitted for format specifiers <code>{:?}</code> in <code>format!</code>-like macros.</td></tr>
</tbody></table>
</div>
<ul>
<li>For operators:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>operator</td><td>Emitted for general operators.</td></tr>
<tr><td>arithmetic</td><td>Emitted for the arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>.</td></tr>
<tr><td>bitwise</td><td>Emitted for the bitwise operators `</td></tr>
<tr><td>comparison</td><td>Emitted for the comparison oerators <code>&gt;</code>, <code>&lt;</code>, <code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>!=</code>.</td></tr>
<tr><td>logical</td><td>Emitted for the logical operatos `</td></tr>
</tbody></table>
</div>
<ul>
<li>For punctuation:</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>punctuation</td><td>Emitted for general punctuation.</td></tr>
<tr><td>attributeBracket</td><td>Emitted for attribute invocation brackets, that is the <code>#[</code> and <code>]</code> tokens.</td></tr>
<tr><td>angle</td><td>Emitted for <code>&lt;&gt;</code> angle brackets.</td></tr>
<tr><td>brace</td><td>Emitted for <code>{}</code> braces.</td></tr>
<tr><td>bracket</td><td>Emitted for <code>[]</code> brackets.</td></tr>
<tr><td>parenthesis</td><td>Emitted for <code>()</code> parentheses.</td></tr>
<tr><td>colon</td><td>Emitted for the <code>:</code> token.</td></tr>
<tr><td>comma</td><td>Emitted for the <code>,</code> token.</td></tr>
<tr><td>dot</td><td>Emitted for the <code>.</code> token.</td></tr>
<tr><td>semi</td><td>Emitted for the <code>;</code> token.</td></tr>
<tr><td>macroBang</td><td>Emitted for the <code>!</code> token in macro calls.</td></tr>
</tbody></table>
</div>
<ul>
<li></li>
</ul>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>builtinAttribute</td><td>Emitted for names to builtin attributes in attribute path, the <code>repr</code> in <code>#[repr(u8)]</code> for example.</td></tr>
<tr><td>builtinType</td><td>Emitted for builtin types like <code>u32</code>, <code>str</code> and <code>f32</code>.</td></tr>
<tr><td>comment</td><td>Emitted for comments.</td></tr>
<tr><td>constParameter</td><td>Emitted for const parameters.</td></tr>
<tr><td>deriveHelper</td><td>Emitted for derive helper attributes.</td></tr>
<tr><td>enumMember</td><td>Emitted for enum variants.</td></tr>
<tr><td>generic</td><td>Emitted for generic tokens that have no mapping.</td></tr>
<tr><td>keyword</td><td>Emitted for keywords.</td></tr>
<tr><td>label</td><td>Emitted for labels.</td></tr>
<tr><td>lifetime</td><td>Emitted for lifetimes.</td></tr>
<tr><td>parameter</td><td>Emitted for non-self function parameters.</td></tr>
<tr><td>property</td><td>Emitted for struct and union fields.</td></tr>
<tr><td>selfKeyword</td><td>Emitted for the self function parameter and self path-specifier.</td></tr>
<tr><td>selfTypeKeyword</td><td>Emitted for the Self type parameter.</td></tr>
<tr><td>toolModule</td><td>Emitted for tool modules.</td></tr>
<tr><td>typeParameter</td><td>Emitted for type parameters.</td></tr>
<tr><td>unresolvedReference</td><td>Emitted for unresolved references, names that rust-analyzer can't find the definition of.</td></tr>
<tr><td>variable</td><td>Emitted for locals, constants and statics.</td></tr>
</tbody></table>
</div>
<h4 id="token-modifiers"><a class="header" href="#token-modifiers">Token Modifiers</a></h4>
<p>Token modifiers allow to style some elements in the source code more precisely.</p>
<p>Rust-analyzer currently emits the following token modifiers:</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>async</td><td>Emitted for async functions and the <code>async</code> and <code>await</code> keywords.</td></tr>
<tr><td>attribute</td><td>Emitted for tokens inside attributes.</td></tr>
<tr><td>callable</td><td>Emitted for locals whose types implements one of the <code>Fn*</code> taits.</td></tr>
<tr><td>constant</td><td>Emitted for const.</td></tr>
<tr><td>consuming</td><td>Emitted for locals that are being consumed when use in a fuction call.</td></tr>
<tr><td>controlFlow</td><td>Emitted for control-flow related tokens, this includes th <code>?</code> operator.</td></tr>
<tr><td>crateRoot</td><td>Emitted for crate names, like <code>serde</code> and `crate.</td></tr>
<tr><td>declaration</td><td>Emitted for names of definitions, like <code>foo</code> in <code>fn foo(){}</code>.</td></tr>
<tr><td>defaultLibrary</td><td>Emitted for items from built-in crates (std, core, allc, test and proc_macro).</td></tr>
<tr><td>documentation</td><td>Emitted for documentation comment.</td></tr>
<tr><td>injected</td><td>Emitted for doc-string injected highlighting like rust sourc blocks in documentation.</td></tr>
<tr><td>intraDocLink</td><td>Emitted for intra doc links in doc-string.</td></tr>
<tr><td>library</td><td>Emitted for items that are defined outside of the current crae.</td></tr>
<tr><td>macro</td><td>Emitted for tokens inside macro call.</td></tr>
<tr><td>mutable</td><td>Emitted for mutable locals and statics as well as functions tking <code>&amp;mut self</code>.</td></tr>
<tr><td>public</td><td>Emitted for items that are from the current crate and are `pub.</td></tr>
<tr><td>reference</td><td>Emitted for locals behind a reference and functions taking self` by reference.</td></tr>
<tr><td>static</td><td>Emitted for &quot;static&quot; functions, also known as functions that d not take a <code>self</code> param, as well as statics and consts.</td></tr>
<tr><td>trait</td><td>Emitted for associated trait item.</td></tr>
<tr><td>unsafe</td><td>Emitted for unsafe operations, like unsafe function calls, as ell as the <code>unsafe</code> token.</td></tr>
</tbody></table>
</div>
<p><img src="/img/features/semantic_syntax_highlighting-1.png" alt="Semantic Syntax Highlighting" />
<img src="/img/features/semantic_syntax_highlighting-2.png" alt="Semantic Syntax Highlighting" /></p>
<h3 id="show-dependency-tree"><a class="header" href="#show-dependency-tree">Show Dependency Tree</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/fetch_crates.rs#13">fetch_crates.rs</a> </p>
<p>Shows a view tree with all the dependencies of this project</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Panel Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>Rust Dependencies</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/show_dependency_tree.png" alt="Show Dependency Tree" /></p>
<h3 id="show-syntax-tree"><a class="header" href="#show-syntax-tree">Show Syntax Tree</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/syntax_tree.rs#9">syntax_tree.rs</a> </p>
<p>Shows the parse tree of the current file. It exists mostly for debugging
rust-analyzer itself.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Show Syntax Tree</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/show_syntax_tree.gif" alt="Show Syntax Tree" /></p>
<h3 id="shuffle-crate-graph"><a class="header" href="#shuffle-crate-graph">Shuffle Crate Graph</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/shuffle_crate_graph.rs#7">shuffle_crate_graph.rs</a> </p>
<p>Randomizes all crate IDs in the crate graph, for debugging.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Shuffle Crate Graph</strong></td></tr>
</tbody></table>
</div>
<h3 id="status"><a class="header" href="#status">Status</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/status.rs#28">status.rs</a> </p>
<p>Shows internal statistic about memory usage of rust-analyzer.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Status</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/status.gif" alt="Status" /></p>
<h3 id="structural-search-and-replace"><a class="header" href="#structural-search-and-replace">Structural Search and Replace</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-ssr/src/lib.rs#8">lib.rs</a> </p>
<p>Search and replace with named wildcards that will match any expression, type, path, pattern or item.
The syntax for a structural search replace command is <code>&lt;search_pattern&gt; ==&gt;&gt; &lt;replace_pattern&gt;</code>.
A <code>$&lt;name&gt;</code> placeholder in the search pattern will match any AST node and <code>$&lt;name&gt;</code> will reference it in the replacement.
Within a macro call, a placeholder will match up until whatever token follows the placeholder.</p>
<p>All paths in both the search pattern and the replacement template must resolve in the context
in which this command is invoked. Paths in the search pattern will then match the code if they
resolve to the same item, even if they're written differently. For example if we invoke the
command in the module <code>foo</code> with a pattern of <code>Bar</code>, then code in the parent module that refers
to <code>foo::Bar</code> will match.</p>
<p>Paths in the replacement template will be rendered appropriately for the context in which the
replacement occurs. For example if our replacement template is <code>foo::Bar</code> and we match some
code in the <code>foo</code> module, we'll insert just <code>Bar</code>.</p>
<p>Inherent method calls should generally be written in UFCS form. e.g. <code>foo::Bar::baz($s, $a)</code> will
match <code>$s.baz($a)</code>, provided the method call <code>baz</code> resolves to the method <code>foo::Bar::baz</code>. When a
placeholder is the receiver of a method call in the search pattern (e.g. <code>$s.foo()</code>), but not in
the replacement template (e.g. <code>bar($s)</code>), then *, &amp; and &amp;mut will be added as needed to mirror
whatever autoderef and autoref was happening implicitly in the matched code.</p>
<p>The scope of the search / replace will be restricted to the current selection if any, otherwise
it will apply to the whole workspace.</p>
<p>Placeholders may be given constraints by writing them as <code>${&lt;name&gt;:&lt;constraint1&gt;:&lt;constraint2&gt;...}</code>.</p>
<p>Supported constraints:</p>
<div class="table-wrapper"><table><thead><tr><th>Constraint</th><th>Restricts placeholder</th></tr></thead><tbody>
<tr><td>kind(literal)</td><td>Is a literal (e.g. <code>42</code> or <code>&quot;forty two&quot;</code>)</td></tr>
<tr><td>not(a)</td><td>Negates the constraint <code>a</code></td></tr>
</tbody></table>
</div>
<p>Available via the command <code>rust-analyzer.ssr</code>.</p>
<pre><code class="language-rust">// Using structural search replace command [foo($a, $b) ==&gt;&gt; ($a).foo($b)]

// BEFORE
String::from(foo(y + 5, z))

// AFTER
String::from((y + 5).foo(z))</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: Structural Search Replace</strong></td></tr>
</tbody></table>
</div>
<p>Also available as an assist, by writing a comment containing the structural
search and replace rule. You will only see the assist if the comment can
be parsed as a valid structural search and replace rule.</p>
<pre><code class="language-rust">// Place the cursor on the line below to see the assist 💡.
// foo($a, $b) ==&gt;&gt; ($a).foo($b)</code></pre>
<h3 id="user-snippet-completions"><a class="header" href="#user-snippet-completions">User Snippet Completions</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-completion/src/snippet.rs#5">snippet.rs</a> </p>
<p>rust-analyzer allows the user to define custom (postfix)-snippets that may depend on items to be accessible for the current scope to be applicable.</p>
<p>A custom snippet can be defined by adding it to the <code>rust-analyzer.completion.snippets.custom</code> object respectively.</p>
<pre><code class="language-json">{
  &quot;rust-analyzer.completion.snippets.custom&quot;: {
    &quot;thread spawn&quot;: {
      &quot;prefix&quot;: [&quot;spawn&quot;, &quot;tspawn&quot;],
      &quot;body&quot;: [
        &quot;thread::spawn(move || {&quot;,
        &quot;\t$0&quot;,
        &quot;});&quot;,
      ],
      &quot;description&quot;: &quot;Insert a thread::spawn call&quot;,
      &quot;requires&quot;: &quot;std::thread&quot;,
      &quot;scope&quot;: &quot;expr&quot;,
    }
  }
}
</code></pre>
<p>In the example above:</p>
<ul>
<li>
<p><code>&quot;thread spawn&quot;</code> is the name of the snippet.</p>
</li>
<li>
<p><code>prefix</code> defines one or more trigger words that will trigger the snippets completion.
Using <code>postfix</code> will instead create a postfix snippet.</p>
</li>
<li>
<p><code>body</code> is one or more lines of content joined via newlines for the final output.</p>
</li>
<li>
<p><code>description</code> is an optional description of the snippet, if unset the snippet name will be used.</p>
</li>
<li>
<p><code>requires</code> is an optional list of item paths that have to be resolvable in the current crate where the completion is rendered.</p>
</li>
</ul>
<h3 id="view-crate-graph"><a class="header" href="#view-crate-graph">View Crate Graph</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/view_crate_graph.rs#8">view_crate_graph.rs</a> </p>
<p>Renders the currently loaded crate graph as an SVG graphic. Requires the <code>dot</code> tool, which
is part of graphviz, to be installed.</p>
<p>Only workspace crates are included, no crates.io dependencies or sysroot crates.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Crate Graph</strong></td></tr>
</tbody></table>
</div>
<h3 id="view-hir"><a class="header" href="#view-hir">View Hir</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/view_hir.rs#6">view_hir.rs</a> </p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Hir</strong></td></tr>
</tbody></table>
</div>
<p><img src="/img/features/view_hir.gif" alt="View Hir" /></p>
<h3 id="view-memory-layout"><a class="header" href="#view-memory-layout">View Memory Layout</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/view_memory_layout.rs#77">view_memory_layout.rs</a> </p>
<p>Displays the recursive memory layout of a datatype.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Memory Layout</strong></td></tr>
</tbody></table>
</div>
<h3 id="view-mir"><a class="header" href="#view-mir">View Mir</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide/src/view_mir.rs#6">view_mir.rs</a> </p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Action Name</th></tr></thead><tbody>
<tr><td>VS Code</td><td><strong>rust-analyzer: View Mir</strong></td></tr>
</tbody></table>
</div>
<h3 id="workspace-symbol"><a class="header" href="#workspace-symbol">Workspace Symbol</a></h3>
<p><strong>Source:</strong>  <a href="crates/ide-db/src/symbol_index.rs#181">symbol_index.rs</a> </p>
<p>Uses fuzzy-search to find types, modules and functions by name across your
project and dependencies. This is <strong>the</strong> most useful feature, which improves code
navigation tremendously. It mostly works on top of the built-in LSP
functionality, however <code>#</code> and <code>*</code> symbols can be used to narrow down the
search. Specifically,</p>
<ul>
<li><code>Foo</code> searches for <code>Foo</code> type in the current workspace</li>
<li><code>foo#</code> searches for <code>foo</code> function in the current workspace</li>
<li><code>Foo*</code> searches for <code>Foo</code> type among dependencies, including <code>stdlib</code></li>
<li><code>foo#*</code> searches for <code>foo</code> function among dependencies</li>
</ul>
<p>That is, <code>#</code> switches from &quot;types&quot; to all symbols, <code>*</code> switches from the current
workspace to dependencies.</p>
<p>Note that filtering does not currently work in VSCode due to the editor never
sending the special symbols to the language server. Instead, you can configure
the filtering via the <code>rust-analyzer.workspace.symbol.search.scope</code> and
<code>rust-analyzer.workspace.symbol.search.kind</code> settings.</p>
<div class="table-wrapper"><table><thead><tr><th>Editor</th><th>Shortcut</th></tr></thead><tbody>
<tr><td>VS Code</td><td><kbd>Ctrl+T</kbd></td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../privacy/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../assists/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../privacy/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../assists/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
